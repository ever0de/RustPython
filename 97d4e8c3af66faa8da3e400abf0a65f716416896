crates/stdlib/src/sqlite.rs
  f2a0666 836,838-839,870,872-873,903-906,908-911,913-914,916-930,1028,1471-1474,1478,1481,1655,1704,1870-1871
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "1.0.21",
  "base_commit_sha": "97d4e8c3af66faa8da3e400abf0a65f716416896",
  "prompts": {
    "f2a0666": {
      "agent_id": {
        "tool": "github-copilot",
        "id": "84d11851-d457-42b6-8e54-18b0407fd43e",
        "model": "copilot/gpt-5.1-codex"
      },
      "human_author": "Jiseok CHOI <jiseok.dev@gmail.com>",
      "messages": [
        {
          "type": "user",
          "text": "당신은 RustPython 시니어 개발자입니다. \n\nhttps://github.com/RustPython/RustPython/issues/6287 \n다음 이슈를 해결하려고 하며, test_connection_bad_reinit 테스트를 통과하도록 stdlib/sqlite모듈의 Connection의 \n- initializer가 두번째부터 호출되었을때 operationalError를 발생\n- uninitialize상태일때 executemany에서 ProgrammingError를 발생\n하는 구현을 진행해주세요.\n\n1. 먼저 branch를 영어로 이슈로 파주시고\n2. 작업을 진행한뒤 테스트가 통과하는지 확인\n3. clippy, fmt 진행\n4. 커밋을 영어로 수정사항과 함께 첨부해주세요.\n\n동작에 대해 애매모한부분이 생긴다면 최신버전의 CPython구현을 참고하세요.\nhttps://github.com/python/cpython/blob/main/Modules/_sqlite/connection.c",
          "timestamp": "2025-11-21T16:00:39.805+00:00"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#700-700), 700 줄에서 1100 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_fetchWebPage"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_fetchWebPage",
          "input": "\"웹 페이지 가져오기\" 사용"
        },
        {
          "type": "tool_use",
          "name": "vscode_fetchWebPage_internal",
          "input": "https://raw.githubusercontent.com/python/cpython/main/Modules/_sqlite/connection.c을(를) 가져오는 중"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `struct Cursor` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#1400-1400), 1400 줄에서 1800 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "정규식 `fn new\\(zelf: &PyRef<Connection>,` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `struct Statement` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#2400-2400), 2400 줄에서 2800 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `struct ConnectArgs` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#200-200), 200 줄에서 420 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `fn connect` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#600-600), 600 줄에서 720 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `trait Constructor` (`**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/vm/src/types/slot.rs#780-780), 780 줄에서 940 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "textEditGroup",
          "input": {
            "done": true,
            "edits": [
              [
                {
                  "range": {
                    "endColumn": 1,
                    "endLineNumber": 3387,
                    "startColumn": 1,
                    "startLineNumber": 1
                  },
                  "text": "// spell-checker:ignore libsqlite3 threadsafety PYSQLITE decltypes colnames collseq cantinit dirtywal\n// spell-checker:ignore corruptfs narg setinputsizes setoutputsize lastrowid arraysize executemany\n// spell-checker:ignore blobopen executescript iterdump getlimit setlimit errorcode errorname\n// spell-checker:ignore rowid rowcount fetchone fetchmany fetchall errcode errname vtable pagecount\n// spell-checker:ignore autocommit libversion toobig errmsg nomem threadsafe longlong vdbe reindex\n// spell-checker:ignore savepoint cantopen ioerr nolfs nomem notadb notfound fullpath notempdir vtab\n// spell-checker:ignore checkreservedlock noent fstat rdlock shmlock shmmap shmopen shmsize sharedcache\n// spell-checker:ignore cantlock commithook foreignkey notnull primarykey gettemppath autoindex convpath\n// spell-checker:ignore dbmoved vnode nbytes\n\nuse rustpython_vm::{AsObject, PyRef, VirtualMachine, builtins::PyModule};\n\n// pub(crate) use _sqlite::make_module;\npub(crate) fn make_module(vm: &VirtualMachine) -> PyRef<PyModule> {\n    // TODO: sqlite version check\n    let module = _sqlite::make_module(vm);\n    _sqlite::setup_module(module.as_object(), vm);\n    module\n}\n\n#[pymodule]\nmod _sqlite {\n    use crossbeam_utils::atomic::AtomicCell;\n    use libsqlite3_sys::{\n        SQLITE_BLOB, SQLITE_DETERMINISTIC, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL,\n        SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, SQLITE_OPEN_URI, SQLITE_TEXT, SQLITE_TRACE_STMT,\n        SQLITE_TRANSIENT, SQLITE_UTF8, sqlite3, sqlite3_aggregate_context, sqlite3_backup_finish,\n        sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining,\n        sqlite3_backup_step, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64,\n        sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name,\n        sqlite3_bind_text, sqlite3_blob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open,\n        sqlite3_blob_read, sqlite3_blob_write, sqlite3_busy_timeout, sqlite3_changes,\n        sqlite3_close_v2, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count,\n        sqlite3_column_decltype, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_name,\n        sqlite3_column_text, sqlite3_column_type, sqlite3_complete, sqlite3_context,\n        sqlite3_context_db_handle, sqlite3_create_collation_v2, sqlite3_create_function_v2,\n        sqlite3_create_window_function, sqlite3_data_count, sqlite3_db_handle, sqlite3_errcode,\n        sqlite3_errmsg, sqlite3_exec, sqlite3_expanded_sql, sqlite3_extended_errcode,\n        sqlite3_finalize, sqlite3_get_autocommit, sqlite3_interrupt, sqlite3_last_insert_rowid,\n        sqlite3_libversion, sqlite3_limit, sqlite3_open_v2, sqlite3_prepare_v2,\n        sqlite3_progress_handler, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double,\n        sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_error_toobig,\n        sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_set_authorizer,\n        sqlite3_sleep, sqlite3_step, sqlite3_stmt, sqlite3_stmt_busy, sqlite3_stmt_readonly,\n        sqlite3_threadsafe, sqlite3_total_changes, sqlite3_trace_v2, sqlite3_user_data,\n        sqlite3_value, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double,\n        sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type,\n    };\n    use malachite_bigint::Sign;\n    use rustpython_common::{\n        atomic::{Ordering, PyAtomic, Radium},\n        hash::PyHash,\n        lock::{PyMappedMutexGuard, PyMutex, PyMutexGuard},\n        static_cell,\n    };\n    use rustpython_vm::{\n        __exports::paste,\n        AsObject, Py, PyAtomicRef, PyObject, PyObjectRef, PyPayload, PyRef, PyResult,\n        TryFromBorrowedObject, VirtualMachine, atomic_func,\n        builtins::{\n            PyBaseException, PyBaseExceptionRef, PyByteArray, PyBytes, PyDict, PyDictRef, PyFloat,\n            PyInt, PyIntRef, PySlice, PyStr, PyStrRef, PyTuple, PyTupleRef, PyType, PyTypeRef,\n            PyUtf8Str, PyUtf8StrRef,\n        },\n        convert::IntoObject,\n        function::{\n            ArgCallable, ArgIterable, FsPath, FuncArgs, OptionalArg, PyComparisonValue,\n            PySetterValue,\n        },\n        object::{Traverse, TraverseFn},\n        protocol::{\n            PyBuffer, PyIterReturn, PyMappingMethods, PyNumberMethods, PySequence,\n            PySequenceMethods,\n        },\n        sliceable::{SaturatedSliceIter, SliceableSequenceOp},\n        types::{\n            AsMapping, AsNumber, AsSequence, Callable, Comparable, Constructor, Hashable,\n            Initializer, IterNext, Iterable, PyComparisonOp, SelfIter, Unconstructible,\n        },\n        utils::ToCString,\n    };\n    use std::{\n        ffi::{CStr, c_int, c_longlong, c_uint, c_void},\n        fmt::Debug,\n        ops::Deref,\n        ptr::{NonNull, null, null_mut},\n        thread::ThreadId,\n    };\n\n    macro_rules! exceptions {\n        ($(($x:ident, $base:expr)),*) => {\n            paste::paste! {\n                static_cell! {\n                    $(\n                        static [<$x:snake:upper>]: PyTypeRef;\n                    )*\n                }\n                $(\n                    #[allow(dead_code)]\n                    fn [<new_ $x:snake>](vm: &VirtualMachine, msg: String) -> PyBaseExceptionRef {\n                        vm.new_exception_msg([<$x:snake _type>]().to_owned(), msg)\n                    }\n                    fn [<$x:snake _type>]() -> &'static Py<PyType> {\n                        [<$x:snake:upper>].get().expect(\"exception type not initialize\")\n                    }\n                )*\n                fn setup_module_exceptions(module: &PyObject, vm: &VirtualMachine) {\n                    $(\n                        #[allow(clippy::redundant_closure_call)]\n                        let exception = [<$x:snake:upper>].get_or_init(|| {\n                            let base = $base(vm);\n                            vm.ctx.new_exception_type(\"_sqlite3\", stringify!($x), Some(vec![base.to_owned()]))\n                        });\n                        module.set_attr(stringify!($x), exception.clone().into_object(), vm).unwrap();\n                    )*\n                }\n            }\n        };\n    }\n\n    exceptions!(\n        (Warning, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (Error, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (InterfaceError, |_| error_type()),\n        (DatabaseError, |_| error_type()),\n        (DataError, |_| database_error_type()),\n        (OperationalError, |_| database_error_type()),\n        (IntegrityError, |_| database_error_type()),\n        (InternalError, |_| database_error_type()),\n        (ProgrammingError, |_| database_error_type()),\n        (NotSupportedError, |_| database_error_type())\n    );\n\n    #[pyattr]\n    fn sqlite_version(vm: &VirtualMachine) -> String {\n        let s = unsafe { sqlite3_libversion() };\n        ptr_to_str(s, vm).unwrap().to_owned()\n    }\n\n    #[pyattr]\n    fn threadsafety(_: &VirtualMachine) -> c_int {\n        let mode = unsafe { sqlite3_threadsafe() };\n        match mode {\n            0 => 0,\n            1 => 3,\n            2 => 1,\n            _ => panic!(\"Unable to interpret SQLite threadsafety mode\"),\n        }\n    }\n\n    #[pyattr(name = \"_deprecated_version\")]\n    const PYSQLITE_VERSION: &str = \"2.6.0\";\n\n    #[pyattr]\n    const PARSE_DECLTYPES: c_int = 1;\n    #[pyattr]\n    const PARSE_COLNAMES: c_int = 2;\n\n    #[pyattr]\n    use libsqlite3_sys::{\n        SQLITE_ALTER_TABLE, SQLITE_ANALYZE, SQLITE_ATTACH, SQLITE_CREATE_INDEX,\n        SQLITE_CREATE_TABLE, SQLITE_CREATE_TEMP_INDEX, SQLITE_CREATE_TEMP_TABLE,\n        SQLITE_CREATE_TEMP_TRIGGER, SQLITE_CREATE_TEMP_VIEW, SQLITE_CREATE_TRIGGER,\n        SQLITE_CREATE_VIEW, SQLITE_CREATE_VTABLE, SQLITE_DELETE, SQLITE_DENY, SQLITE_DETACH,\n        SQLITE_DROP_INDEX, SQLITE_DROP_TABLE, SQLITE_DROP_TEMP_INDEX, SQLITE_DROP_TEMP_TABLE,\n        SQLITE_DROP_TEMP_TRIGGER, SQLITE_DROP_TEMP_VIEW, SQLITE_DROP_TRIGGER, SQLITE_DROP_VIEW,\n        SQLITE_DROP_VTABLE, SQLITE_FUNCTION, SQLITE_IGNORE, SQLITE_INSERT, SQLITE_LIMIT_ATTACHED,\n        SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH,\n        SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH,\n        SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER,\n        SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_PRAGMA, SQLITE_READ,\n        SQLITE_RECURSIVE, SQLITE_REINDEX, SQLITE_SAVEPOINT, SQLITE_SELECT, SQLITE_TRANSACTION,\n        SQLITE_UPDATE,\n    };\n\n    macro_rules! error_codes {\n        ($($x:ident),*) => {\n            $(\n                #[allow(unused_imports)]\n                use libsqlite3_sys::$x;\n            )*\n            static ERROR_CODES: &[(&str, c_int)] = &[\n            $(\n                (stringify!($x), libsqlite3_sys::$x),\n            )*\n            ];\n        };\n    }\n\n    error_codes!(\n        SQLITE_ABORT,\n        SQLITE_AUTH,\n        SQLITE_BUSY,\n        SQLITE_CANTOPEN,\n        SQLITE_CONSTRAINT,\n        SQLITE_CORRUPT,\n        SQLITE_DONE,\n        SQLITE_EMPTY,\n        SQLITE_ERROR,\n        SQLITE_FORMAT,\n        SQLITE_FULL,\n        SQLITE_INTERNAL,\n        SQLITE_INTERRUPT,\n        SQLITE_IOERR,\n        SQLITE_LOCKED,\n        SQLITE_MISMATCH,\n        SQLITE_MISUSE,\n        SQLITE_NOLFS,\n        SQLITE_NOMEM,\n        SQLITE_NOTADB,\n        SQLITE_NOTFOUND,\n        SQLITE_OK,\n        SQLITE_PERM,\n        SQLITE_PROTOCOL,\n        SQLITE_RANGE,\n        SQLITE_READONLY,\n        SQLITE_ROW,\n        SQLITE_SCHEMA,\n        SQLITE_TOOBIG,\n        SQLITE_NOTICE,\n        SQLITE_WARNING,\n        SQLITE_ABORT_ROLLBACK,\n        SQLITE_BUSY_RECOVERY,\n        SQLITE_CANTOPEN_FULLPATH,\n        SQLITE_CANTOPEN_ISDIR,\n        SQLITE_CANTOPEN_NOTEMPDIR,\n        SQLITE_CORRUPT_VTAB,\n        SQLITE_IOERR_ACCESS,\n        SQLITE_IOERR_BLOCKED,\n        SQLITE_IOERR_CHECKRESERVEDLOCK,\n        SQLITE_IOERR_CLOSE,\n        SQLITE_IOERR_DELETE,\n        SQLITE_IOERR_DELETE_NOENT,\n        SQLITE_IOERR_DIR_CLOSE,\n        SQLITE_IOERR_DIR_FSYNC,\n        SQLITE_IOERR_FSTAT,\n        SQLITE_IOERR_FSYNC,\n        SQLITE_IOERR_LOCK,\n        SQLITE_IOERR_NOMEM,\n        SQLITE_IOERR_RDLOCK,\n        SQLITE_IOERR_READ,\n        SQLITE_IOERR_SEEK,\n        SQLITE_IOERR_SHMLOCK,\n        SQLITE_IOERR_SHMMAP,\n        SQLITE_IOERR_SHMOPEN,\n        SQLITE_IOERR_SHMSIZE,\n        SQLITE_IOERR_SHORT_READ,\n        SQLITE_IOERR_TRUNCATE,\n        SQLITE_IOERR_UNLOCK,\n        SQLITE_IOERR_WRITE,\n        SQLITE_LOCKED_SHAREDCACHE,\n        SQLITE_READONLY_CANTLOCK,\n        SQLITE_READONLY_RECOVERY,\n        SQLITE_CONSTRAINT_CHECK,\n        SQLITE_CONSTRAINT_COMMITHOOK,\n        SQLITE_CONSTRAINT_FOREIGNKEY,\n        SQLITE_CONSTRAINT_FUNCTION,\n        SQLITE_CONSTRAINT_NOTNULL,\n        SQLITE_CONSTRAINT_PRIMARYKEY,\n        SQLITE_CONSTRAINT_TRIGGER,\n        SQLITE_CONSTRAINT_UNIQUE,\n        SQLITE_CONSTRAINT_VTAB,\n        SQLITE_READONLY_ROLLBACK,\n        SQLITE_IOERR_MMAP,\n        SQLITE_NOTICE_RECOVER_ROLLBACK,\n        SQLITE_NOTICE_RECOVER_WAL,\n        SQLITE_BUSY_SNAPSHOT,\n        SQLITE_IOERR_GETTEMPPATH,\n        SQLITE_WARNING_AUTOINDEX,\n        SQLITE_CANTOPEN_CONVPATH,\n        SQLITE_IOERR_CONVPATH,\n        SQLITE_CONSTRAINT_ROWID,\n        SQLITE_READONLY_DBMOVED,\n        SQLITE_AUTH_USER,\n        SQLITE_OK_LOAD_PERMANENTLY,\n        SQLITE_IOERR_VNODE,\n        SQLITE_IOERR_AUTH,\n        SQLITE_IOERR_BEGIN_ATOMIC,\n        SQLITE_IOERR_COMMIT_ATOMIC,\n        SQLITE_IOERR_ROLLBACK_ATOMIC,\n        SQLITE_ERROR_MISSING_COLLSEQ,\n        SQLITE_ERROR_RETRY,\n        SQLITE_READONLY_CANTINIT,\n        SQLITE_READONLY_DIRECTORY,\n        SQLITE_CORRUPT_SEQUENCE,\n        SQLITE_LOCKED_VTAB,\n        SQLITE_CANTOPEN_DIRTYWAL,\n        SQLITE_ERROR_SNAPSHOT,\n        SQLITE_CANTOPEN_SYMLINK,\n        SQLITE_CONSTRAINT_PINNED,\n        SQLITE_OK_SYMLINK,\n        SQLITE_BUSY_TIMEOUT,\n        SQLITE_CORRUPT_INDEX,\n        SQLITE_IOERR_DATA,\n        SQLITE_IOERR_CORRUPTFS\n    );\n\n    #[derive(FromArgs)]\n    struct ConnectArgs {\n        #[pyarg(any)]\n        database: FsPath,\n        #[pyarg(any, default = 5.0)]\n        timeout: f64,\n        #[pyarg(any, default = 0)]\n        detect_types: c_int,\n        #[pyarg(any, default = Some(vm.ctx.empty_str.to_owned()))]\n        isolation_level: Option<PyStrRef>,\n        #[pyarg(any, default = true)]\n        check_same_thread: bool,\n        #[pyarg(any, default = Connection::class(&vm.ctx).to_owned())]\n        factory: PyTypeRef,\n        // TODO: cache statements\n        #[allow(dead_code)]\n        #[pyarg(any, default = 0)]\n        cached_statements: c_int,\n        #[pyarg(any, default = false)]\n        uri: bool,\n    }\n\n    unsafe impl Traverse for ConnectArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.isolation_level.traverse(tracer_fn);\n            self.factory.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct BackupArgs {\n        #[pyarg(any)]\n        target: PyRef<Connection>,\n        #[pyarg(named, default = -1)]\n        pages: c_int,\n        #[pyarg(named, optional)]\n        progress: Option<ArgCallable>,\n        #[pyarg(named, optional)]\n        name: Option<PyStrRef>,\n        #[pyarg(named, default = 0.250)]\n        sleep: f64,\n    }\n\n    unsafe impl Traverse for BackupArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.progress.traverse(tracer_fn);\n            self.name.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct CreateFunctionArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(any)]\n        narg: c_int,\n        #[pyarg(any)]\n        func: PyObjectRef,\n        #[pyarg(named, default)]\n        deterministic: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct CreateAggregateArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(positional)]\n        narg: c_int,\n        #[pyarg(positional)]\n        aggregate_class: PyObjectRef,\n    }\n\n    #[derive(FromArgs)]\n    struct BlobOpenArgs {\n        #[pyarg(positional)]\n        table: PyStrRef,\n        #[pyarg(positional)]\n        column: PyStrRef,\n        #[pyarg(positional)]\n        row: i64,\n        #[pyarg(named, default)]\n        readonly: bool,\n        #[pyarg(named, default = vm.ctx.new_str(\"main\"))]\n        name: PyStrRef,\n    }\n\n    struct CallbackData {\n        obj: NonNull<PyObject>,\n        vm: *const VirtualMachine,\n    }\n\n    impl CallbackData {\n        fn new(obj: PyObjectRef, vm: &VirtualMachine) -> Option<Self> {\n            (!vm.is_none(&obj)).then_some(Self {\n                obj: obj.into_raw(),\n                vm,\n            })\n        }\n\n        fn retrieve(&self) -> (&PyObject, &VirtualMachine) {\n            unsafe { (self.obj.as_ref(), &*self.vm) }\n        }\n\n        unsafe extern \"C\" fn destructor(data: *mut c_void) {\n            drop(unsafe { Box::from_raw(data.cast::<Self>()) });\n        }\n\n        unsafe extern \"C\" fn func_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (func, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n\n                let val = func.call(args, vm)?;\n\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                context.result_exception(vm, exc, \"user-defined function raised exception\\0\")\n            }\n        }\n\n        unsafe extern \"C\" fn step_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (cls, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            if unsafe { (*instance).is_null() } {\n                match cls.call((), vm) {\n                    Ok(obj) => unsafe { *instance = obj.into_raw().as_ptr() },\n                    Err(exc) => {\n                        return context.result_exception(\n                            vm,\n                            exc,\n                            \"user-defined aggregate's '__init__' method raised error\\0\",\n                        );\n                    }\n                }\n            }\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"step\", args, vm);\n        }\n\n        unsafe extern \"C\" fn finalize_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let Some(instance) = (unsafe { (*instance).as_ref() }) else {\n                return;\n            };\n\n            Self::callback_result_from_method(context, instance, \"finalize\", vm);\n        }\n\n        unsafe extern \"C\" fn collation_callback(\n            data: *mut c_void,\n            a_len: c_int,\n            a_ptr: *const c_void,\n            b_len: c_int,\n            b_ptr: *const c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n\n            let f = || -> PyResult<c_int> {\n                let text1 = ptr_to_string(a_ptr.cast(), a_len, null_mut(), vm)?;\n                let text1 = vm.ctx.new_str(text1);\n                let text2 = ptr_to_string(b_ptr.cast(), b_len, null_mut(), vm)?;\n                let text2 = vm.ctx.new_str(text2);\n\n                let val = callable.call((text1, text2), vm)?;\n                let Some(val) = val.to_number().index(vm) else {\n                    return Ok(0);\n                };\n\n                let val = match val?.as_bigint().sign() {\n                    Sign::Plus => 1,\n                    Sign::Minus => -1,\n                    Sign::NoSign => 0,\n                };\n\n                Ok(val)\n            };\n\n            f().unwrap_or(0)\n        }\n\n        unsafe extern \"C\" fn value_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::callback_result_from_method(context, instance, \"value\", vm);\n        }\n\n        unsafe extern \"C\" fn inverse_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"inverse\", args, vm);\n        }\n\n        unsafe extern \"C\" fn authorizer_callback(\n            data: *mut c_void,\n            action: c_int,\n            arg1: *const libc::c_char,\n            arg2: *const libc::c_char,\n            db_name: *const libc::c_char,\n            access: *const libc::c_char,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let f = || -> PyResult<c_int> {\n                let arg1 = ptr_to_str(arg1, vm)?;\n                let arg2 = ptr_to_str(arg2, vm)?;\n                let db_name = ptr_to_str(db_name, vm)?;\n                let access = ptr_to_str(access, vm)?;\n\n                let val = callable.call((action, arg1, arg2, db_name, access), vm)?;\n                let Some(val) = val.downcast_ref::<PyInt>() else {\n                    return Ok(SQLITE_DENY);\n                };\n                val.try_to_primitive::<c_int>(vm)\n            };\n\n            f().unwrap_or(SQLITE_DENY)\n        }\n\n        unsafe extern \"C\" fn trace_callback(\n            _typ: c_uint,\n            data: *mut c_void,\n            stmt: *mut c_void,\n            sql: *mut c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let expanded = unsafe { sqlite3_expanded_sql(stmt.cast()) };\n            let f = || -> PyResult<()> {\n                let stmt = ptr_to_str(expanded, vm).or_else(|_| ptr_to_str(sql.cast(), vm))?;\n                callable.call((stmt,), vm)?;\n                Ok(())\n            };\n            let _ = f();\n            0\n        }\n\n        unsafe extern \"C\" fn progress_callback(data: *mut c_void) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            if let Ok(val) = callable.call((), vm)\n                && let Ok(val) = val.is_true(vm)\n            {\n                return val as c_int;\n            }\n            -1\n        }\n\n        fn callback_result_from_method(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let val = vm.call_method(instance, name, ())?;\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n\n        fn call_method_with_args(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            args: &[*mut sqlite3_value],\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n                vm.call_method(instance, name, args).map(drop)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n    }\n\n    impl Drop for CallbackData {\n        fn drop(&mut self) {\n            unsafe { PyObjectRef::from_raw(self.obj) };\n        }\n    }\n\n    #[pyfunction]\n    fn connect(args: ConnectArgs, vm: &VirtualMachine) -> PyResult {\n        Connection::py_new(args.factory.clone(), args, vm)\n    }\n\n    #[pyfunction]\n    fn complete_statement(statement: PyStrRef, vm: &VirtualMachine) -> PyResult<bool> {\n        let s = statement.to_cstring(vm)?;\n        let ret = unsafe { sqlite3_complete(s.as_ptr()) };\n        Ok(ret == 1)\n    }\n\n    #[pyfunction]\n    fn enable_callback_tracebacks(flag: bool) {\n        enable_traceback().store(flag, Ordering::Relaxed);\n    }\n\n    #[pyfunction]\n    fn register_adapter(typ: PyTypeRef, adapter: ArgCallable, vm: &VirtualMachine) -> PyResult<()> {\n        if typ.is(PyInt::class(&vm.ctx))\n            || typ.is(PyFloat::class(&vm.ctx))\n            || typ.is(PyStr::class(&vm.ctx))\n            || typ.is(PyByteArray::class(&vm.ctx))\n        {\n            let _ = BASE_TYPE_ADAPTED.set(());\n        }\n        let protocol = PrepareProtocol::class(&vm.ctx).to_owned();\n        let key = vm.ctx.new_tuple(vec![typ.into(), protocol.into()]);\n        adapters().set_item(key.as_object(), adapter.into(), vm)\n    }\n\n    #[pyfunction]\n    fn register_converter(\n        typename: PyStrRef,\n        converter: ArgCallable,\n        vm: &VirtualMachine,\n    ) -> PyResult<()> {\n        let name = typename.as_str().to_uppercase();\n        converters().set_item(&name, converter.into(), vm)\n    }\n\n    fn _adapt<F>(obj: &PyObject, proto: PyTypeRef, alt: F, vm: &VirtualMachine) -> PyResult\n    where\n        F: FnOnce(&PyObject) -> PyResult,\n    {\n        let proto = proto.into_object();\n        let key = vm\n            .ctx\n            .new_tuple(vec![obj.class().to_owned().into(), proto.clone()]);\n\n        if let Some(adapter) = adapters().get_item_opt(key.as_object(), vm)? {\n            return adapter.call((obj,), vm);\n        }\n        if let Ok(adapter) = proto.get_attr(\"__adapt__\", vm) {\n            match adapter.call((obj,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n        if let Ok(adapter) = obj.get_attr(\"__conform__\", vm) {\n            match adapter.call((proto,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n\n        alt(obj)\n    }\n\n    #[pyfunction]\n    fn adapt(\n        obj: PyObjectRef,\n        proto: OptionalArg<Option<PyTypeRef>>,\n        alt: OptionalArg<PyObjectRef>,\n        vm: &VirtualMachine,\n    ) -> PyResult {\n        if matches!(proto, OptionalArg::Present(None)) {\n            return if let OptionalArg::Present(alt) = alt {\n                Ok(alt)\n            } else {\n                Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n            };\n        }\n\n        let proto = proto\n            .flatten()\n            .unwrap_or_else(|| PrepareProtocol::class(&vm.ctx).to_owned());\n\n        _adapt(\n            &obj,\n            proto,\n            |_| {\n                if let OptionalArg::Present(alt) = alt {\n                    Ok(alt)\n                } else {\n                    Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n                }\n            },\n            vm,\n        )\n    }\n\n    fn need_adapt(obj: &PyObject, vm: &VirtualMachine) -> bool {\n        if BASE_TYPE_ADAPTED.get().is_some() {\n            true\n        } else {\n            let cls = obj.class();\n            !(cls.is(vm.ctx.types.int_type)\n                || cls.is(vm.ctx.types.float_type)\n                || cls.is(vm.ctx.types.str_type)\n                || cls.is(vm.ctx.types.bytearray_type))\n        }\n    }\n\n    static_cell! {\n        static CONVERTERS: PyDictRef;\n        static ADAPTERS: PyDictRef;\n        static BASE_TYPE_ADAPTED: ();\n        static USER_FUNCTION_EXCEPTION: PyAtomicRef<Option<PyBaseException>>;\n        static ENABLE_TRACEBACK: PyAtomic<bool>;\n    }\n\n    fn converters() -> &'static Py<PyDict> {\n        CONVERTERS.get().expect(\"converters not initialize\")\n    }\n\n    fn adapters() -> &'static Py<PyDict> {\n        ADAPTERS.get().expect(\"adapters not initialize\")\n    }\n\n    fn user_function_exception() -> &'static PyAtomicRef<Option<PyBaseException>> {\n        USER_FUNCTION_EXCEPTION\n            .get()\n            .expect(\"user function exception not initialize\")\n    }\n\n    fn enable_traceback() -> &'static PyAtomic<bool> {\n        ENABLE_TRACEBACK\n            .get()\n            .expect(\"enable traceback not initialize\")\n    }\n\n    pub(super) fn setup_module(module: &PyObject, vm: &VirtualMachine) {\n        for (name, code) in ERROR_CODES {\n            let name = vm.ctx.intern_str(*name);\n            let code = vm.new_pyobj(*code);\n            module.set_attr(name, code, vm).unwrap();\n        }\n\n        setup_module_exceptions(module, vm);\n\n        let _ = CONVERTERS.set(vm.ctx.new_dict());\n        let _ = ADAPTERS.set(vm.ctx.new_dict());\n        let _ = USER_FUNCTION_EXCEPTION.set(PyAtomicRef::from(None));\n        let _ = ENABLE_TRACEBACK.set(Radium::new(false));\n\n        module\n            .set_attr(\"converters\", converters().to_owned(), vm)\n            .unwrap();\n        module\n            .set_attr(\"adapters\", adapters().to_owned(), vm)\n            .unwrap();\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(PyPayload)]\n    struct Connection {\n        db: PyMutex<Option<Sqlite>>,\n        detect_types: c_int,\n        isolation_level: PyAtomicRef<Option<PyStr>>,\n        check_same_thread: bool,\n        thread_ident: ThreadId,\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        text_factory: PyAtomicRef<PyObject>,\n    }\n\n    impl Debug for Connection {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"Sqlite3 Connection\")\n        }\n    }\n\n    impl Constructor for Connection {\n        type Args = ConnectArgs;\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n\n            // For non-subclassed Connection, initialize in __new__\n            // For subclassed Connection, leave db as None and require __init__ to be called\n            let is_base_class = cls.is(Connection::class(&vm.ctx).as_object());\n\n            let db = if is_base_class {\n                // Initialize immediately for base class\n                Some(Connection::initialize_db(&args, vm)?)\n            } else {\n                // For subclasses, require __init__ to be called\n                None\n            };\n\n            let conn = Self {\n                db: PyMutex::new(db),\n                detect_types: args.detect_types,\n                isolation_level: PyAtomicRef::from(args.isolation_level),\n                check_same_thread: args.check_same_thread,\n                thread_ident: std::thread::current().id(),\n                row_factory: PyAtomicRef::from(None),\n                text_factory: PyAtomicRef::from(text_factory),\n            };\n\n            Ok(conn.into_ref_with_type(vm, cls)?.into())\n        }\n    }\n\n    impl Callable for Connection {\n        type Args = FuncArgs;\n\n        fn call(zelf: &Py<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let _ = zelf.db_lock(vm)?;\n\n            let (sql,): (PyUtf8StrRef,) = args.bind(vm)?;\n\n            if let Some(stmt) = Statement::new(zelf, sql, vm)? {\n                Ok(stmt.into_ref(&vm.ctx).into())\n            } else {\n                Ok(vm.ctx.none())\n            }\n        }\n    }\n\n    impl Initializer for Connection {\n        type Args = ConnectArgs;\n\n        fn init(zelf: PyRef<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = zelf.db.lock();\n\n            {\n                // Always drop the current database handle so __init__ can fully reconfigure it.\n                let mut guard = zelf.db.lock();\n                guard.take();\n            }\n\n            // Reset factories to their defaults, matching CPython's behavior.\n            let default_text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n            let _ = unsafe { zelf.row_factory.swap(None) };\n            let _ = unsafe { zelf.text_factory.swap(default_text_factory) };\n\n            // Attempt to open the new database before mutating other state so failures leave\n            // the connection uninitialized (and subsequent operations raise ProgrammingError).\n            let db = Self::initialize_db(&args, vm)?;\n\n            let ConnectArgs {\n                detect_types,\n                isolation_level,\n                check_same_thread,\n                ..\n            } = args;\n\n            zelf.detect_types = detect_types;\n            zelf.check_same_thread = check_same_thread;\n            zelf.thread_ident = std::thread::current().id();\n            let _ = unsafe { zelf.isolation_level.swap(isolation_level) };\n\n            let mut guard = zelf.db.lock();\n            *guard = Some(db);\n            Ok(())\n        }\n    }\n\n    #[pyclass(with(Constructor, Callable, Initializer), flags(BASETYPE))]\n    impl Connection {\n        fn initialize_db(args: &ConnectArgs, vm: &VirtualMachine) -> PyResult<Sqlite> {\n            let path = args.database.to_cstring(vm)?;\n            let db = Sqlite::from(SqliteRaw::open(path.as_ptr(), args.uri, vm)?);\n            let timeout = (args.timeout * 1000.0) as c_int;\n            db.busy_timeout(timeout);\n            if let Some(isolation_level) = &args.isolation_level {\n                begin_statement_ptr_from_isolation_level(isolation_level, vm)?;\n            }\n            Ok(db)\n        }\n\n        fn db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            self.check_thread(vm)?;\n            self._db_lock(vm)\n        }\n\n        fn _db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            let guard = self.db.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Connection.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn cursor(\n            zelf: PyRef<Self>,\n            factory: OptionalArg<ArgCallable>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            zelf.db_lock(vm).map(drop)?;\n\n            let cursor = if let OptionalArg::Present(factory) = factory {\n                let cursor = factory.invoke((zelf.clone(),), vm)?;\n                let cursor = cursor.downcast::<Cursor>().map_err(|x| {\n                    vm.new_type_error(format!(\"factory must return a cursor, not {}\", x.class()))\n                })?;\n                let _ = unsafe { cursor.row_factory.swap(zelf.row_factory.to_owned()) };\n                cursor\n            } else {\n                let row_factory = zelf.row_factory.to_owned();\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx)\n            };\n            Ok(cursor)\n        }\n\n        #[pymethod]\n        fn blobopen(\n            zelf: PyRef<Self>,\n            args: BlobOpenArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Blob>> {\n            let table = args.table.to_cstring(vm)?;\n            let column = args.column.to_cstring(vm)?;\n            let name = args.name.to_cstring(vm)?;\n\n            let db = zelf.db_lock(vm)?;\n\n            let mut blob = null_mut();\n            let ret = unsafe {\n                sqlite3_blob_open(\n                    db.db,\n                    name.as_ptr(),\n                    table.as_ptr(),\n                    column.as_ptr(),\n                    args.row,\n                    (!args.readonly) as c_int,\n                    &mut blob,\n                )\n            };\n            db.check(ret, vm)?;\n            drop(db);\n\n            let blob = SqliteBlob { blob };\n            let blob = Blob {\n                connection: zelf,\n                inner: PyMutex::new(Some(BlobInner { blob, offset: 0 })),\n            };\n            Ok(blob.into_ref(&vm.ctx))\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.check_thread(vm)?;\n            self.db.lock().take();\n            Ok(())\n        }\n\n        #[pymethod]\n        fn commit(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.db_lock(vm)?.implicit_commit(vm)\n        }\n\n        #[pymethod]\n        fn rollback(&self, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            if !db.is_autocommit() {\n                db._exec(b\"ROLLBACK\\0\", vm)\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::execute(cursor, sql, parameters, vm)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::executemany(cursor, sql, seq_of_params, vm)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            Cursor::executescript(\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx),\n                script,\n                vm,\n            )\n        }\n\n        // TODO: Make it build without clippy::manual_c_str_literals\n        #[pymethod]\n        #[allow(clippy::manual_c_str_literals)]\n        fn backup(zelf: &Py<Self>, args: BackupArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let BackupArgs {\n                target,\n                pages,\n                progress,\n                name,\n                sleep,\n            } = args;\n            if zelf.is(&target) {\n                return Err(vm.new_value_error(\"target cannot be the same connection instance\"));\n            }\n\n            let pages = if pages == 0 { -1 } else { pages };\n\n            let name_cstring;\n            let name_ptr = if let Some(name) = &name {\n                name_cstring = name.to_cstring(vm)?;\n                name_cstring.as_ptr()\n            } else {\n                b\"main\\0\".as_ptr().cast()\n            };\n\n            let sleep_ms = (sleep * 1000.0) as c_int;\n\n            let db = zelf.db_lock(vm)?;\n            let target_db = target.db_lock(vm)?;\n\n            let handle = unsafe {\n                sqlite3_backup_init(target_db.db, b\"main\\0\".as_ptr().cast(), db.db, name_ptr)\n            };\n\n            if handle.is_null() {\n                return Err(target_db.error_extended(vm));\n            }\n\n            drop(db);\n            drop(target_db);\n\n            loop {\n                let ret = unsafe { sqlite3_backup_step(handle, pages) };\n\n                if let Some(progress) = &progress {\n                    let remaining = unsafe { sqlite3_backup_remaining(handle) };\n                    let pagecount = unsafe { sqlite3_backup_pagecount(handle) };\n                    if let Err(err) = progress.invoke((ret, remaining, pagecount), vm) {\n                        unsafe { sqlite3_backup_finish(handle) };\n                        return Err(err);\n                    }\n                }\n\n                if ret == SQLITE_BUSY || ret == SQLITE_LOCKED {\n                    unsafe { sqlite3_sleep(sleep_ms) };\n                } else if ret != SQLITE_OK {\n                    break;\n                }\n            }\n\n            let ret = unsafe { sqlite3_backup_finish(handle) };\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(target.db_lock(vm)?.error_extended(vm))\n            }\n        }\n\n        #[pymethod]\n        fn create_function(&self, args: CreateFunctionArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let flags = if args.deterministic {\n                SQLITE_UTF8 | SQLITE_DETERMINISTIC\n            } else {\n                SQLITE_UTF8\n            };\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.func, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    flags,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                flags,\n                Box::into_raw(Box::new(data)).cast(),\n                Some(CallbackData::func_callback),\n                None,\n                None,\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_aggregate(&self, args: CreateAggregateArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.aggregate_class, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    SQLITE_UTF8,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                SQLITE_UTF8,\n                Box::into_raw(Box::new(data)).cast(),\n                None,\n                Some(CallbackData::step_callback),\n                Some(CallbackData::finalize_callback),\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_collation(\n            &self,\n            name: PyUtf8StrRef,\n            callable: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable.clone(), vm) else {\n                unsafe {\n                    sqlite3_create_collation_v2(\n                        db.db,\n                        name.as_ptr(),\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                    );\n                }\n                return Ok(());\n            };\n            let data = Box::into_raw(Box::new(data));\n\n            if !callable.is_callable() {\n                return Err(vm.new_type_error(\"parameter must be callable\"));\n            }\n\n            let ret = unsafe {\n                sqlite3_create_collation_v2(\n                    db.db,\n                    name.as_ptr(),\n                    SQLITE_UTF8,\n                    data.cast(),\n                    Some(CallbackData::collation_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n\n            db.check(ret, vm).inspect_err(|_| {\n                // create_collation do not call destructor if error occur\n                let _ = unsafe { Box::from_raw(data) };\n            })\n        }\n\n        #[pymethod]\n        fn create_window_function(\n            &self,\n            name: PyStrRef,\n            narg: c_int,\n            aggregate_class: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(aggregate_class, vm) else {\n                unsafe {\n                    sqlite3_create_window_function(\n                        db.db,\n                        name.as_ptr(),\n                        narg,\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                        None,\n                        None,\n                        None,\n                    )\n                };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_create_window_function(\n                    db.db,\n                    name.as_ptr(),\n                    narg,\n                    SQLITE_UTF8,\n                    Box::into_raw(Box::new(data)).cast(),\n                    Some(CallbackData::step_callback),\n                    Some(CallbackData::finalize_callback),\n                    Some(CallbackData::value_callback),\n                    Some(CallbackData::inverse_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n            db.check(ret, vm)\n                .map_err(|_| new_programming_error(vm, \"Error creating window function\".to_owned()))\n        }\n\n        #[pymethod]\n        fn set_authorizer(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_set_authorizer(db.db, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_set_authorizer(\n                    db.db,\n                    Some(CallbackData::authorizer_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n            db.check(ret, vm).map_err(|_| {\n                new_operational_error(vm, \"Error setting authorizer callback\".to_owned())\n            })\n        }\n\n        #[pymethod]\n        fn set_trace_callback(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_trace_v2(db.db, SQLITE_TRACE_STMT as u32, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_trace_v2(\n                    db.db,\n                    SQLITE_TRACE_STMT as u32,\n                    Some(CallbackData::trace_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            db.check(ret, vm)\n        }\n\n        #[pymethod]\n        fn set_progress_handler(\n            &self,\n            callable: PyObjectRef,\n            n: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_progress_handler(db.db, n, None, null_mut()) };\n                return Ok(());\n            };\n\n            unsafe {\n                sqlite3_progress_handler(\n                    db.db,\n                    n,\n                    Some(CallbackData::progress_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            Ok(())\n        }\n\n        #[pymethod]\n        fn iterdump(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            let module = vm.import(\"sqlite3.dump\", 0)?;\n            let func = module.get_attr(\"_iterdump\", vm)?;\n            func.call((zelf,), vm)\n        }\n\n        #[pymethod]\n        fn interrupt(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // DO NOT check thread safety\n            self._db_lock(vm).map(|x| x.interrupt())\n        }\n\n        #[pymethod]\n        fn getlimit(&self, category: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, -1, vm)\n        }\n\n        #[pymethod]\n        fn setlimit(&self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, limit, vm)\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>) -> PyRef<Self> {\n            zelf\n        }\n\n        #[pymethod]\n        fn __exit__(\n            &self,\n            cls: PyObjectRef,\n            exc: PyObjectRef,\n            tb: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            if vm.is_none(&cls) && vm.is_none(&exc) && vm.is_none(&tb) {\n                self.commit(vm)\n            } else {\n                self.rollback(vm)\n            }\n        }\n\n        #[pygetset]\n        fn isolation_level(&self) -> Option<PyStrRef> {\n            self.isolation_level.deref().map(|x| x.to_owned())\n        }\n        #[pygetset(setter)]\n        fn set_isolation_level(\n            &self,\n            value: PySetterValue<Option<PyStrRef>>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            match value {\n                PySetterValue::Assign(value) => {\n                    if let Some(val_str) = &value {\n                        begin_statement_ptr_from_isolation_level(val_str, vm)?;\n                    }\n\n                    // If setting isolation_level to None (auto-commit mode), commit any pending transaction\n                    if value.is_none() {\n                        let db = self.db_lock(vm)?;\n                        if !db.is_autocommit() {\n                            // Keep the lock and call implicit_commit directly to avoid race conditions\n                            db.implicit_commit(vm)?;\n                        }\n                    }\n                    let _ = unsafe { self.isolation_level.swap(value) };\n                    Ok(())\n                }\n                PySetterValue::Delete => Err(vm.new_attribute_error(\n                    \"'isolation_level' attribute cannot be deleted\".to_owned(),\n                )),\n            }\n        }\n\n        #[pygetset]\n        fn text_factory(&self) -> PyObjectRef {\n            self.text_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_text_factory(&self, val: PyObjectRef) {\n            let _ = unsafe { self.text_factory.swap(val) };\n        }\n\n        #[pygetset]\n        fn row_factory(&self) -> Option<PyObjectRef> {\n            self.row_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_row_factory(&self, val: Option<PyObjectRef>) {\n            let _ = unsafe { self.row_factory.swap(val) };\n        }\n\n        fn check_thread(&self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.check_same_thread && (std::thread::current().id() != self.thread_ident) {\n                Err(new_programming_error(\n                    vm,\n                    \"SQLite objects created in a thread can only be used in that same thread.\"\n                        .to_owned(),\n                ))\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pygetset]\n        fn in_transaction(&self, vm: &VirtualMachine) -> PyResult<bool> {\n            self._db_lock(vm).map(|x| !x.is_autocommit())\n        }\n\n        #[pygetset]\n        fn total_changes(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self._db_lock(vm).map(|x| x.total_changes())\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Cursor {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        arraysize: PyAtomic<c_int>,\n        #[pytraverse(skip)]\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        inner: PyMutex<Option<CursorInner>>,\n    }\n\n    #[derive(Debug, Traverse)]\n    struct CursorInner {\n        description: Option<PyTupleRef>,\n        row_cast_map: Vec<Option<PyObjectRef>>,\n        #[pytraverse(skip)]\n        lastrowid: i64,\n        #[pytraverse(skip)]\n        rowcount: i64,\n        statement: Option<PyRef<Statement>>,\n        #[pytraverse(skip)]\n        closed: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct FetchManyArgs {\n        #[pyarg(any, name = \"size\", optional)]\n        size: Option<c_int>,\n    }\n\n    #[pyclass(with(Constructor, IterNext, Iterable), flags(BASETYPE))]\n    impl Cursor {\n        fn new(\n            connection: PyRef<Connection>,\n            row_factory: Option<PyObjectRef>,\n            _vm: &VirtualMachine,\n        ) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(row_factory),\n                inner: PyMutex::from(Some(CursorInner {\n                    description: None,\n                    row_cast_map: vec![],\n                    lastrowid: -1,\n                    rowcount: -1,\n                    statement: None,\n                    closed: false,\n                })),\n            }\n        }\n\n        fn new_uninitialized(connection: PyRef<Connection>, _vm: &VirtualMachine) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(None),\n                inner: PyMutex::from(None),\n            }\n        }\n\n        #[pymethod]\n        fn __init__(&self, _connection: PyRef<Connection>, _vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = self.inner.lock();\n            if guard.is_some() {\n                // Already initialized (e.g., from a call to super().__init__)\n                return Ok(());\n            }\n            *guard = Some(CursorInner {\n                description: None,\n                row_cast_map: vec![],\n                lastrowid: -1,\n                rowcount: -1,\n                statement: None,\n                closed: false,\n            });\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, CursorInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                let inner_guard =\n                    PyMutexGuard::map(guard, |x| unsafe { x.as_mut().unwrap_unchecked() });\n                if inner_guard.closed {\n                    return Err(new_programming_error(\n                        vm,\n                        \"Cannot operate on a closed cursor.\".to_owned(),\n                    ));\n                }\n                Ok(inner_guard)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let st = stmt.lock();\n            let params_needed = st.bind_parameter_count();\n\n            if let OptionalArg::Present(parameters) = parameters {\n                st.bind_parameters(&parameters, vm)?;\n            } else if params_needed > 0 {\n                let msg = format!(\n                    \"Incorrect number of bindings supplied. The current statement uses {}, and 0 were supplied.\",\n                    params_needed\n                );\n                return Err(new_programming_error(vm, msg));\n            }\n\n            let ret = st.step();\n\n            if ret != SQLITE_DONE && ret != SQLITE_ROW {\n                if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                    return Err(exc);\n                }\n                return Err(db.error_extended(vm));\n            }\n\n            inner.row_cast_map = zelf.build_row_cast_map(&st, vm)?;\n\n            inner.description = st.columns_description(zelf.connection.detect_types, vm)?;\n\n            if ret == SQLITE_ROW {\n                drop(st);\n                inner.statement = Some(stmt);\n            } else {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount += db.changes() as i64;\n                }\n            }\n\n            inner.lastrowid = db.lastrowid();\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            let st = stmt.lock();\n\n            if st.readonly() {\n                return Err(new_programming_error(\n                    vm,\n                    \"executemany() can only execute DML statements.\".to_owned(),\n                ));\n            }\n\n            inner.description = st.columns_description(zelf.connection.detect_types, vm)?;\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let iter = seq_of_params.iter(vm)?;\n            for params in iter {\n                let params = params?;\n                st.bind_parameters(&params, vm)?;\n\n                if !st.step_row_else_done(vm)? {\n                    if stmt.is_dml {\n                        inner.rowcount += db.changes() as i64;\n                    }\n                    st.reset();\n                }\n\n                // if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                //     return Err(exc);\n                // }\n            }\n\n            if st.busy() {\n                drop(st);\n                inner.statement = Some(stmt);\n            }\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let db = zelf.connection.db_lock(vm)?;\n\n            db.sql_limit(script.byte_len(), vm)?;\n\n            db.implicit_commit(vm)?;\n\n            let script = script.to_cstring(vm)?;\n            let mut ptr = script.as_ptr();\n\n            while let Some(st) = db.prepare(ptr, &mut ptr, vm)? {\n                while st.step_row_else_done(vm)? {}\n            }\n\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn fetchone(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult {\n            Self::next(zelf, vm).map(|x| match x {\n                PyIterReturn::Return(row) => row,\n                PyIterReturn::StopIteration(_) => vm.ctx.none(),\n            })\n        }\n\n        #[pymethod]\n        fn fetchmany(\n            zelf: &Py<Self>,\n            args: FetchManyArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<PyObjectRef>> {\n            let max_rows = args\n                .size\n                .unwrap_or_else(|| zelf.arraysize.load(Ordering::Relaxed));\n\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Cursor::next(zelf, vm)? {\n                list.push(row);\n                if max_rows > 0 && list.len() as c_int >= max_rows {\n                    break;\n                }\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn fetchall(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Self::next(zelf, vm)? {\n                list.push(row);\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // Check if __init__ was called\n            let mut guard = self.inner.lock();\n            if guard.is_none() {\n                return Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ));\n            }\n\n            if let Some(inner) = guard.as_mut() {\n                if let Some(stmt) = &inner.statement {\n                    stmt.lock().reset();\n                }\n                inner.closed = true;\n            }\n            Ok(())\n        }\n\n        #[pymethod]\n        fn setinputsizes(&self, _sizes: PyObjectRef) {}\n        #[pymethod]\n        fn setoutputsize(&self, _size: PyObjectRef, _column: OptionalArg<PyObjectRef>) {}\n\n        #[pygetset]\n        fn connection(&self) -> PyRef<Connection> {\n            self.connection.clone()\n        }\n\n        #[pygetset]\n        fn lastrowid(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.lastrowid)\n        }\n\n        #[pygetset]\n        fn rowcount(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.rowcount)\n        }\n\n        #[pygetset]\n        fn description(&self, vm: &VirtualMachine) -> PyResult<Option<PyTupleRef>> {\n            self.inner(vm).map(|x| x.description.clone())\n        }\n\n        #[pygetset]\n        fn arraysize(&self) -> c_int {\n            self.arraysize.load(Ordering::Relaxed)\n        }\n        #[pygetset(setter)]\n        fn set_arraysize(&self, val: c_int) {\n            self.arraysize.store(val, Ordering::Relaxed);\n        }\n\n        fn build_row_cast_map(\n            &self,\n            st: &SqliteStatementRaw,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<Option<PyObjectRef>>> {\n            if self.connection.detect_types == 0 {\n                return Ok(vec![]);\n            }\n\n            let mut cast_map = vec![];\n            let num_cols = st.column_count();\n\n            for i in 0..num_cols {\n                if self.connection.detect_types & PARSE_COLNAMES != 0 {\n                    let col_name = st.column_name(i);\n                    let col_name = ptr_to_str(col_name, vm)?;\n                    let col_name = col_name\n                        .chars()\n                        .skip_while(|&x| x != '[')\n                        .skip(1)\n                        .take_while(|&x| x != ']')\n                        .flat_map(|x| x.to_uppercase())\n                        .collect::<String>();\n                    if let Some(converter) = converters().get_item_opt(&col_name, vm)? {\n                        cast_map.push(Some(converter.clone()));\n                        continue;\n                    }\n                }\n                if self.connection.detect_types & PARSE_DECLTYPES != 0 {\n                    let decltype = st.column_decltype(i);\n                    let decltype = ptr_to_str(decltype, vm)?;\n                    if let Some(decltype) = decltype.split_terminator(&[' ', '(']).next() {\n                        let decltype = decltype.to_uppercase();\n                        if let Some(converter) = converters().get_item_opt(&decltype, vm)? {\n                            cast_map.push(Some(converter.clone()));\n                            continue;\n                        }\n                    }\n                }\n                cast_map.push(None);\n            }\n\n            Ok(cast_map)\n        }\n    }\n\n    impl Constructor for Cursor {\n        type Args = (PyRef<Connection>,);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            Self::new_uninitialized(args.0, vm)\n                .into_ref_with_type(vm, cls)\n                .map(Into::into)\n        }\n    }\n\n    impl SelfIter for Cursor {}\n    impl IterNext for Cursor {\n        fn next(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyIterReturn> {\n            let mut inner = zelf.inner(vm)?;\n            let Some(stmt) = &inner.statement else {\n                return Ok(PyIterReturn::StopIteration(None));\n            };\n            let st = stmt.lock();\n            let db = zelf.connection.db_lock(vm)?;\n            // fetch_one_row\n\n            let num_cols = st.data_count();\n\n            let mut row = Vec::with_capacity(num_cols as usize);\n\n            for i in 0..num_cols {\n                let val = if let Some(converter) =\n                    inner.row_cast_map.get(i as usize).cloned().flatten()\n                {\n                    let blob = st.column_blob(i);\n                    if blob.is_null() {\n                        vm.ctx.none()\n                    } else {\n                        let nbytes = st.column_bytes(i);\n                        let blob = unsafe {\n                            std::slice::from_raw_parts(blob.cast::<u8>(), nbytes as usize)\n                        };\n                        let blob = vm.ctx.new_bytes(blob.to_vec());\n                        converter.call((blob,), vm)?\n                    }\n                } else {\n                    let col_type = st.column_type(i);\n                    match col_type {\n                        SQLITE_NULL => vm.ctx.none(),\n                        SQLITE_INTEGER => vm.ctx.new_int(st.column_int(i)).into(),\n                        SQLITE_FLOAT => vm.ctx.new_float(st.column_double(i)).into(),\n                        SQLITE_TEXT => {\n                            let text =\n                                ptr_to_vec(st.column_text(i), st.column_bytes(i), db.db, vm)?;\n\n                            let text_factory = zelf.connection.text_factory.to_owned();\n\n                            if text_factory.is(PyStr::class(&vm.ctx)) {\n                                let text = String::from_utf8(text).map_err(|err| {\n                                    let col_name = st.column_name(i);\n                                    let col_name_str = ptr_to_str(col_name, vm).unwrap_or(\"?\");\n                                    let valid_up_to = err.utf8_error().valid_up_to();\n                                    let text_prefix = String::from_utf8_lossy(&err.as_bytes()[..valid_up_to]);\n                                    let msg = format!(\n                                        \"Could not decode to UTF-8 column '{col_name_str}' with text '{text_prefix}'\"\n                                    );\n                                    new_operational_error(vm, msg)\n                                })?;\n                                vm.ctx.new_str(text).into()\n                            } else if text_factory.is(PyBytes::class(&vm.ctx)) {\n                                vm.ctx.new_bytes(text).into()\n                            } else if text_factory.is(PyByteArray::class(&vm.ctx)) {\n                                PyByteArray::from(text).into_ref(&vm.ctx).into()\n                            } else {\n                                let bytes = vm.ctx.new_bytes(text);\n                                text_factory.call((bytes,), vm)?\n                            }\n                        }\n                        SQLITE_BLOB => {\n                            let blob = ptr_to_vec(\n                                st.column_blob(i).cast(),\n                                st.column_bytes(i),\n                                db.db,\n                                vm,\n                            )?;\n\n                            vm.ctx.new_bytes(blob).into()\n                        }\n                        _ => {\n                            return Err(vm.new_not_implemented_error(format!(\n                                \"unknown column type: {col_type}\"\n                            )));\n                        }\n                    }\n                };\n\n                row.push(val);\n            }\n\n            if !st.step_row_else_done(vm)? {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount = db.changes() as i64;\n                }\n                inner.statement = None;\n            } else {\n                drop(st);\n            }\n\n            drop(db);\n            drop(inner);\n\n            let row = vm.ctx.new_tuple(row);\n\n            if let Some(row_factory) = zelf.row_factory.to_owned() {\n                row_factory\n                    .call((zelf.to_owned(), row), vm)\n                    .map(PyIterReturn::Return)\n            } else {\n                Ok(PyIterReturn::Return(row.into()))\n            }\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Row {\n        data: PyTupleRef,\n        description: PyTupleRef,\n    }\n\n    #[pyclass(\n        with(Constructor, Hashable, Comparable, Iterable, AsMapping, AsSequence),\n        flags(BASETYPE)\n    )]\n    impl Row {\n        #[pymethod]\n        fn keys(&self, _vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            Ok(self\n                .description\n                .iter()\n                .map(|x| x.downcast_ref::<PyTuple>().unwrap().as_slice()[0].clone())\n                .collect())\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            if let Some(i) = needle.downcast_ref::<PyInt>() {\n                let i = i.try_to_primitive::<isize>(vm)?;\n                self.data.getitem_by_index(vm, i)\n            } else if let Some(name) = needle.downcast_ref::<PyStr>() {\n                for (obj, i) in self.description.iter().zip(0..) {\n                    let obj = &obj.downcast_ref::<PyTuple>().unwrap().as_slice()[0];\n                    let Some(obj) = obj.downcast_ref::<PyStr>() else {\n                        break;\n                    };\n                    let a_iter = name.as_str().chars().flat_map(|x| x.to_uppercase());\n                    let b_iter = obj.as_str().chars().flat_map(|x| x.to_uppercase());\n\n                    if a_iter.eq(b_iter) {\n                        return self.data.getitem_by_index(vm, i);\n                    }\n                }\n                Err(vm.new_index_error(\"No item with that key\"))\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let list = self.data.getitem_by_slice(vm, slice.to_saturated(vm)?)?;\n                Ok(vm.ctx.new_tuple(list).into())\n            } else {\n                Err(vm.new_index_error(\"Index must be int or string\"))\n            }\n        }\n    }\n\n    impl Constructor for Row {\n        type Args = (PyRef<Cursor>, PyTupleRef);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let description = args\n                .0\n                .inner(vm)?\n                .description\n                .clone()\n                .ok_or_else(|| vm.new_value_error(\"no description in Cursor\"))?;\n\n            Self {\n                data: args.1,\n                description,\n            }\n            .into_ref_with_type(vm, cls)\n            .map(Into::into)\n        }\n    }\n\n    impl Hashable for Row {\n        fn hash(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyHash> {\n            Ok(zelf.description.as_object().hash(vm)? | zelf.data.as_object().hash(vm)?)\n        }\n    }\n\n    impl Comparable for Row {\n        fn cmp(\n            zelf: &Py<Self>,\n            other: &PyObject,\n            op: PyComparisonOp,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyComparisonValue> {\n            op.eq_only(|| {\n                if let Some(other) = other.downcast_ref::<Self>() {\n                    let eq = vm\n                        .bool_eq(zelf.description.as_object(), other.description.as_object())?\n                        && vm.bool_eq(zelf.data.as_object(), other.data.as_object())?;\n                    Ok(eq.into())\n                } else {\n                    Ok(PyComparisonValue::NotImplemented)\n                }\n            })\n        }\n    }\n\n    impl Iterable for Row {\n        fn iter(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            Iterable::iter(zelf.data.clone(), vm)\n        }\n    }\n\n    impl AsMapping for Row {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: std::sync::LazyLock<PyMappingMethods> =\n                std::sync::LazyLock::new(|| PyMappingMethods {\n                    length: atomic_func!(|mapping, _vm| Ok(Row::mapping_downcast(mapping)\n                        .data\n                        .len())),\n                    subscript: atomic_func!(|mapping, needle, vm| {\n                        Row::mapping_downcast(mapping).subscript(needle, vm)\n                    }),\n                    ..PyMappingMethods::NOT_IMPLEMENTED\n                });\n            &AS_MAPPING\n        }\n    }\n\n    impl AsSequence for Row {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: std::sync::LazyLock<PySequenceMethods> =\n                std::sync::LazyLock::new(|| PySequenceMethods {\n                    length: atomic_func!(|seq, _vm| Ok(Row::sequence_downcast(seq).data.len())),\n                    item: atomic_func!(|seq, i, vm| Row::sequence_downcast(seq)\n                        .data\n                        .getitem_by_index(vm, i)),\n                    ..PySequenceMethods::NOT_IMPLEMENTED\n                });\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Blob\", traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Blob {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        inner: PyMutex<Option<BlobInner>>,\n    }\n\n    impl Unconstructible for Blob {}\n\n    #[derive(Debug)]\n    struct BlobInner {\n        blob: SqliteBlob,\n        offset: c_int,\n    }\n\n    impl Drop for BlobInner {\n        fn drop(&mut self) {\n            unsafe { sqlite3_blob_close(self.blob.blob) };\n        }\n    }\n\n    #[pyclass(with(AsMapping, Unconstructible, AsNumber, AsSequence))]\n    impl Blob {\n        #[pymethod]\n        fn close(&self) {\n            self.inner.lock().take();\n        }\n\n        #[pymethod]\n        fn read(\n            &self,\n            length: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<PyBytes>> {\n            let mut length = length.unwrap_or(-1);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let max_read = blob_len - inner.offset;\n\n            if length < 0 || length > max_read {\n                length = max_read;\n            }\n\n            if length == 0 {\n                Ok(vm.ctx.empty_bytes.clone())\n            } else {\n                let mut buf = Vec::<u8>::with_capacity(length as usize);\n                let ret = inner\n                    .blob\n                    .read(buf.as_mut_ptr().cast(), length, inner.offset);\n                self.check(ret, vm)?;\n                unsafe { buf.set_len(length as usize) };\n                inner.offset += length;\n                Ok(vm.ctx.new_bytes(buf))\n            }\n        }\n\n        #[pymethod]\n        fn write(&self, data: PyBuffer, vm: &VirtualMachine) -> PyResult<()> {\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let length = Self::expect_write(blob_len, data.desc.len, inner.offset, vm)?;\n\n            let ret = data.contiguous_or_collect(|buf| {\n                inner.blob.write(buf.as_ptr().cast(), length, inner.offset)\n            });\n\n            self.check(ret, vm)?;\n            inner.offset += length;\n            Ok(())\n        }\n\n        #[pymethod]\n        fn tell(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.inner(vm).map(|x| x.offset)\n        }\n\n        #[pymethod]\n        fn seek(\n            &self,\n            mut offset: c_int,\n            origin: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let origin = origin.unwrap_or(libc::SEEK_SET);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n\n            let overflow_err = || vm.new_overflow_error(\"seek offset results in overflow\");\n\n            match origin {\n                libc::SEEK_SET => {}\n                libc::SEEK_CUR => {\n                    offset = offset.checked_add(inner.offset).ok_or_else(overflow_err)?\n                }\n                libc::SEEK_END => offset = offset.checked_add(blob_len).ok_or_else(overflow_err)?,\n                _ => {\n                    return Err(vm.new_value_error(\n                        \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\",\n                    ));\n                }\n            }\n\n            if offset < 0 || offset > blob_len {\n                Err(vm.new_value_error(\"offset out of blob range\"))\n            } else {\n                inner.offset = offset;\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult<PyRef<Self>> {\n            let _ = zelf.inner(vm)?;\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn __exit__(&self, _args: FuncArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let _ = self.inner(vm)?;\n            self.close();\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, BlobInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Cannot operate on a closed blob.\".to_owned(),\n                ))\n            }\n        }\n\n        fn wrapped_index(index: PyIntRef, length: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let mut index = index.try_to_primitive::<c_int>(vm)?;\n            if index < 0 {\n                index += length;\n            }\n            if index < 0 || index >= length {\n                Err(vm.new_index_error(\"Blob index out of range\"))\n            } else {\n                Ok(index)\n            }\n        }\n\n        fn expect_write(\n            blob_len: c_int,\n            length: usize,\n            offset: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<c_int> {\n            let max_write = blob_len - offset;\n            if length <= max_write as usize {\n                Ok(length as c_int)\n            } else {\n                Err(vm.new_value_error(\"data longer than blob length\"))\n            }\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            let inner = self.inner(vm)?;\n            if let Some(index) = needle.try_index_opt(vm) {\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                let mut byte: u8 = 0;\n                let ret = inner.blob.read_single(&mut byte, index);\n                self.check(ret, vm).map(|_| vm.ctx.new_int(byte).into())\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, length) = slice.adjust_indices(blob_len as usize);\n                let mut buf = Vec::<u8>::with_capacity(length);\n\n                if step == 1 {\n                    let ret = inner.blob.read(\n                        buf.as_mut_ptr().cast(),\n                        length as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n                    unsafe { buf.set_len(length) };\n                } else {\n                    let iter = SaturatedSliceIter::from_adjust_indices(range, step, length);\n                    let mut byte: u8 = 0;\n                    for index in iter {\n                        let ret = inner.blob.read_single(&mut byte, index as c_int);\n                        self.check(ret, vm)?;\n                        buf.push(byte);\n                    }\n                }\n                Ok(vm.ctx.new_bytes(buf).into())\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn ass_subscript(\n            &self,\n            needle: &PyObject,\n            value: Option<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(value) = value else {\n                return Err(vm.new_type_error(\"Blob doesn't support slice deletion\"));\n            };\n            let inner = self.inner(vm)?;\n\n            if let Some(index) = needle.try_index_opt(vm) {\n                // Handle single item assignment: blob[i] = b\n                let Some(value) = value.downcast_ref::<PyInt>() else {\n                    return Err(vm.new_type_error(format!(\n                        \"'{}' object cannot be interpreted as an integer\",\n                        value.class()\n                    )));\n                };\n                let value = value.try_to_primitive::<u8>(vm)?;\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                Self::expect_write(blob_len, 1, index, vm)?;\n                let ret = inner.blob.write_single(value, index);\n                self.check(ret, vm)\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                // Handle slice assignment: blob[a:b:c] = b\"...\"\n                let value_buf = PyBuffer::try_from_borrowed_object(vm, &value)?;\n\n                let buf = value_buf\n                    .as_contiguous()\n                    .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, slice_len) = slice.adjust_indices(blob_len as usize);\n\n                if step == 0 {\n                    return Err(vm.new_value_error(\"slice step cannot be zero\"));\n                }\n\n                if buf.len() != slice_len {\n                    return Err(vm.new_index_error(\"Blob slice assignment is wrong size\"));\n                }\n\n                if slice_len == 0 {\n                    return Ok(());\n                }\n\n                if step == 1 {\n                    let ret = inner.blob.write(\n                        buf.as_ptr().cast(),\n                        buf.len() as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                } else {\n                    let span_len = range.end - range.start;\n                    let mut temp_buf = vec![0u8; span_len];\n\n                    let ret = inner.blob.read(\n                        temp_buf.as_mut_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n\n                    let mut i_in_temp: usize = 0;\n                    for i_in_src in 0..slice_len {\n                        temp_buf[i_in_temp] = buf[i_in_src];\n                        i_in_temp += step as usize;\n                    }\n\n                    let ret = inner.blob.write(\n                        temp_buf.as_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                }\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn check(&self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.connection.db_lock(vm)?.error_extended(vm))\n            }\n        }\n    }\n\n    impl AsMapping for Blob {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: PyMappingMethods = PyMappingMethods {\n                length: atomic_func!(|mapping, vm| Blob::mapping_downcast(mapping)\n                    .inner(vm)\n                    .map(|x| x.blob.bytes() as usize)),\n                subscript: atomic_func!(|mapping, needle, vm| {\n                    Blob::mapping_downcast(mapping).subscript(needle, vm)\n                }),\n                ass_subscript: atomic_func!(|mapping, needle, value, vm| {\n                    Blob::mapping_downcast(mapping).ass_subscript(needle, value, vm)\n                }),\n            };\n            &AS_MAPPING\n        }\n    }\n\n    impl AsNumber for Blob {\n        fn as_number() -> &'static PyNumberMethods {\n            static AS_NUMBER: PyNumberMethods = PyNumberMethods {\n                add: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for +: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                multiply: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for *: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                ..PyNumberMethods::NOT_IMPLEMENTED\n            };\n            &AS_NUMBER\n        }\n    }\n\n    impl AsSequence for Blob {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: PySequenceMethods = PySequenceMethods {\n                length: AtomicCell::new(None),\n                concat: AtomicCell::new(None),\n                repeat: AtomicCell::new(None),\n                item: AtomicCell::new(None),\n                ass_item: AtomicCell::new(None),\n                contains: atomic_func!(|seq, _needle, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"argument of type '{}' is not iterable\",\n                        seq.obj.class().name(),\n                    )))\n                }),\n                inplace_concat: AtomicCell::new(None),\n                inplace_repeat: AtomicCell::new(None),\n            };\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(Debug, PyPayload)]\n    struct PrepareProtocol {}\n\n    #[pyclass()]\n    impl PrepareProtocol {}\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Statement\")]\n    #[derive(PyPayload)]\n    struct Statement {\n        st: PyMutex<SqliteStatement>,\n        pub is_dml: bool,\n    }\n\n    impl Debug for Statement {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(\n                f,\n                \"{} Statement\",\n                if self.is_dml { \"DML\" } else { \"Non-DML\" }\n            )\n        }\n    }\n\n    impl Unconstructible for Statement {}\n\n    #[pyclass(with(Unconstructible))]\n    impl Statement {\n        fn new(\n            connection: &Connection,\n            sql: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<Self>> {\n            if sql.as_str().contains('\\0') {\n                return Err(new_programming_error(\n                    vm,\n                    \"statement contains a null character.\".to_owned(),\n                ));\n            }\n            let sql_cstr = sql.to_cstring(vm)?;\n\n            let db = connection.db_lock(vm)?;\n\n            db.sql_limit(sql.byte_len(), vm)?;\n\n            let mut tail = null();\n            let st = db.prepare(sql_cstr.as_ptr(), &mut tail, vm)?;\n\n            let Some(st) = st else {\n                return Ok(None);\n            };\n\n            let tail = unsafe { CStr::from_ptr(tail) };\n            let tail = tail.to_bytes();\n            if lstrip_sql(tail).is_some() {\n                return Err(new_programming_error(\n                    vm,\n                    \"You can only execute one statement at a time.\".to_owned(),\n                ));\n            }\n\n            let is_dml = if let Some(head) = lstrip_sql(sql_cstr.as_bytes()) {\n                head.len() >= 6\n                    && (head[..6].eq_ignore_ascii_case(b\"insert\")\n                        || head[..6].eq_ignore_ascii_case(b\"update\")\n                        || head[..6].eq_ignore_ascii_case(b\"delete\")\n                        || (head.len() >= 7 && head[..7].eq_ignore_ascii_case(b\"replace\")))\n            } else {\n                false\n            };\n\n            Ok(Some(Self {\n                st: PyMutex::from(st),\n                is_dml,\n            }))\n        }\n\n        fn lock(&self) -> PyMutexGuard<'_, SqliteStatement> {\n            self.st.lock()\n        }\n    }\n\n    struct Sqlite {\n        raw: SqliteRaw,\n    }\n\n    impl From<SqliteRaw> for Sqlite {\n        fn from(raw: SqliteRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for Sqlite {\n        fn drop(&mut self) {\n            unsafe { sqlite3_close_v2(self.raw.db) };\n        }\n    }\n\n    impl Deref for Sqlite {\n        type Target = SqliteRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteRaw {\n        db: *mut sqlite3,\n    }\n\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"threading\")] {\n            unsafe impl Send for SqliteStatement {}\n            // unsafe impl Sync for SqliteStatement {}\n            unsafe impl Send for Sqlite {}\n            // unsafe impl Sync for Sqlite {}\n            unsafe impl Send for SqliteBlob {}\n        }\n    }\n\n    impl From<SqliteStatementRaw> for SqliteRaw {\n        fn from(stmt: SqliteStatementRaw) -> Self {\n            unsafe {\n                Self {\n                    db: sqlite3_db_handle(stmt.st),\n                }\n            }\n        }\n    }\n\n    impl SqliteRaw {\n        fn check(self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.error_extended(vm))\n            }\n        }\n\n        fn error_extended(self, vm: &VirtualMachine) -> PyBaseExceptionRef {\n            let errcode = unsafe { sqlite3_errcode(self.db) };\n            let typ = exception_type_from_errcode(errcode, vm);\n            let extended_errcode = unsafe { sqlite3_extended_errcode(self.db) };\n            let errmsg = unsafe { sqlite3_errmsg(self.db) };\n            let errmsg = unsafe { CStr::from_ptr(errmsg) };\n            let errmsg = errmsg.to_str().unwrap().to_owned();\n\n            raise_exception(typ.to_owned(), extended_errcode, errmsg, vm)\n        }\n\n        fn open(path: *const libc::c_char, uri: bool, vm: &VirtualMachine) -> PyResult<Self> {\n            let mut db = null_mut();\n            let ret = unsafe {\n                sqlite3_open_v2(\n                    path,\n                    &raw mut db,\n                    SQLITE_OPEN_READWRITE\n                        | SQLITE_OPEN_CREATE\n                        | if uri { SQLITE_OPEN_URI } else { 0 },\n                    null(),\n                )\n            };\n            let zelf = Self { db };\n            zelf.check(ret, vm).map(|_| zelf)\n        }\n\n        fn _exec(self, sql: &[u8], vm: &VirtualMachine) -> PyResult<()> {\n            let ret =\n                unsafe { sqlite3_exec(self.db, sql.as_ptr().cast(), None, null_mut(), null_mut()) };\n            self.check(ret, vm)\n        }\n\n        fn prepare(\n            self,\n            sql: *const libc::c_char,\n            tail: *mut *const libc::c_char,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<SqliteStatement>> {\n            let mut st = null_mut();\n            let ret = unsafe { sqlite3_prepare_v2(self.db, sql, -1, &mut st, tail) };\n            self.check(ret, vm)?;\n            if st.is_null() {\n                Ok(None)\n            } else {\n                Ok(Some(SqliteStatement::from(SqliteStatementRaw::from(st))))\n            }\n        }\n\n        fn limit(self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let old_limit = unsafe { sqlite3_limit(self.db, category, limit) };\n            if old_limit >= 0 {\n                Ok(old_limit)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"'category' is out of bounds\".to_owned(),\n                ))\n            }\n        }\n\n        fn sql_limit(self, len: usize, vm: &VirtualMachine) -> PyResult<()> {\n            if len <= unsafe { sqlite3_limit(self.db, SQLITE_LIMIT_SQL_LENGTH, -1) } as usize {\n                Ok(())\n            } else {\n                Err(new_data_error(vm, \"query string is too large\".to_owned()))\n            }\n        }\n\n        fn is_autocommit(self) -> bool {\n            unsafe { sqlite3_get_autocommit(self.db) != 0 }\n        }\n\n        fn changes(self) -> c_int {\n            unsafe { sqlite3_changes(self.db) }\n        }\n\n        fn total_changes(self) -> c_int {\n            unsafe { sqlite3_total_changes(self.db) }\n        }\n\n        fn lastrowid(self) -> c_longlong {\n            unsafe { sqlite3_last_insert_rowid(self.db) }\n        }\n\n        fn implicit_commit(self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.is_autocommit() {\n                Ok(())\n            } else {\n                self._exec(b\"COMMIT\\0\", vm)\n            }\n        }\n\n        fn begin_transaction(\n            self,\n            isolation_level: Option<PyStrRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(isolation_level) = isolation_level else {\n                return Ok(());\n            };\n            let mut s = Vec::with_capacity(16);\n            s.extend(b\"BEGIN \");\n            s.extend(isolation_level.as_str().bytes());\n            s.push(b'\\0');\n            self._exec(&s, vm)\n        }\n\n        fn interrupt(self) {\n            unsafe { sqlite3_interrupt(self.db) }\n        }\n\n        fn busy_timeout(self, timeout: i32) {\n            unsafe { sqlite3_busy_timeout(self.db, timeout) };\n        }\n\n        #[allow(clippy::too_many_arguments)]\n        fn create_function(\n            self,\n            name: *const libc::c_char,\n            narg: c_int,\n            flags: c_int,\n            data: *mut c_void,\n            func: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            step: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            finalize: Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n            destroy: Option<unsafe extern \"C\" fn(arg1: *mut c_void)>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let ret = unsafe {\n                sqlite3_create_function_v2(\n                    self.db, name, narg, flags, data, func, step, finalize, destroy,\n                )\n            };\n            self.check(ret, vm)\n                .map_err(|_| new_operational_error(vm, \"Error creating function\".to_owned()))\n        }\n    }\n\n    struct SqliteStatement {\n        raw: SqliteStatementRaw,\n    }\n\n    impl From<SqliteStatementRaw> for SqliteStatement {\n        fn from(raw: SqliteStatementRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for SqliteStatement {\n        fn drop(&mut self) {\n            unsafe {\n                sqlite3_finalize(self.raw.st);\n            }\n        }\n    }\n\n    impl Deref for SqliteStatement {\n        type Target = SqliteStatementRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteStatementRaw {\n        st: *mut sqlite3_stmt,\n    }\n\n    impl From<*mut sqlite3_stmt> for SqliteStatementRaw {\n        fn from(st: *mut sqlite3_stmt) -> Self {\n            SqliteStatementRaw { st }\n        }\n    }\n\n    impl SqliteStatementRaw {\n        fn step(self) -> c_int {\n            unsafe { sqlite3_step(self.st) }\n        }\n\n        fn step_row_else_done(self, vm: &VirtualMachine) -> PyResult<bool> {\n            let ret = self.step();\n\n            if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                Err(exc)\n            } else if ret == SQLITE_ROW {\n                Ok(true)\n            } else if ret == SQLITE_DONE {\n                Ok(false)\n            } else {\n                Err(SqliteRaw::from(self).error_extended(vm))\n            }\n        }\n\n        fn reset(self) {\n            unsafe { sqlite3_reset(self.st) };\n        }\n\n        fn data_count(self) -> c_int {\n            unsafe { sqlite3_data_count(self.st) }\n        }\n\n        fn bind_parameter(\n            self,\n            pos: c_int,\n            parameter: &PyObject,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let adapted;\n            let obj = if need_adapt(parameter, vm) {\n                adapted = _adapt(\n                    parameter,\n                    PrepareProtocol::class(&vm.ctx).to_owned(),\n                    |x| Ok(x.to_owned()),\n                    vm,\n                )?;\n                &adapted\n            } else {\n                parameter\n            };\n\n            let ret = if vm.is_none(obj) {\n                unsafe { sqlite3_bind_null(self.st, pos) }\n            } else if let Some(val) = obj.downcast_ref::<PyInt>() {\n                let val = val.try_to_primitive::<i64>(vm).map_err(|_| {\n                    vm.new_overflow_error(\"Python int too large to convert to SQLite INTEGER\")\n                })?;\n                unsafe { sqlite3_bind_int64(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyFloat>() {\n                let val = val.to_f64();\n                unsafe { sqlite3_bind_double(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyStr>() {\n                let val = val.try_as_utf8(vm)?;\n                let (ptr, len) = str_to_ptr_len(val, vm)?;\n                unsafe { sqlite3_bind_text(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, obj) {\n                let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                unsafe { sqlite3_bind_blob(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Error binding parameter {}: type '{}' is not supported\",\n                        pos,\n                        obj.class()\n                    ),\n                ));\n            };\n\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                let db = SqliteRaw::from(self);\n                db.check(ret, vm)\n            }\n        }\n\n        fn bind_parameters(self, parameters: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            if let Some(dict) = parameters.downcast_ref::<PyDict>() {\n                self.bind_parameters_name(dict, vm)\n            } else if let Ok(seq) = PySequence::try_protocol(parameters, vm) {\n                self.bind_parameters_sequence(seq, vm)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"parameters are of unsupported type\".to_owned(),\n                ))\n            }\n        }\n\n        fn bind_parameters_name(self, dict: &Py<PyDict>, vm: &VirtualMachine) -> PyResult<()> {\n            let num_needed = unsafe { sqlite3_bind_parameter_count(self.st) };\n\n            for i in 1..=num_needed {\n                let name = unsafe { sqlite3_bind_parameter_name(self.st, i) };\n                if name.is_null() {\n                    return Err(new_programming_error(vm, \"Binding {} has no name, but you supplied a dictionary (which has only names).\".to_owned()));\n                }\n                let name = unsafe { name.add(1) };\n                let name = ptr_to_str(name, vm)?;\n\n                let val = match dict.get_item_opt(name, vm)? {\n                    Some(val) => val,\n                    None => {\n                        return Err(new_programming_error(\n                            vm,\n                            format!(\"You did not supply a value for binding parameter :{name}.\",),\n                        ));\n                    }\n                };\n\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn bind_parameter_count(self) -> c_int {\n            unsafe { sqlite3_bind_parameter_count(self.st) }\n        }\n\n        fn bind_parameters_sequence(\n            self,\n            seq: PySequence<'_>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let num_needed = self.bind_parameter_count();\n            let num_supplied = seq.length(vm)?;\n\n            if num_supplied != num_needed as usize {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Incorrect number of bindings supplied. The current statement uses {}, and {} were supplied.\",\n                        num_needed, num_supplied\n                    ),\n                ));\n            }\n\n            for i in 1..=num_needed {\n                let val = seq.get_item(i as isize - 1, vm)?;\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn column_count(self) -> c_int {\n            unsafe { sqlite3_column_count(self.st) }\n        }\n\n        fn column_type(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_type(self.st, pos) }\n        }\n\n        fn column_int(self, pos: c_int) -> i64 {\n            unsafe { sqlite3_column_int64(self.st, pos) }\n        }\n\n        fn column_double(self, pos: c_int) -> f64 {\n            unsafe { sqlite3_column_double(self.st, pos) }\n        }\n\n        fn column_blob(self, pos: c_int) -> *const c_void {\n            unsafe { sqlite3_column_blob(self.st, pos) }\n        }\n\n        fn column_text(self, pos: c_int) -> *const u8 {\n            unsafe { sqlite3_column_text(self.st, pos) }\n        }\n\n        fn column_decltype(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_decltype(self.st, pos) }\n        }\n\n        fn column_bytes(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_bytes(self.st, pos) }\n        }\n\n        fn column_name(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_name(self.st, pos) }\n        }\n\n        fn columns_name(self, detect_types: i32, vm: &VirtualMachine) -> PyResult<Vec<PyStrRef>> {\n            let count = self.column_count();\n            (0..count)\n                .map(|i| {\n                    let name = self.column_name(i);\n                    let name_str = ptr_to_str(name, vm)?;\n\n                    // If PARSE_COLNAMES is enabled, strip everything after the first '[' (and preceding space)\n                    let processed_name = if detect_types & PARSE_COLNAMES != 0\n                        && let Some(bracket_pos) = name_str.find('[')\n                    {\n                        // Check if there's a single space before '[' and remove it (CPython compatibility)\n                        let end_pos = if bracket_pos > 0\n                            && name_str.chars().nth(bracket_pos - 1) == Some(' ')\n                        {\n                            bracket_pos - 1\n                        } else {\n                            bracket_pos\n                        };\n\n                        &name_str[..end_pos]\n                    } else {\n                        name_str\n                    };\n\n                    Ok(vm.ctx.new_str(processed_name))\n                })\n                .collect()\n        }\n\n        fn columns_description(\n            self,\n            detect_types: i32,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<PyTupleRef>> {\n            if self.column_count() == 0 {\n                return Ok(None);\n            }\n            let columns = self\n                .columns_name(detect_types, vm)?\n                .into_iter()\n                .map(|s| {\n                    vm.ctx\n                        .new_tuple(vec![\n                            s.into(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                        ])\n                        .into()\n                })\n                .collect();\n            Ok(Some(vm.ctx.new_tuple(columns)))\n        }\n\n        fn busy(self) -> bool {\n            unsafe { sqlite3_stmt_busy(self.st) != 0 }\n        }\n\n        fn readonly(self) -> bool {\n            unsafe { sqlite3_stmt_readonly(self.st) != 0 }\n        }\n    }\n\n    #[derive(Debug, Copy, Clone)]\n    struct SqliteBlob {\n        blob: *mut sqlite3_blob,\n    }\n\n    impl SqliteBlob {\n        fn bytes(self) -> c_int {\n            unsafe { sqlite3_blob_bytes(self.blob) }\n        }\n\n        fn write(self, buf: *const c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_write(self.blob, buf, length, offset) }\n        }\n\n        fn read(self, buf: *mut c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_read(self.blob, buf, length, offset) }\n        }\n\n        fn read_single(self, byte: &mut u8, offset: c_int) -> c_int {\n            self.read(byte as *mut u8 as *mut _, 1, offset)\n        }\n\n        fn write_single(self, byte: u8, offset: c_int) -> c_int {\n            self.write(&byte as *const u8 as *const _, 1, offset)\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteContext {\n        ctx: *mut sqlite3_context,\n    }\n\n    impl From<*mut sqlite3_context> for SqliteContext {\n        fn from(ctx: *mut sqlite3_context) -> Self {\n            Self { ctx }\n        }\n    }\n\n    impl SqliteContext {\n        fn user_data<T>(self) -> *mut T {\n            unsafe { sqlite3_user_data(self.ctx).cast() }\n        }\n\n        fn aggregate_context<T>(self) -> *mut T {\n            unsafe { sqlite3_aggregate_context(self.ctx, std::mem::size_of::<T>() as c_int).cast() }\n        }\n\n        fn result_exception(self, vm: &VirtualMachine, exc: PyBaseExceptionRef, msg: &str) {\n            if exc.fast_isinstance(vm.ctx.exceptions.memory_error) {\n                unsafe { sqlite3_result_error_nomem(self.ctx) }\n            } else if exc.fast_isinstance(vm.ctx.exceptions.overflow_error) {\n                unsafe { sqlite3_result_error_toobig(self.ctx) }\n            } else {\n                unsafe { sqlite3_result_error(self.ctx, msg.as_ptr().cast(), -1) }\n            }\n            if enable_traceback().load(Ordering::Relaxed) {\n                vm.print_exception(exc);\n            }\n        }\n\n        fn db_handle(self) -> *mut sqlite3 {\n            unsafe { sqlite3_context_db_handle(self.ctx) }\n        }\n\n        fn result_from_object(self, val: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            unsafe {\n                if vm.is_none(val) {\n                    sqlite3_result_null(self.ctx)\n                } else if let Some(val) = val.downcast_ref::<PyInt>() {\n                    sqlite3_result_int64(self.ctx, val.try_to_primitive(vm)?)\n                } else if let Some(val) = val.downcast_ref::<PyFloat>() {\n                    sqlite3_result_double(self.ctx, val.to_f64())\n                } else if let Some(val) = val.downcast_ref::<PyStr>() {\n                    let val = val.try_as_utf8(vm)?;\n                    let (ptr, len) = str_to_ptr_len(val, vm)?;\n                    sqlite3_result_text(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, val) {\n                    let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                    sqlite3_result_blob(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else {\n                    return Err(new_programming_error(\n                        vm,\n                        \"result type not support\".to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n    }\n\n    fn value_to_object(val: *mut sqlite3_value, db: *mut sqlite3, vm: &VirtualMachine) -> PyResult {\n        let obj = unsafe {\n            match sqlite3_value_type(val) {\n                SQLITE_INTEGER => vm.ctx.new_int(sqlite3_value_int64(val)).into(),\n                SQLITE_FLOAT => vm.ctx.new_float(sqlite3_value_double(val)).into(),\n                SQLITE_TEXT => {\n                    let text =\n                        ptr_to_vec(sqlite3_value_text(val), sqlite3_value_bytes(val), db, vm)?;\n                    let text = String::from_utf8(text)\n                        .map_err(|_| vm.new_value_error(\"invalid utf-8 with SQLITE_TEXT\"))?;\n                    vm.ctx.new_str(text).into()\n                }\n                SQLITE_BLOB => {\n                    let blob = ptr_to_vec(\n                        sqlite3_value_blob(val).cast(),\n                        sqlite3_value_bytes(val),\n                        db,\n                        vm,\n                    )?;\n                    vm.ctx.new_bytes(blob).into()\n                }\n                _ => vm.ctx.none(),\n            }\n        };\n        Ok(obj)\n    }\n\n    fn ptr_to_str<'a>(p: *const libc::c_char, vm: &VirtualMachine) -> PyResult<&'a str> {\n        if p.is_null() {\n            return Err(vm.new_memory_error(\"string pointer is null\"));\n        }\n        unsafe { CStr::from_ptr(p).to_str() }\n            .map_err(|_| vm.new_value_error(\"Invalid UIF-8 codepoint\"))\n    }\n\n    fn ptr_to_string(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<String> {\n        let s = ptr_to_vec(p, nbytes, db, vm)?;\n        String::from_utf8(s).map_err(|_| vm.new_value_error(\"invalid utf-8\"))\n    }\n\n    fn ptr_to_vec(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<Vec<u8>> {\n        if p.is_null() {\n            if !db.is_null() && unsafe { sqlite3_errcode(db) } == SQLITE_NOMEM {\n                Err(vm.new_memory_error(\"sqlite out of memory\"))\n            } else {\n                Ok(vec![])\n            }\n        } else if nbytes < 0 {\n            Err(vm.new_system_error(\"negative size with ptr\"))\n        } else {\n            Ok(unsafe { std::slice::from_raw_parts(p.cast(), nbytes as usize) }.to_vec())\n        }\n    }\n\n    fn str_to_ptr_len(s: &PyUtf8Str, vm: &VirtualMachine) -> PyResult<(*const libc::c_char, i32)> {\n        let s_str = s.as_str();\n        let len = c_int::try_from(s_str.len())\n            .map_err(|_| vm.new_overflow_error(\"TEXT longer than INT_MAX bytes\"))?;\n        let ptr = s_str.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn buffer_to_ptr_len(buffer: &PyBuffer, vm: &VirtualMachine) -> PyResult<(*const c_void, i32)> {\n        let bytes = buffer\n            .as_contiguous()\n            .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n        let len = c_int::try_from(bytes.len())\n            .map_err(|_| vm.new_overflow_error(\"BLOB longer than INT_MAX bytes\"))?;\n        let ptr = bytes.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn exception_type_from_errcode(errcode: c_int, vm: &VirtualMachine) -> &'static Py<PyType> {\n        match errcode {\n            SQLITE_INTERNAL | SQLITE_NOTFOUND => internal_error_type(),\n            SQLITE_NOMEM => vm.ctx.exceptions.memory_error,\n            SQLITE_ERROR | SQLITE_PERM | SQLITE_ABORT | SQLITE_BUSY | SQLITE_LOCKED\n            | SQLITE_READONLY | SQLITE_INTERRUPT | SQLITE_IOERR | SQLITE_FULL | SQLITE_CANTOPEN\n            | SQLITE_PROTOCOL | SQLITE_EMPTY | SQLITE_SCHEMA => operational_error_type(),\n            SQLITE_CORRUPT => database_error_type(),\n            SQLITE_TOOBIG => data_error_type(),\n            SQLITE_CONSTRAINT | SQLITE_MISMATCH => integrity_error_type(),\n            SQLITE_MISUSE | SQLITE_RANGE => interface_error_type(),\n            _ => database_error_type(),\n        }\n    }\n\n    fn name_from_errcode(errcode: c_int) -> &'static str {\n        for (name, code) in ERROR_CODES {\n            if *code == errcode {\n                return name;\n            }\n        }\n        \"unknown error code\"\n    }\n\n    fn raise_exception(\n        typ: PyTypeRef,\n        errcode: c_int,\n        msg: String,\n        vm: &VirtualMachine,\n    ) -> PyBaseExceptionRef {\n        let dict = vm.ctx.new_dict();\n        if let Err(e) = dict.set_item(\"sqlite_errorcode\", vm.ctx.new_int(errcode).into(), vm) {\n            return e;\n        }\n        let errname = name_from_errcode(errcode);\n        if let Err(e) = dict.set_item(\"sqlite_errorname\", vm.ctx.new_str(errname).into(), vm) {\n            return e;\n        }\n\n        vm.new_exception_msg_dict(typ, msg, dict)\n    }\n\n    static BEGIN_STATEMENTS: &[&[u8]] = &[\n        b\"BEGIN \",\n        b\"BEGIN DEFERRED\",\n        b\"BEGIN IMMEDIATE\",\n        b\"BEGIN EXCLUSIVE\",\n    ];\n\n    fn begin_statement_ptr_from_isolation_level(\n        s: &PyStr,\n        vm: &VirtualMachine,\n    ) -> PyResult<*const libc::c_char> {\n        BEGIN_STATEMENTS\n            .iter()\n            .find(|&&x| x[6..].eq_ignore_ascii_case(s.as_bytes()))\n            .map(|&x| x.as_ptr().cast())\n            .ok_or_else(|| {\n                vm.new_value_error(\n                    \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or 'EXCLUSIVE'\",\n                )\n            })\n    }\n\n    fn lstrip_sql(sql: &[u8]) -> Option<&[u8]> {\n        let mut pos = 0;\n\n        // This loop is borrowed from the SQLite source code.\n        while let Some(t_char) = sql.get(pos) {\n            match t_char {\n                b' ' | b'\\t' | b'\\x0c' | b'\\n' | b'\\r' => {\n                    // Skip whitespace.\n                    pos += 1;\n                }\n                b'-' => {\n                    // Skip line comments.\n                    if sql.get(pos + 1) == Some(&b'-') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'\\n' {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                b'/' => {\n                    // Skip C style comments.\n                    if sql.get(pos + 1) == Some(&b'*') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'*' && sql.get(pos + 1) == Some(&b'/') {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                        pos += 2;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                _ => {\n                    return Some(&sql[pos..]);\n                }\n            }\n        }\n\n        None\n    }\n}\n"
                }
              ],
              []
            ],
            "kind": "textEditGroup",
            "uri": {
              "$mid": 1,
              "external": "file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "fsPath": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "path": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "scheme": "file"
            }
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "정규식 `fn init\\(zelf: PyRef<Self>` (`**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/vm/src/builtins/list.rs#360-360), 360 줄에서 420 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findFiles",
          "input": "`**/struct PyRef` 일치하는 파일을 검색하는 중"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `pub struct PyRef` (`**/crates/vm/src/**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/vm/src/object/core.rs#1000-1000), 1000 줄에서 1120 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/vm/src/object/core.rs#1120-1120), 1120 줄에서 1280 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `struct PyRefMut` (`**/crates/vm/src/**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `pub struct Py<` (`**/crates/vm/src/**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/vm/src/object/core.rs#880-880), 880 줄에서 1006 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `detect_types` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `PyRefMut` 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `PyAtomic<` (`**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `payload_mut` (`**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "정규식 `as_u64\\(\\)` (`**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `check_same_thread` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `thread_ident` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `Radium` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#820-820), 820 줄에서 960 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "textEditGroup",
          "input": {
            "done": true,
            "edits": [
              [
                {
                  "range": {
                    "endColumn": 1,
                    "endLineNumber": 3387,
                    "startColumn": 1,
                    "startLineNumber": 1
                  },
                  "text": "// spell-checker:ignore libsqlite3 threadsafety PYSQLITE decltypes colnames collseq cantinit dirtywal\n// spell-checker:ignore corruptfs narg setinputsizes setoutputsize lastrowid arraysize executemany\n// spell-checker:ignore blobopen executescript iterdump getlimit setlimit errorcode errorname\n// spell-checker:ignore rowid rowcount fetchone fetchmany fetchall errcode errname vtable pagecount\n// spell-checker:ignore autocommit libversion toobig errmsg nomem threadsafe longlong vdbe reindex\n// spell-checker:ignore savepoint cantopen ioerr nolfs nomem notadb notfound fullpath notempdir vtab\n// spell-checker:ignore checkreservedlock noent fstat rdlock shmlock shmmap shmopen shmsize sharedcache\n// spell-checker:ignore cantlock commithook foreignkey notnull primarykey gettemppath autoindex convpath\n// spell-checker:ignore dbmoved vnode nbytes\n\nuse rustpython_vm::{AsObject, PyRef, VirtualMachine, builtins::PyModule};\n\n// pub(crate) use _sqlite::make_module;\npub(crate) fn make_module(vm: &VirtualMachine) -> PyRef<PyModule> {\n    // TODO: sqlite version check\n    let module = _sqlite::make_module(vm);\n    _sqlite::setup_module(module.as_object(), vm);\n    module\n}\n\n#[pymodule]\nmod _sqlite {\n    use crossbeam_utils::atomic::AtomicCell;\n    use libsqlite3_sys::{\n        SQLITE_BLOB, SQLITE_DETERMINISTIC, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL,\n        SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, SQLITE_OPEN_URI, SQLITE_TEXT, SQLITE_TRACE_STMT,\n        SQLITE_TRANSIENT, SQLITE_UTF8, sqlite3, sqlite3_aggregate_context, sqlite3_backup_finish,\n        sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining,\n        sqlite3_backup_step, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64,\n        sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name,\n        sqlite3_bind_text, sqlite3_blob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open,\n        sqlite3_blob_read, sqlite3_blob_write, sqlite3_busy_timeout, sqlite3_changes,\n        sqlite3_close_v2, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count,\n        sqlite3_column_decltype, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_name,\n        sqlite3_column_text, sqlite3_column_type, sqlite3_complete, sqlite3_context,\n        sqlite3_context_db_handle, sqlite3_create_collation_v2, sqlite3_create_function_v2,\n        sqlite3_create_window_function, sqlite3_data_count, sqlite3_db_handle, sqlite3_errcode,\n        sqlite3_errmsg, sqlite3_exec, sqlite3_expanded_sql, sqlite3_extended_errcode,\n        sqlite3_finalize, sqlite3_get_autocommit, sqlite3_interrupt, sqlite3_last_insert_rowid,\n        sqlite3_libversion, sqlite3_limit, sqlite3_open_v2, sqlite3_prepare_v2,\n        sqlite3_progress_handler, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double,\n        sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_error_toobig,\n        sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_set_authorizer,\n        sqlite3_sleep, sqlite3_step, sqlite3_stmt, sqlite3_stmt_busy, sqlite3_stmt_readonly,\n        sqlite3_threadsafe, sqlite3_total_changes, sqlite3_trace_v2, sqlite3_user_data,\n        sqlite3_value, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double,\n        sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type,\n    };\n    use malachite_bigint::Sign;\n    use rustpython_common::{\n        atomic::{Ordering, PyAtomic, Radium},\n        hash::PyHash,\n        lock::{PyMappedMutexGuard, PyMutex, PyMutexGuard},\n        static_cell,\n    };\n    use rustpython_vm::{\n        __exports::paste,\n        AsObject, Py, PyAtomicRef, PyObject, PyObjectRef, PyPayload, PyRef, PyResult,\n        TryFromBorrowedObject, VirtualMachine, atomic_func,\n        builtins::{\n            PyBaseException, PyBaseExceptionRef, PyByteArray, PyBytes, PyDict, PyDictRef, PyFloat,\n            PyInt, PyIntRef, PySlice, PyStr, PyStrRef, PyTuple, PyTupleRef, PyType, PyTypeRef,\n            PyUtf8Str, PyUtf8StrRef,\n        },\n        convert::IntoObject,\n        function::{\n            ArgCallable, ArgIterable, FsPath, FuncArgs, OptionalArg, PyComparisonValue,\n            PySetterValue,\n        },\n        object::{Traverse, TraverseFn},\n        protocol::{\n            PyBuffer, PyIterReturn, PyMappingMethods, PyNumberMethods, PySequence,\n            PySequenceMethods,\n        },\n        sliceable::{SaturatedSliceIter, SliceableSequenceOp},\n        types::{\n            AsMapping, AsNumber, AsSequence, Callable, Comparable, Constructor, Hashable,\n            Initializer, IterNext, Iterable, PyComparisonOp, SelfIter, Unconstructible,\n        },\n        utils::ToCString,\n    };\n    use std::{\n        ffi::{CStr, c_int, c_longlong, c_uint, c_void},\n        fmt::Debug,\n        ops::Deref,\n        ptr::{NonNull, null, null_mut},\n        thread::ThreadId,\n    };\n\n    macro_rules! exceptions {\n        ($(($x:ident, $base:expr)),*) => {\n            paste::paste! {\n                static_cell! {\n                    $(\n                        static [<$x:snake:upper>]: PyTypeRef;\n                    )*\n                }\n                $(\n                    #[allow(dead_code)]\n                    fn [<new_ $x:snake>](vm: &VirtualMachine, msg: String) -> PyBaseExceptionRef {\n                        vm.new_exception_msg([<$x:snake _type>]().to_owned(), msg)\n                    }\n                    fn [<$x:snake _type>]() -> &'static Py<PyType> {\n                        [<$x:snake:upper>].get().expect(\"exception type not initialize\")\n                    }\n                )*\n                fn setup_module_exceptions(module: &PyObject, vm: &VirtualMachine) {\n                    $(\n                        #[allow(clippy::redundant_closure_call)]\n                        let exception = [<$x:snake:upper>].get_or_init(|| {\n                            let base = $base(vm);\n                            vm.ctx.new_exception_type(\"_sqlite3\", stringify!($x), Some(vec![base.to_owned()]))\n                        });\n                        module.set_attr(stringify!($x), exception.clone().into_object(), vm).unwrap();\n                    )*\n                }\n            }\n        };\n    }\n\n    exceptions!(\n        (Warning, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (Error, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (InterfaceError, |_| error_type()),\n        (DatabaseError, |_| error_type()),\n        (DataError, |_| database_error_type()),\n        (OperationalError, |_| database_error_type()),\n        (IntegrityError, |_| database_error_type()),\n        (InternalError, |_| database_error_type()),\n        (ProgrammingError, |_| database_error_type()),\n        (NotSupportedError, |_| database_error_type())\n    );\n\n    #[pyattr]\n    fn sqlite_version(vm: &VirtualMachine) -> String {\n        let s = unsafe { sqlite3_libversion() };\n        ptr_to_str(s, vm).unwrap().to_owned()\n    }\n\n    #[pyattr]\n    fn threadsafety(_: &VirtualMachine) -> c_int {\n        let mode = unsafe { sqlite3_threadsafe() };\n        match mode {\n            0 => 0,\n            1 => 3,\n            2 => 1,\n            _ => panic!(\"Unable to interpret SQLite threadsafety mode\"),\n        }\n    }\n\n    #[pyattr(name = \"_deprecated_version\")]\n    const PYSQLITE_VERSION: &str = \"2.6.0\";\n\n    #[pyattr]\n    const PARSE_DECLTYPES: c_int = 1;\n    #[pyattr]\n    const PARSE_COLNAMES: c_int = 2;\n\n    #[pyattr]\n    use libsqlite3_sys::{\n        SQLITE_ALTER_TABLE, SQLITE_ANALYZE, SQLITE_ATTACH, SQLITE_CREATE_INDEX,\n        SQLITE_CREATE_TABLE, SQLITE_CREATE_TEMP_INDEX, SQLITE_CREATE_TEMP_TABLE,\n        SQLITE_CREATE_TEMP_TRIGGER, SQLITE_CREATE_TEMP_VIEW, SQLITE_CREATE_TRIGGER,\n        SQLITE_CREATE_VIEW, SQLITE_CREATE_VTABLE, SQLITE_DELETE, SQLITE_DENY, SQLITE_DETACH,\n        SQLITE_DROP_INDEX, SQLITE_DROP_TABLE, SQLITE_DROP_TEMP_INDEX, SQLITE_DROP_TEMP_TABLE,\n        SQLITE_DROP_TEMP_TRIGGER, SQLITE_DROP_TEMP_VIEW, SQLITE_DROP_TRIGGER, SQLITE_DROP_VIEW,\n        SQLITE_DROP_VTABLE, SQLITE_FUNCTION, SQLITE_IGNORE, SQLITE_INSERT, SQLITE_LIMIT_ATTACHED,\n        SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH,\n        SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH,\n        SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER,\n        SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_PRAGMA, SQLITE_READ,\n        SQLITE_RECURSIVE, SQLITE_REINDEX, SQLITE_SAVEPOINT, SQLITE_SELECT, SQLITE_TRANSACTION,\n        SQLITE_UPDATE,\n    };\n\n    macro_rules! error_codes {\n        ($($x:ident),*) => {\n            $(\n                #[allow(unused_imports)]\n                use libsqlite3_sys::$x;\n            )*\n            static ERROR_CODES: &[(&str, c_int)] = &[\n            $(\n                (stringify!($x), libsqlite3_sys::$x),\n            )*\n            ];\n        };\n    }\n\n    error_codes!(\n        SQLITE_ABORT,\n        SQLITE_AUTH,\n        SQLITE_BUSY,\n        SQLITE_CANTOPEN,\n        SQLITE_CONSTRAINT,\n        SQLITE_CORRUPT,\n        SQLITE_DONE,\n        SQLITE_EMPTY,\n        SQLITE_ERROR,\n        SQLITE_FORMAT,\n        SQLITE_FULL,\n        SQLITE_INTERNAL,\n        SQLITE_INTERRUPT,\n        SQLITE_IOERR,\n        SQLITE_LOCKED,\n        SQLITE_MISMATCH,\n        SQLITE_MISUSE,\n        SQLITE_NOLFS,\n        SQLITE_NOMEM,\n        SQLITE_NOTADB,\n        SQLITE_NOTFOUND,\n        SQLITE_OK,\n        SQLITE_PERM,\n        SQLITE_PROTOCOL,\n        SQLITE_RANGE,\n        SQLITE_READONLY,\n        SQLITE_ROW,\n        SQLITE_SCHEMA,\n        SQLITE_TOOBIG,\n        SQLITE_NOTICE,\n        SQLITE_WARNING,\n        SQLITE_ABORT_ROLLBACK,\n        SQLITE_BUSY_RECOVERY,\n        SQLITE_CANTOPEN_FULLPATH,\n        SQLITE_CANTOPEN_ISDIR,\n        SQLITE_CANTOPEN_NOTEMPDIR,\n        SQLITE_CORRUPT_VTAB,\n        SQLITE_IOERR_ACCESS,\n        SQLITE_IOERR_BLOCKED,\n        SQLITE_IOERR_CHECKRESERVEDLOCK,\n        SQLITE_IOERR_CLOSE,\n        SQLITE_IOERR_DELETE,\n        SQLITE_IOERR_DELETE_NOENT,\n        SQLITE_IOERR_DIR_CLOSE,\n        SQLITE_IOERR_DIR_FSYNC,\n        SQLITE_IOERR_FSTAT,\n        SQLITE_IOERR_FSYNC,\n        SQLITE_IOERR_LOCK,\n        SQLITE_IOERR_NOMEM,\n        SQLITE_IOERR_RDLOCK,\n        SQLITE_IOERR_READ,\n        SQLITE_IOERR_SEEK,\n        SQLITE_IOERR_SHMLOCK,\n        SQLITE_IOERR_SHMMAP,\n        SQLITE_IOERR_SHMOPEN,\n        SQLITE_IOERR_SHMSIZE,\n        SQLITE_IOERR_SHORT_READ,\n        SQLITE_IOERR_TRUNCATE,\n        SQLITE_IOERR_UNLOCK,\n        SQLITE_IOERR_WRITE,\n        SQLITE_LOCKED_SHAREDCACHE,\n        SQLITE_READONLY_CANTLOCK,\n        SQLITE_READONLY_RECOVERY,\n        SQLITE_CONSTRAINT_CHECK,\n        SQLITE_CONSTRAINT_COMMITHOOK,\n        SQLITE_CONSTRAINT_FOREIGNKEY,\n        SQLITE_CONSTRAINT_FUNCTION,\n        SQLITE_CONSTRAINT_NOTNULL,\n        SQLITE_CONSTRAINT_PRIMARYKEY,\n        SQLITE_CONSTRAINT_TRIGGER,\n        SQLITE_CONSTRAINT_UNIQUE,\n        SQLITE_CONSTRAINT_VTAB,\n        SQLITE_READONLY_ROLLBACK,\n        SQLITE_IOERR_MMAP,\n        SQLITE_NOTICE_RECOVER_ROLLBACK,\n        SQLITE_NOTICE_RECOVER_WAL,\n        SQLITE_BUSY_SNAPSHOT,\n        SQLITE_IOERR_GETTEMPPATH,\n        SQLITE_WARNING_AUTOINDEX,\n        SQLITE_CANTOPEN_CONVPATH,\n        SQLITE_IOERR_CONVPATH,\n        SQLITE_CONSTRAINT_ROWID,\n        SQLITE_READONLY_DBMOVED,\n        SQLITE_AUTH_USER,\n        SQLITE_OK_LOAD_PERMANENTLY,\n        SQLITE_IOERR_VNODE,\n        SQLITE_IOERR_AUTH,\n        SQLITE_IOERR_BEGIN_ATOMIC,\n        SQLITE_IOERR_COMMIT_ATOMIC,\n        SQLITE_IOERR_ROLLBACK_ATOMIC,\n        SQLITE_ERROR_MISSING_COLLSEQ,\n        SQLITE_ERROR_RETRY,\n        SQLITE_READONLY_CANTINIT,\n        SQLITE_READONLY_DIRECTORY,\n        SQLITE_CORRUPT_SEQUENCE,\n        SQLITE_LOCKED_VTAB,\n        SQLITE_CANTOPEN_DIRTYWAL,\n        SQLITE_ERROR_SNAPSHOT,\n        SQLITE_CANTOPEN_SYMLINK,\n        SQLITE_CONSTRAINT_PINNED,\n        SQLITE_OK_SYMLINK,\n        SQLITE_BUSY_TIMEOUT,\n        SQLITE_CORRUPT_INDEX,\n        SQLITE_IOERR_DATA,\n        SQLITE_IOERR_CORRUPTFS\n    );\n\n    #[derive(FromArgs)]\n    struct ConnectArgs {\n        #[pyarg(any)]\n        database: FsPath,\n        #[pyarg(any, default = 5.0)]\n        timeout: f64,\n        #[pyarg(any, default = 0)]\n        detect_types: c_int,\n        #[pyarg(any, default = Some(vm.ctx.empty_str.to_owned()))]\n        isolation_level: Option<PyStrRef>,\n        #[pyarg(any, default = true)]\n        check_same_thread: bool,\n        #[pyarg(any, default = Connection::class(&vm.ctx).to_owned())]\n        factory: PyTypeRef,\n        // TODO: cache statements\n        #[allow(dead_code)]\n        #[pyarg(any, default = 0)]\n        cached_statements: c_int,\n        #[pyarg(any, default = false)]\n        uri: bool,\n    }\n\n    unsafe impl Traverse for ConnectArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.isolation_level.traverse(tracer_fn);\n            self.factory.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct BackupArgs {\n        #[pyarg(any)]\n        target: PyRef<Connection>,\n        #[pyarg(named, default = -1)]\n        pages: c_int,\n        #[pyarg(named, optional)]\n        progress: Option<ArgCallable>,\n        #[pyarg(named, optional)]\n        name: Option<PyStrRef>,\n        #[pyarg(named, default = 0.250)]\n        sleep: f64,\n    }\n\n    unsafe impl Traverse for BackupArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.progress.traverse(tracer_fn);\n            self.name.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct CreateFunctionArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(any)]\n        narg: c_int,\n        #[pyarg(any)]\n        func: PyObjectRef,\n        #[pyarg(named, default)]\n        deterministic: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct CreateAggregateArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(positional)]\n        narg: c_int,\n        #[pyarg(positional)]\n        aggregate_class: PyObjectRef,\n    }\n\n    #[derive(FromArgs)]\n    struct BlobOpenArgs {\n        #[pyarg(positional)]\n        table: PyStrRef,\n        #[pyarg(positional)]\n        column: PyStrRef,\n        #[pyarg(positional)]\n        row: i64,\n        #[pyarg(named, default)]\n        readonly: bool,\n        #[pyarg(named, default = vm.ctx.new_str(\"main\"))]\n        name: PyStrRef,\n    }\n\n    struct CallbackData {\n        obj: NonNull<PyObject>,\n        vm: *const VirtualMachine,\n    }\n\n    impl CallbackData {\n        fn new(obj: PyObjectRef, vm: &VirtualMachine) -> Option<Self> {\n            (!vm.is_none(&obj)).then_some(Self {\n                obj: obj.into_raw(),\n                vm,\n            })\n        }\n\n        fn retrieve(&self) -> (&PyObject, &VirtualMachine) {\n            unsafe { (self.obj.as_ref(), &*self.vm) }\n        }\n\n        unsafe extern \"C\" fn destructor(data: *mut c_void) {\n            drop(unsafe { Box::from_raw(data.cast::<Self>()) });\n        }\n\n        unsafe extern \"C\" fn func_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (func, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n\n                let val = func.call(args, vm)?;\n\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                context.result_exception(vm, exc, \"user-defined function raised exception\\0\")\n            }\n        }\n\n        unsafe extern \"C\" fn step_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (cls, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            if unsafe { (*instance).is_null() } {\n                match cls.call((), vm) {\n                    Ok(obj) => unsafe { *instance = obj.into_raw().as_ptr() },\n                    Err(exc) => {\n                        return context.result_exception(\n                            vm,\n                            exc,\n                            \"user-defined aggregate's '__init__' method raised error\\0\",\n                        );\n                    }\n                }\n            }\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"step\", args, vm);\n        }\n\n        unsafe extern \"C\" fn finalize_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let Some(instance) = (unsafe { (*instance).as_ref() }) else {\n                return;\n            };\n\n            Self::callback_result_from_method(context, instance, \"finalize\", vm);\n        }\n\n        unsafe extern \"C\" fn collation_callback(\n            data: *mut c_void,\n            a_len: c_int,\n            a_ptr: *const c_void,\n            b_len: c_int,\n            b_ptr: *const c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n\n            let f = || -> PyResult<c_int> {\n                let text1 = ptr_to_string(a_ptr.cast(), a_len, null_mut(), vm)?;\n                let text1 = vm.ctx.new_str(text1);\n                let text2 = ptr_to_string(b_ptr.cast(), b_len, null_mut(), vm)?;\n                let text2 = vm.ctx.new_str(text2);\n\n                let val = callable.call((text1, text2), vm)?;\n                let Some(val) = val.to_number().index(vm) else {\n                    return Ok(0);\n                };\n\n                let val = match val?.as_bigint().sign() {\n                    Sign::Plus => 1,\n                    Sign::Minus => -1,\n                    Sign::NoSign => 0,\n                };\n\n                Ok(val)\n            };\n\n            f().unwrap_or(0)\n        }\n\n        unsafe extern \"C\" fn value_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::callback_result_from_method(context, instance, \"value\", vm);\n        }\n\n        unsafe extern \"C\" fn inverse_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"inverse\", args, vm);\n        }\n\n        unsafe extern \"C\" fn authorizer_callback(\n            data: *mut c_void,\n            action: c_int,\n            arg1: *const libc::c_char,\n            arg2: *const libc::c_char,\n            db_name: *const libc::c_char,\n            access: *const libc::c_char,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let f = || -> PyResult<c_int> {\n                let arg1 = ptr_to_str(arg1, vm)?;\n                let arg2 = ptr_to_str(arg2, vm)?;\n                let db_name = ptr_to_str(db_name, vm)?;\n                let access = ptr_to_str(access, vm)?;\n\n                let val = callable.call((action, arg1, arg2, db_name, access), vm)?;\n                let Some(val) = val.downcast_ref::<PyInt>() else {\n                    return Ok(SQLITE_DENY);\n                };\n                val.try_to_primitive::<c_int>(vm)\n            };\n\n            f().unwrap_or(SQLITE_DENY)\n        }\n\n        unsafe extern \"C\" fn trace_callback(\n            _typ: c_uint,\n            data: *mut c_void,\n            stmt: *mut c_void,\n            sql: *mut c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let expanded = unsafe { sqlite3_expanded_sql(stmt.cast()) };\n            let f = || -> PyResult<()> {\n                let stmt = ptr_to_str(expanded, vm).or_else(|_| ptr_to_str(sql.cast(), vm))?;\n                callable.call((stmt,), vm)?;\n                Ok(())\n            };\n            let _ = f();\n            0\n        }\n\n        unsafe extern \"C\" fn progress_callback(data: *mut c_void) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            if let Ok(val) = callable.call((), vm)\n                && let Ok(val) = val.is_true(vm)\n            {\n                return val as c_int;\n            }\n            -1\n        }\n\n        fn callback_result_from_method(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let val = vm.call_method(instance, name, ())?;\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n\n        fn call_method_with_args(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            args: &[*mut sqlite3_value],\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n                vm.call_method(instance, name, args).map(drop)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n    }\n\n    impl Drop for CallbackData {\n        fn drop(&mut self) {\n            unsafe { PyObjectRef::from_raw(self.obj) };\n        }\n    }\n\n    #[pyfunction]\n    fn connect(args: ConnectArgs, vm: &VirtualMachine) -> PyResult {\n        Connection::py_new(args.factory.clone(), args, vm)\n    }\n\n    #[pyfunction]\n    fn complete_statement(statement: PyStrRef, vm: &VirtualMachine) -> PyResult<bool> {\n        let s = statement.to_cstring(vm)?;\n        let ret = unsafe { sqlite3_complete(s.as_ptr()) };\n        Ok(ret == 1)\n    }\n\n    #[pyfunction]\n    fn enable_callback_tracebacks(flag: bool) {\n        enable_traceback().store(flag, Ordering::Relaxed);\n    }\n\n    #[pyfunction]\n    fn register_adapter(typ: PyTypeRef, adapter: ArgCallable, vm: &VirtualMachine) -> PyResult<()> {\n        if typ.is(PyInt::class(&vm.ctx))\n            || typ.is(PyFloat::class(&vm.ctx))\n            || typ.is(PyStr::class(&vm.ctx))\n            || typ.is(PyByteArray::class(&vm.ctx))\n        {\n            let _ = BASE_TYPE_ADAPTED.set(());\n        }\n        let protocol = PrepareProtocol::class(&vm.ctx).to_owned();\n        let key = vm.ctx.new_tuple(vec![typ.into(), protocol.into()]);\n        adapters().set_item(key.as_object(), adapter.into(), vm)\n    }\n\n    #[pyfunction]\n    fn register_converter(\n        typename: PyStrRef,\n        converter: ArgCallable,\n        vm: &VirtualMachine,\n    ) -> PyResult<()> {\n        let name = typename.as_str().to_uppercase();\n        converters().set_item(&name, converter.into(), vm)\n    }\n\n    fn _adapt<F>(obj: &PyObject, proto: PyTypeRef, alt: F, vm: &VirtualMachine) -> PyResult\n    where\n        F: FnOnce(&PyObject) -> PyResult,\n    {\n        let proto = proto.into_object();\n        let key = vm\n            .ctx\n            .new_tuple(vec![obj.class().to_owned().into(), proto.clone()]);\n\n        if let Some(adapter) = adapters().get_item_opt(key.as_object(), vm)? {\n            return adapter.call((obj,), vm);\n        }\n        if let Ok(adapter) = proto.get_attr(\"__adapt__\", vm) {\n            match adapter.call((obj,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n        if let Ok(adapter) = obj.get_attr(\"__conform__\", vm) {\n            match adapter.call((proto,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n\n        alt(obj)\n    }\n\n    #[pyfunction]\n    fn adapt(\n        obj: PyObjectRef,\n        proto: OptionalArg<Option<PyTypeRef>>,\n        alt: OptionalArg<PyObjectRef>,\n        vm: &VirtualMachine,\n    ) -> PyResult {\n        if matches!(proto, OptionalArg::Present(None)) {\n            return if let OptionalArg::Present(alt) = alt {\n                Ok(alt)\n            } else {\n                Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n            };\n        }\n\n        let proto = proto\n            .flatten()\n            .unwrap_or_else(|| PrepareProtocol::class(&vm.ctx).to_owned());\n\n        _adapt(\n            &obj,\n            proto,\n            |_| {\n                if let OptionalArg::Present(alt) = alt {\n                    Ok(alt)\n                } else {\n                    Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n                }\n            },\n            vm,\n        )\n    }\n\n    fn need_adapt(obj: &PyObject, vm: &VirtualMachine) -> bool {\n        if BASE_TYPE_ADAPTED.get().is_some() {\n            true\n        } else {\n            let cls = obj.class();\n            !(cls.is(vm.ctx.types.int_type)\n                || cls.is(vm.ctx.types.float_type)\n                || cls.is(vm.ctx.types.str_type)\n                || cls.is(vm.ctx.types.bytearray_type))\n        }\n    }\n\n    static_cell! {\n        static CONVERTERS: PyDictRef;\n        static ADAPTERS: PyDictRef;\n        static BASE_TYPE_ADAPTED: ();\n        static USER_FUNCTION_EXCEPTION: PyAtomicRef<Option<PyBaseException>>;\n        static ENABLE_TRACEBACK: PyAtomic<bool>;\n    }\n\n    fn converters() -> &'static Py<PyDict> {\n        CONVERTERS.get().expect(\"converters not initialize\")\n    }\n\n    fn adapters() -> &'static Py<PyDict> {\n        ADAPTERS.get().expect(\"adapters not initialize\")\n    }\n\n    fn user_function_exception() -> &'static PyAtomicRef<Option<PyBaseException>> {\n        USER_FUNCTION_EXCEPTION\n            .get()\n            .expect(\"user function exception not initialize\")\n    }\n\n    fn enable_traceback() -> &'static PyAtomic<bool> {\n        ENABLE_TRACEBACK\n            .get()\n            .expect(\"enable traceback not initialize\")\n    }\n\n    pub(super) fn setup_module(module: &PyObject, vm: &VirtualMachine) {\n        for (name, code) in ERROR_CODES {\n            let name = vm.ctx.intern_str(*name);\n            let code = vm.new_pyobj(*code);\n            module.set_attr(name, code, vm).unwrap();\n        }\n\n        setup_module_exceptions(module, vm);\n\n        let _ = CONVERTERS.set(vm.ctx.new_dict());\n        let _ = ADAPTERS.set(vm.ctx.new_dict());\n        let _ = USER_FUNCTION_EXCEPTION.set(PyAtomicRef::from(None));\n        let _ = ENABLE_TRACEBACK.set(Radium::new(false));\n\n        module\n            .set_attr(\"converters\", converters().to_owned(), vm)\n            .unwrap();\n        module\n            .set_attr(\"adapters\", adapters().to_owned(), vm)\n            .unwrap();\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(PyPayload)]\n    struct Connection {\n        db: PyMutex<Option<Sqlite>>,\n        detect_types: PyAtomic<c_int>,\n        isolation_level: PyAtomicRef<Option<PyStr>>,\n        check_same_thread: PyAtomic<bool>,\n        thread_ident: PyMutex<ThreadId>,\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        text_factory: PyAtomicRef<PyObject>,\n    }\n\n    impl Debug for Connection {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"Sqlite3 Connection\")\n        }\n    }\n\n    impl Constructor for Connection {\n        type Args = ConnectArgs;\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n\n            // For non-subclassed Connection, initialize in __new__\n            // For subclassed Connection, leave db as None and require __init__ to be called\n            let is_base_class = cls.is(Connection::class(&vm.ctx).as_object());\n\n            let db = if is_base_class {\n                // Initialize immediately for base class\n                Some(Connection::initialize_db(&args, vm)?)\n            } else {\n                // For subclasses, require __init__ to be called\n                None\n            };\n\n            let conn = Self {\n                db: PyMutex::new(db),\n                detect_types: Radium::new(args.detect_types),\n                isolation_level: PyAtomicRef::from(args.isolation_level),\n                check_same_thread: Radium::new(args.check_same_thread),\n                thread_ident: PyMutex::new(std::thread::current().id()),\n                row_factory: PyAtomicRef::from(None),\n                text_factory: PyAtomicRef::from(text_factory),\n            };\n\n            Ok(conn.into_ref_with_type(vm, cls)?.into())\n        }\n    }\n\n    impl Callable for Connection {\n        type Args = FuncArgs;\n\n        fn call(zelf: &Py<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let _ = zelf.db_lock(vm)?;\n\n            let (sql,): (PyUtf8StrRef,) = args.bind(vm)?;\n\n            if let Some(stmt) = Statement::new(zelf, sql, vm)? {\n                Ok(stmt.into_ref(&vm.ctx).into())\n            } else {\n                Ok(vm.ctx.none())\n            }\n        }\n    }\n\n    impl Initializer for Connection {\n        type Args = ConnectArgs;\n\n        fn init(zelf: PyRef<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = zelf.db.lock();\n\n            {\n                // Always drop the current database handle so __init__ can fully reconfigure it.\n                let mut guard = zelf.db.lock();\n                guard.take();\n            }\n\n            // Reset factories to their defaults, matching CPython's behavior.\n            let default_text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n            let _ = unsafe { zelf.row_factory.swap(None) };\n            let _ = unsafe { zelf.text_factory.swap(default_text_factory) };\n\n            // Attempt to open the new database before mutating other state so failures leave\n            // the connection uninitialized (and subsequent operations raise ProgrammingError).\n            let db = Self::initialize_db(&args, vm)?;\n\n            let ConnectArgs {\n                detect_types,\n                isolation_level,\n                check_same_thread,\n                ..\n            } = args;\n\n            zelf.detect_types = detect_types;\n            zelf.check_same_thread = check_same_thread;\n            zelf.thread_ident = std::thread::current().id();\n            let _ = unsafe { zelf.isolation_level.swap(isolation_level) };\n\n            let mut guard = zelf.db.lock();\n            *guard = Some(db);\n            Ok(())\n        }\n    }\n\n    #[pyclass(with(Constructor, Callable, Initializer), flags(BASETYPE))]\n    impl Connection {\n        fn initialize_db(args: &ConnectArgs, vm: &VirtualMachine) -> PyResult<Sqlite> {\n            let path = args.database.to_cstring(vm)?;\n            let db = Sqlite::from(SqliteRaw::open(path.as_ptr(), args.uri, vm)?);\n            let timeout = (args.timeout * 1000.0) as c_int;\n            db.busy_timeout(timeout);\n            if let Some(isolation_level) = &args.isolation_level {\n                begin_statement_ptr_from_isolation_level(isolation_level, vm)?;\n            }\n            Ok(db)\n        }\n\n        fn db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            self.check_thread(vm)?;\n            self._db_lock(vm)\n        }\n\n        fn _db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            let guard = self.db.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Connection.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn cursor(\n            zelf: PyRef<Self>,\n            factory: OptionalArg<ArgCallable>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            zelf.db_lock(vm).map(drop)?;\n\n            let cursor = if let OptionalArg::Present(factory) = factory {\n                let cursor = factory.invoke((zelf.clone(),), vm)?;\n                let cursor = cursor.downcast::<Cursor>().map_err(|x| {\n                    vm.new_type_error(format!(\"factory must return a cursor, not {}\", x.class()))\n                })?;\n                let _ = unsafe { cursor.row_factory.swap(zelf.row_factory.to_owned()) };\n                cursor\n            } else {\n                let row_factory = zelf.row_factory.to_owned();\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx)\n            };\n            Ok(cursor)\n        }\n\n        #[pymethod]\n        fn blobopen(\n            zelf: PyRef<Self>,\n            args: BlobOpenArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Blob>> {\n            let table = args.table.to_cstring(vm)?;\n            let column = args.column.to_cstring(vm)?;\n            let name = args.name.to_cstring(vm)?;\n\n            let db = zelf.db_lock(vm)?;\n\n            let mut blob = null_mut();\n            let ret = unsafe {\n                sqlite3_blob_open(\n                    db.db,\n                    name.as_ptr(),\n                    table.as_ptr(),\n                    column.as_ptr(),\n                    args.row,\n                    (!args.readonly) as c_int,\n                    &mut blob,\n                )\n            };\n            db.check(ret, vm)?;\n            drop(db);\n\n            let blob = SqliteBlob { blob };\n            let blob = Blob {\n                connection: zelf,\n                inner: PyMutex::new(Some(BlobInner { blob, offset: 0 })),\n            };\n            Ok(blob.into_ref(&vm.ctx))\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.check_thread(vm)?;\n            self.db.lock().take();\n            Ok(())\n        }\n\n        #[pymethod]\n        fn commit(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.db_lock(vm)?.implicit_commit(vm)\n        }\n\n        #[pymethod]\n        fn rollback(&self, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            if !db.is_autocommit() {\n                db._exec(b\"ROLLBACK\\0\", vm)\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::execute(cursor, sql, parameters, vm)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::executemany(cursor, sql, seq_of_params, vm)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            Cursor::executescript(\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx),\n                script,\n                vm,\n            )\n        }\n\n        // TODO: Make it build without clippy::manual_c_str_literals\n        #[pymethod]\n        #[allow(clippy::manual_c_str_literals)]\n        fn backup(zelf: &Py<Self>, args: BackupArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let BackupArgs {\n                target,\n                pages,\n                progress,\n                name,\n                sleep,\n            } = args;\n            if zelf.is(&target) {\n                return Err(vm.new_value_error(\"target cannot be the same connection instance\"));\n            }\n\n            let pages = if pages == 0 { -1 } else { pages };\n\n            let name_cstring;\n            let name_ptr = if let Some(name) = &name {\n                name_cstring = name.to_cstring(vm)?;\n                name_cstring.as_ptr()\n            } else {\n                b\"main\\0\".as_ptr().cast()\n            };\n\n            let sleep_ms = (sleep * 1000.0) as c_int;\n\n            let db = zelf.db_lock(vm)?;\n            let target_db = target.db_lock(vm)?;\n\n            let handle = unsafe {\n                sqlite3_backup_init(target_db.db, b\"main\\0\".as_ptr().cast(), db.db, name_ptr)\n            };\n\n            if handle.is_null() {\n                return Err(target_db.error_extended(vm));\n            }\n\n            drop(db);\n            drop(target_db);\n\n            loop {\n                let ret = unsafe { sqlite3_backup_step(handle, pages) };\n\n                if let Some(progress) = &progress {\n                    let remaining = unsafe { sqlite3_backup_remaining(handle) };\n                    let pagecount = unsafe { sqlite3_backup_pagecount(handle) };\n                    if let Err(err) = progress.invoke((ret, remaining, pagecount), vm) {\n                        unsafe { sqlite3_backup_finish(handle) };\n                        return Err(err);\n                    }\n                }\n\n                if ret == SQLITE_BUSY || ret == SQLITE_LOCKED {\n                    unsafe { sqlite3_sleep(sleep_ms) };\n                } else if ret != SQLITE_OK {\n                    break;\n                }\n            }\n\n            let ret = unsafe { sqlite3_backup_finish(handle) };\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(target.db_lock(vm)?.error_extended(vm))\n            }\n        }\n\n        #[pymethod]\n        fn create_function(&self, args: CreateFunctionArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let flags = if args.deterministic {\n                SQLITE_UTF8 | SQLITE_DETERMINISTIC\n            } else {\n                SQLITE_UTF8\n            };\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.func, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    flags,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                flags,\n                Box::into_raw(Box::new(data)).cast(),\n                Some(CallbackData::func_callback),\n                None,\n                None,\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_aggregate(&self, args: CreateAggregateArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.aggregate_class, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    SQLITE_UTF8,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                SQLITE_UTF8,\n                Box::into_raw(Box::new(data)).cast(),\n                None,\n                Some(CallbackData::step_callback),\n                Some(CallbackData::finalize_callback),\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_collation(\n            &self,\n            name: PyUtf8StrRef,\n            callable: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable.clone(), vm) else {\n                unsafe {\n                    sqlite3_create_collation_v2(\n                        db.db,\n                        name.as_ptr(),\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                    );\n                }\n                return Ok(());\n            };\n            let data = Box::into_raw(Box::new(data));\n\n            if !callable.is_callable() {\n                return Err(vm.new_type_error(\"parameter must be callable\"));\n            }\n\n            let ret = unsafe {\n                sqlite3_create_collation_v2(\n                    db.db,\n                    name.as_ptr(),\n                    SQLITE_UTF8,\n                    data.cast(),\n                    Some(CallbackData::collation_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n\n            db.check(ret, vm).inspect_err(|_| {\n                // create_collation do not call destructor if error occur\n                let _ = unsafe { Box::from_raw(data) };\n            })\n        }\n\n        #[pymethod]\n        fn create_window_function(\n            &self,\n            name: PyStrRef,\n            narg: c_int,\n            aggregate_class: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(aggregate_class, vm) else {\n                unsafe {\n                    sqlite3_create_window_function(\n                        db.db,\n                        name.as_ptr(),\n                        narg,\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                        None,\n                        None,\n                        None,\n                    )\n                };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_create_window_function(\n                    db.db,\n                    name.as_ptr(),\n                    narg,\n                    SQLITE_UTF8,\n                    Box::into_raw(Box::new(data)).cast(),\n                    Some(CallbackData::step_callback),\n                    Some(CallbackData::finalize_callback),\n                    Some(CallbackData::value_callback),\n                    Some(CallbackData::inverse_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n            db.check(ret, vm)\n                .map_err(|_| new_programming_error(vm, \"Error creating window function\".to_owned()))\n        }\n\n        #[pymethod]\n        fn set_authorizer(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_set_authorizer(db.db, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_set_authorizer(\n                    db.db,\n                    Some(CallbackData::authorizer_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n            db.check(ret, vm).map_err(|_| {\n                new_operational_error(vm, \"Error setting authorizer callback\".to_owned())\n            })\n        }\n\n        #[pymethod]\n        fn set_trace_callback(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_trace_v2(db.db, SQLITE_TRACE_STMT as u32, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_trace_v2(\n                    db.db,\n                    SQLITE_TRACE_STMT as u32,\n                    Some(CallbackData::trace_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            db.check(ret, vm)\n        }\n\n        #[pymethod]\n        fn set_progress_handler(\n            &self,\n            callable: PyObjectRef,\n            n: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_progress_handler(db.db, n, None, null_mut()) };\n                return Ok(());\n            };\n\n            unsafe {\n                sqlite3_progress_handler(\n                    db.db,\n                    n,\n                    Some(CallbackData::progress_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            Ok(())\n        }\n\n        #[pymethod]\n        fn iterdump(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            let module = vm.import(\"sqlite3.dump\", 0)?;\n            let func = module.get_attr(\"_iterdump\", vm)?;\n            func.call((zelf,), vm)\n        }\n\n        #[pymethod]\n        fn interrupt(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // DO NOT check thread safety\n            self._db_lock(vm).map(|x| x.interrupt())\n        }\n\n        #[pymethod]\n        fn getlimit(&self, category: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, -1, vm)\n        }\n\n        #[pymethod]\n        fn setlimit(&self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, limit, vm)\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>) -> PyRef<Self> {\n            zelf\n        }\n\n        #[pymethod]\n        fn __exit__(\n            &self,\n            cls: PyObjectRef,\n            exc: PyObjectRef,\n            tb: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            if vm.is_none(&cls) && vm.is_none(&exc) && vm.is_none(&tb) {\n                self.commit(vm)\n            } else {\n                self.rollback(vm)\n            }\n        }\n\n        #[pygetset]\n        fn isolation_level(&self) -> Option<PyStrRef> {\n            self.isolation_level.deref().map(|x| x.to_owned())\n        }\n        #[pygetset(setter)]\n        fn set_isolation_level(\n            &self,\n            value: PySetterValue<Option<PyStrRef>>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            match value {\n                PySetterValue::Assign(value) => {\n                    if let Some(val_str) = &value {\n                        begin_statement_ptr_from_isolation_level(val_str, vm)?;\n                    }\n\n                    // If setting isolation_level to None (auto-commit mode), commit any pending transaction\n                    if value.is_none() {\n                        let db = self.db_lock(vm)?;\n                        if !db.is_autocommit() {\n                            // Keep the lock and call implicit_commit directly to avoid race conditions\n                            db.implicit_commit(vm)?;\n                        }\n                    }\n                    let _ = unsafe { self.isolation_level.swap(value) };\n                    Ok(())\n                }\n                PySetterValue::Delete => Err(vm.new_attribute_error(\n                    \"'isolation_level' attribute cannot be deleted\".to_owned(),\n                )),\n            }\n        }\n\n        #[pygetset]\n        fn text_factory(&self) -> PyObjectRef {\n            self.text_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_text_factory(&self, val: PyObjectRef) {\n            let _ = unsafe { self.text_factory.swap(val) };\n        }\n\n        #[pygetset]\n        fn row_factory(&self) -> Option<PyObjectRef> {\n            self.row_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_row_factory(&self, val: Option<PyObjectRef>) {\n            let _ = unsafe { self.row_factory.swap(val) };\n        }\n\n        fn check_thread(&self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.check_same_thread && (std::thread::current().id() != self.thread_ident) {\n                Err(new_programming_error(\n                    vm,\n                    \"SQLite objects created in a thread can only be used in that same thread.\"\n                        .to_owned(),\n                ))\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pygetset]\n        fn in_transaction(&self, vm: &VirtualMachine) -> PyResult<bool> {\n            self._db_lock(vm).map(|x| !x.is_autocommit())\n        }\n\n        #[pygetset]\n        fn total_changes(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self._db_lock(vm).map(|x| x.total_changes())\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Cursor {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        arraysize: PyAtomic<c_int>,\n        #[pytraverse(skip)]\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        inner: PyMutex<Option<CursorInner>>,\n    }\n\n    #[derive(Debug, Traverse)]\n    struct CursorInner {\n        description: Option<PyTupleRef>,\n        row_cast_map: Vec<Option<PyObjectRef>>,\n        #[pytraverse(skip)]\n        lastrowid: i64,\n        #[pytraverse(skip)]\n        rowcount: i64,\n        statement: Option<PyRef<Statement>>,\n        #[pytraverse(skip)]\n        closed: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct FetchManyArgs {\n        #[pyarg(any, name = \"size\", optional)]\n        size: Option<c_int>,\n    }\n\n    #[pyclass(with(Constructor, IterNext, Iterable), flags(BASETYPE))]\n    impl Cursor {\n        fn new(\n            connection: PyRef<Connection>,\n            row_factory: Option<PyObjectRef>,\n            _vm: &VirtualMachine,\n        ) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(row_factory),\n                inner: PyMutex::from(Some(CursorInner {\n                    description: None,\n                    row_cast_map: vec![],\n                    lastrowid: -1,\n                    rowcount: -1,\n                    statement: None,\n                    closed: false,\n                })),\n            }\n        }\n\n        fn new_uninitialized(connection: PyRef<Connection>, _vm: &VirtualMachine) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(None),\n                inner: PyMutex::from(None),\n            }\n        }\n\n        #[pymethod]\n        fn __init__(&self, _connection: PyRef<Connection>, _vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = self.inner.lock();\n            if guard.is_some() {\n                // Already initialized (e.g., from a call to super().__init__)\n                return Ok(());\n            }\n            *guard = Some(CursorInner {\n                description: None,\n                row_cast_map: vec![],\n                lastrowid: -1,\n                rowcount: -1,\n                statement: None,\n                closed: false,\n            });\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, CursorInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                let inner_guard =\n                    PyMutexGuard::map(guard, |x| unsafe { x.as_mut().unwrap_unchecked() });\n                if inner_guard.closed {\n                    return Err(new_programming_error(\n                        vm,\n                        \"Cannot operate on a closed cursor.\".to_owned(),\n                    ));\n                }\n                Ok(inner_guard)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let st = stmt.lock();\n            let params_needed = st.bind_parameter_count();\n\n            if let OptionalArg::Present(parameters) = parameters {\n                st.bind_parameters(&parameters, vm)?;\n            } else if params_needed > 0 {\n                let msg = format!(\n                    \"Incorrect number of bindings supplied. The current statement uses {}, and 0 were supplied.\",\n                    params_needed\n                );\n                return Err(new_programming_error(vm, msg));\n            }\n\n            let ret = st.step();\n\n            if ret != SQLITE_DONE && ret != SQLITE_ROW {\n                if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                    return Err(exc);\n                }\n                return Err(db.error_extended(vm));\n            }\n\n            inner.row_cast_map = zelf.build_row_cast_map(&st, vm)?;\n\n            inner.description = st.columns_description(zelf.connection.detect_types, vm)?;\n\n            if ret == SQLITE_ROW {\n                drop(st);\n                inner.statement = Some(stmt);\n            } else {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount += db.changes() as i64;\n                }\n            }\n\n            inner.lastrowid = db.lastrowid();\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            let st = stmt.lock();\n\n            if st.readonly() {\n                return Err(new_programming_error(\n                    vm,\n                    \"executemany() can only execute DML statements.\".to_owned(),\n                ));\n            }\n\n            inner.description = st.columns_description(zelf.connection.detect_types, vm)?;\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let iter = seq_of_params.iter(vm)?;\n            for params in iter {\n                let params = params?;\n                st.bind_parameters(&params, vm)?;\n\n                if !st.step_row_else_done(vm)? {\n                    if stmt.is_dml {\n                        inner.rowcount += db.changes() as i64;\n                    }\n                    st.reset();\n                }\n\n                // if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                //     return Err(exc);\n                // }\n            }\n\n            if st.busy() {\n                drop(st);\n                inner.statement = Some(stmt);\n            }\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let db = zelf.connection.db_lock(vm)?;\n\n            db.sql_limit(script.byte_len(), vm)?;\n\n            db.implicit_commit(vm)?;\n\n            let script = script.to_cstring(vm)?;\n            let mut ptr = script.as_ptr();\n\n            while let Some(st) = db.prepare(ptr, &mut ptr, vm)? {\n                while st.step_row_else_done(vm)? {}\n            }\n\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn fetchone(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult {\n            Self::next(zelf, vm).map(|x| match x {\n                PyIterReturn::Return(row) => row,\n                PyIterReturn::StopIteration(_) => vm.ctx.none(),\n            })\n        }\n\n        #[pymethod]\n        fn fetchmany(\n            zelf: &Py<Self>,\n            args: FetchManyArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<PyObjectRef>> {\n            let max_rows = args\n                .size\n                .unwrap_or_else(|| zelf.arraysize.load(Ordering::Relaxed));\n\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Cursor::next(zelf, vm)? {\n                list.push(row);\n                if max_rows > 0 && list.len() as c_int >= max_rows {\n                    break;\n                }\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn fetchall(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Self::next(zelf, vm)? {\n                list.push(row);\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // Check if __init__ was called\n            let mut guard = self.inner.lock();\n            if guard.is_none() {\n                return Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ));\n            }\n\n            if let Some(inner) = guard.as_mut() {\n                if let Some(stmt) = &inner.statement {\n                    stmt.lock().reset();\n                }\n                inner.closed = true;\n            }\n            Ok(())\n        }\n\n        #[pymethod]\n        fn setinputsizes(&self, _sizes: PyObjectRef) {}\n        #[pymethod]\n        fn setoutputsize(&self, _size: PyObjectRef, _column: OptionalArg<PyObjectRef>) {}\n\n        #[pygetset]\n        fn connection(&self) -> PyRef<Connection> {\n            self.connection.clone()\n        }\n\n        #[pygetset]\n        fn lastrowid(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.lastrowid)\n        }\n\n        #[pygetset]\n        fn rowcount(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.rowcount)\n        }\n\n        #[pygetset]\n        fn description(&self, vm: &VirtualMachine) -> PyResult<Option<PyTupleRef>> {\n            self.inner(vm).map(|x| x.description.clone())\n        }\n\n        #[pygetset]\n        fn arraysize(&self) -> c_int {\n            self.arraysize.load(Ordering::Relaxed)\n        }\n        #[pygetset(setter)]\n        fn set_arraysize(&self, val: c_int) {\n            self.arraysize.store(val, Ordering::Relaxed);\n        }\n\n        fn build_row_cast_map(\n            &self,\n            st: &SqliteStatementRaw,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<Option<PyObjectRef>>> {\n            if self.connection.detect_types == 0 {\n                return Ok(vec![]);\n            }\n\n            let mut cast_map = vec![];\n            let num_cols = st.column_count();\n\n            for i in 0..num_cols {\n                if self.connection.detect_types & PARSE_COLNAMES != 0 {\n                    let col_name = st.column_name(i);\n                    let col_name = ptr_to_str(col_name, vm)?;\n                    let col_name = col_name\n                        .chars()\n                        .skip_while(|&x| x != '[')\n                        .skip(1)\n                        .take_while(|&x| x != ']')\n                        .flat_map(|x| x.to_uppercase())\n                        .collect::<String>();\n                    if let Some(converter) = converters().get_item_opt(&col_name, vm)? {\n                        cast_map.push(Some(converter.clone()));\n                        continue;\n                    }\n                }\n                if self.connection.detect_types & PARSE_DECLTYPES != 0 {\n                    let decltype = st.column_decltype(i);\n                    let decltype = ptr_to_str(decltype, vm)?;\n                    if let Some(decltype) = decltype.split_terminator(&[' ', '(']).next() {\n                        let decltype = decltype.to_uppercase();\n                        if let Some(converter) = converters().get_item_opt(&decltype, vm)? {\n                            cast_map.push(Some(converter.clone()));\n                            continue;\n                        }\n                    }\n                }\n                cast_map.push(None);\n            }\n\n            Ok(cast_map)\n        }\n    }\n\n    impl Constructor for Cursor {\n        type Args = (PyRef<Connection>,);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            Self::new_uninitialized(args.0, vm)\n                .into_ref_with_type(vm, cls)\n                .map(Into::into)\n        }\n    }\n\n    impl SelfIter for Cursor {}\n    impl IterNext for Cursor {\n        fn next(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyIterReturn> {\n            let mut inner = zelf.inner(vm)?;\n            let Some(stmt) = &inner.statement else {\n                return Ok(PyIterReturn::StopIteration(None));\n            };\n            let st = stmt.lock();\n            let db = zelf.connection.db_lock(vm)?;\n            // fetch_one_row\n\n            let num_cols = st.data_count();\n\n            let mut row = Vec::with_capacity(num_cols as usize);\n\n            for i in 0..num_cols {\n                let val = if let Some(converter) =\n                    inner.row_cast_map.get(i as usize).cloned().flatten()\n                {\n                    let blob = st.column_blob(i);\n                    if blob.is_null() {\n                        vm.ctx.none()\n                    } else {\n                        let nbytes = st.column_bytes(i);\n                        let blob = unsafe {\n                            std::slice::from_raw_parts(blob.cast::<u8>(), nbytes as usize)\n                        };\n                        let blob = vm.ctx.new_bytes(blob.to_vec());\n                        converter.call((blob,), vm)?\n                    }\n                } else {\n                    let col_type = st.column_type(i);\n                    match col_type {\n                        SQLITE_NULL => vm.ctx.none(),\n                        SQLITE_INTEGER => vm.ctx.new_int(st.column_int(i)).into(),\n                        SQLITE_FLOAT => vm.ctx.new_float(st.column_double(i)).into(),\n                        SQLITE_TEXT => {\n                            let text =\n                                ptr_to_vec(st.column_text(i), st.column_bytes(i), db.db, vm)?;\n\n                            let text_factory = zelf.connection.text_factory.to_owned();\n\n                            if text_factory.is(PyStr::class(&vm.ctx)) {\n                                let text = String::from_utf8(text).map_err(|err| {\n                                    let col_name = st.column_name(i);\n                                    let col_name_str = ptr_to_str(col_name, vm).unwrap_or(\"?\");\n                                    let valid_up_to = err.utf8_error().valid_up_to();\n                                    let text_prefix = String::from_utf8_lossy(&err.as_bytes()[..valid_up_to]);\n                                    let msg = format!(\n                                        \"Could not decode to UTF-8 column '{col_name_str}' with text '{text_prefix}'\"\n                                    );\n                                    new_operational_error(vm, msg)\n                                })?;\n                                vm.ctx.new_str(text).into()\n                            } else if text_factory.is(PyBytes::class(&vm.ctx)) {\n                                vm.ctx.new_bytes(text).into()\n                            } else if text_factory.is(PyByteArray::class(&vm.ctx)) {\n                                PyByteArray::from(text).into_ref(&vm.ctx).into()\n                            } else {\n                                let bytes = vm.ctx.new_bytes(text);\n                                text_factory.call((bytes,), vm)?\n                            }\n                        }\n                        SQLITE_BLOB => {\n                            let blob = ptr_to_vec(\n                                st.column_blob(i).cast(),\n                                st.column_bytes(i),\n                                db.db,\n                                vm,\n                            )?;\n\n                            vm.ctx.new_bytes(blob).into()\n                        }\n                        _ => {\n                            return Err(vm.new_not_implemented_error(format!(\n                                \"unknown column type: {col_type}\"\n                            )));\n                        }\n                    }\n                };\n\n                row.push(val);\n            }\n\n            if !st.step_row_else_done(vm)? {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount = db.changes() as i64;\n                }\n                inner.statement = None;\n            } else {\n                drop(st);\n            }\n\n            drop(db);\n            drop(inner);\n\n            let row = vm.ctx.new_tuple(row);\n\n            if let Some(row_factory) = zelf.row_factory.to_owned() {\n                row_factory\n                    .call((zelf.to_owned(), row), vm)\n                    .map(PyIterReturn::Return)\n            } else {\n                Ok(PyIterReturn::Return(row.into()))\n            }\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Row {\n        data: PyTupleRef,\n        description: PyTupleRef,\n    }\n\n    #[pyclass(\n        with(Constructor, Hashable, Comparable, Iterable, AsMapping, AsSequence),\n        flags(BASETYPE)\n    )]\n    impl Row {\n        #[pymethod]\n        fn keys(&self, _vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            Ok(self\n                .description\n                .iter()\n                .map(|x| x.downcast_ref::<PyTuple>().unwrap().as_slice()[0].clone())\n                .collect())\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            if let Some(i) = needle.downcast_ref::<PyInt>() {\n                let i = i.try_to_primitive::<isize>(vm)?;\n                self.data.getitem_by_index(vm, i)\n            } else if let Some(name) = needle.downcast_ref::<PyStr>() {\n                for (obj, i) in self.description.iter().zip(0..) {\n                    let obj = &obj.downcast_ref::<PyTuple>().unwrap().as_slice()[0];\n                    let Some(obj) = obj.downcast_ref::<PyStr>() else {\n                        break;\n                    };\n                    let a_iter = name.as_str().chars().flat_map(|x| x.to_uppercase());\n                    let b_iter = obj.as_str().chars().flat_map(|x| x.to_uppercase());\n\n                    if a_iter.eq(b_iter) {\n                        return self.data.getitem_by_index(vm, i);\n                    }\n                }\n                Err(vm.new_index_error(\"No item with that key\"))\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let list = self.data.getitem_by_slice(vm, slice.to_saturated(vm)?)?;\n                Ok(vm.ctx.new_tuple(list).into())\n            } else {\n                Err(vm.new_index_error(\"Index must be int or string\"))\n            }\n        }\n    }\n\n    impl Constructor for Row {\n        type Args = (PyRef<Cursor>, PyTupleRef);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let description = args\n                .0\n                .inner(vm)?\n                .description\n                .clone()\n                .ok_or_else(|| vm.new_value_error(\"no description in Cursor\"))?;\n\n            Self {\n                data: args.1,\n                description,\n            }\n            .into_ref_with_type(vm, cls)\n            .map(Into::into)\n        }\n    }\n\n    impl Hashable for Row {\n        fn hash(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyHash> {\n            Ok(zelf.description.as_object().hash(vm)? | zelf.data.as_object().hash(vm)?)\n        }\n    }\n\n    impl Comparable for Row {\n        fn cmp(\n            zelf: &Py<Self>,\n            other: &PyObject,\n            op: PyComparisonOp,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyComparisonValue> {\n            op.eq_only(|| {\n                if let Some(other) = other.downcast_ref::<Self>() {\n                    let eq = vm\n                        .bool_eq(zelf.description.as_object(), other.description.as_object())?\n                        && vm.bool_eq(zelf.data.as_object(), other.data.as_object())?;\n                    Ok(eq.into())\n                } else {\n                    Ok(PyComparisonValue::NotImplemented)\n                }\n            })\n        }\n    }\n\n    impl Iterable for Row {\n        fn iter(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            Iterable::iter(zelf.data.clone(), vm)\n        }\n    }\n\n    impl AsMapping for Row {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: std::sync::LazyLock<PyMappingMethods> =\n                std::sync::LazyLock::new(|| PyMappingMethods {\n                    length: atomic_func!(|mapping, _vm| Ok(Row::mapping_downcast(mapping)\n                        .data\n                        .len())),\n                    subscript: atomic_func!(|mapping, needle, vm| {\n                        Row::mapping_downcast(mapping).subscript(needle, vm)\n                    }),\n                    ..PyMappingMethods::NOT_IMPLEMENTED\n                });\n            &AS_MAPPING\n        }\n    }\n\n    impl AsSequence for Row {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: std::sync::LazyLock<PySequenceMethods> =\n                std::sync::LazyLock::new(|| PySequenceMethods {\n                    length: atomic_func!(|seq, _vm| Ok(Row::sequence_downcast(seq).data.len())),\n                    item: atomic_func!(|seq, i, vm| Row::sequence_downcast(seq)\n                        .data\n                        .getitem_by_index(vm, i)),\n                    ..PySequenceMethods::NOT_IMPLEMENTED\n                });\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Blob\", traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Blob {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        inner: PyMutex<Option<BlobInner>>,\n    }\n\n    impl Unconstructible for Blob {}\n\n    #[derive(Debug)]\n    struct BlobInner {\n        blob: SqliteBlob,\n        offset: c_int,\n    }\n\n    impl Drop for BlobInner {\n        fn drop(&mut self) {\n            unsafe { sqlite3_blob_close(self.blob.blob) };\n        }\n    }\n\n    #[pyclass(with(AsMapping, Unconstructible, AsNumber, AsSequence))]\n    impl Blob {\n        #[pymethod]\n        fn close(&self) {\n            self.inner.lock().take();\n        }\n\n        #[pymethod]\n        fn read(\n            &self,\n            length: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<PyBytes>> {\n            let mut length = length.unwrap_or(-1);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let max_read = blob_len - inner.offset;\n\n            if length < 0 || length > max_read {\n                length = max_read;\n            }\n\n            if length == 0 {\n                Ok(vm.ctx.empty_bytes.clone())\n            } else {\n                let mut buf = Vec::<u8>::with_capacity(length as usize);\n                let ret = inner\n                    .blob\n                    .read(buf.as_mut_ptr().cast(), length, inner.offset);\n                self.check(ret, vm)?;\n                unsafe { buf.set_len(length as usize) };\n                inner.offset += length;\n                Ok(vm.ctx.new_bytes(buf))\n            }\n        }\n\n        #[pymethod]\n        fn write(&self, data: PyBuffer, vm: &VirtualMachine) -> PyResult<()> {\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let length = Self::expect_write(blob_len, data.desc.len, inner.offset, vm)?;\n\n            let ret = data.contiguous_or_collect(|buf| {\n                inner.blob.write(buf.as_ptr().cast(), length, inner.offset)\n            });\n\n            self.check(ret, vm)?;\n            inner.offset += length;\n            Ok(())\n        }\n\n        #[pymethod]\n        fn tell(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.inner(vm).map(|x| x.offset)\n        }\n\n        #[pymethod]\n        fn seek(\n            &self,\n            mut offset: c_int,\n            origin: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let origin = origin.unwrap_or(libc::SEEK_SET);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n\n            let overflow_err = || vm.new_overflow_error(\"seek offset results in overflow\");\n\n            match origin {\n                libc::SEEK_SET => {}\n                libc::SEEK_CUR => {\n                    offset = offset.checked_add(inner.offset).ok_or_else(overflow_err)?\n                }\n                libc::SEEK_END => offset = offset.checked_add(blob_len).ok_or_else(overflow_err)?,\n                _ => {\n                    return Err(vm.new_value_error(\n                        \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\",\n                    ));\n                }\n            }\n\n            if offset < 0 || offset > blob_len {\n                Err(vm.new_value_error(\"offset out of blob range\"))\n            } else {\n                inner.offset = offset;\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult<PyRef<Self>> {\n            let _ = zelf.inner(vm)?;\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn __exit__(&self, _args: FuncArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let _ = self.inner(vm)?;\n            self.close();\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, BlobInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Cannot operate on a closed blob.\".to_owned(),\n                ))\n            }\n        }\n\n        fn wrapped_index(index: PyIntRef, length: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let mut index = index.try_to_primitive::<c_int>(vm)?;\n            if index < 0 {\n                index += length;\n            }\n            if index < 0 || index >= length {\n                Err(vm.new_index_error(\"Blob index out of range\"))\n            } else {\n                Ok(index)\n            }\n        }\n\n        fn expect_write(\n            blob_len: c_int,\n            length: usize,\n            offset: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<c_int> {\n            let max_write = blob_len - offset;\n            if length <= max_write as usize {\n                Ok(length as c_int)\n            } else {\n                Err(vm.new_value_error(\"data longer than blob length\"))\n            }\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            let inner = self.inner(vm)?;\n            if let Some(index) = needle.try_index_opt(vm) {\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                let mut byte: u8 = 0;\n                let ret = inner.blob.read_single(&mut byte, index);\n                self.check(ret, vm).map(|_| vm.ctx.new_int(byte).into())\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, length) = slice.adjust_indices(blob_len as usize);\n                let mut buf = Vec::<u8>::with_capacity(length);\n\n                if step == 1 {\n                    let ret = inner.blob.read(\n                        buf.as_mut_ptr().cast(),\n                        length as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n                    unsafe { buf.set_len(length) };\n                } else {\n                    let iter = SaturatedSliceIter::from_adjust_indices(range, step, length);\n                    let mut byte: u8 = 0;\n                    for index in iter {\n                        let ret = inner.blob.read_single(&mut byte, index as c_int);\n                        self.check(ret, vm)?;\n                        buf.push(byte);\n                    }\n                }\n                Ok(vm.ctx.new_bytes(buf).into())\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn ass_subscript(\n            &self,\n            needle: &PyObject,\n            value: Option<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(value) = value else {\n                return Err(vm.new_type_error(\"Blob doesn't support slice deletion\"));\n            };\n            let inner = self.inner(vm)?;\n\n            if let Some(index) = needle.try_index_opt(vm) {\n                // Handle single item assignment: blob[i] = b\n                let Some(value) = value.downcast_ref::<PyInt>() else {\n                    return Err(vm.new_type_error(format!(\n                        \"'{}' object cannot be interpreted as an integer\",\n                        value.class()\n                    )));\n                };\n                let value = value.try_to_primitive::<u8>(vm)?;\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                Self::expect_write(blob_len, 1, index, vm)?;\n                let ret = inner.blob.write_single(value, index);\n                self.check(ret, vm)\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                // Handle slice assignment: blob[a:b:c] = b\"...\"\n                let value_buf = PyBuffer::try_from_borrowed_object(vm, &value)?;\n\n                let buf = value_buf\n                    .as_contiguous()\n                    .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, slice_len) = slice.adjust_indices(blob_len as usize);\n\n                if step == 0 {\n                    return Err(vm.new_value_error(\"slice step cannot be zero\"));\n                }\n\n                if buf.len() != slice_len {\n                    return Err(vm.new_index_error(\"Blob slice assignment is wrong size\"));\n                }\n\n                if slice_len == 0 {\n                    return Ok(());\n                }\n\n                if step == 1 {\n                    let ret = inner.blob.write(\n                        buf.as_ptr().cast(),\n                        buf.len() as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                } else {\n                    let span_len = range.end - range.start;\n                    let mut temp_buf = vec![0u8; span_len];\n\n                    let ret = inner.blob.read(\n                        temp_buf.as_mut_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n\n                    let mut i_in_temp: usize = 0;\n                    for i_in_src in 0..slice_len {\n                        temp_buf[i_in_temp] = buf[i_in_src];\n                        i_in_temp += step as usize;\n                    }\n\n                    let ret = inner.blob.write(\n                        temp_buf.as_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                }\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn check(&self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.connection.db_lock(vm)?.error_extended(vm))\n            }\n        }\n    }\n\n    impl AsMapping for Blob {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: PyMappingMethods = PyMappingMethods {\n                length: atomic_func!(|mapping, vm| Blob::mapping_downcast(mapping)\n                    .inner(vm)\n                    .map(|x| x.blob.bytes() as usize)),\n                subscript: atomic_func!(|mapping, needle, vm| {\n                    Blob::mapping_downcast(mapping).subscript(needle, vm)\n                }),\n                ass_subscript: atomic_func!(|mapping, needle, value, vm| {\n                    Blob::mapping_downcast(mapping).ass_subscript(needle, value, vm)\n                }),\n            };\n            &AS_MAPPING\n        }\n    }\n\n    impl AsNumber for Blob {\n        fn as_number() -> &'static PyNumberMethods {\n            static AS_NUMBER: PyNumberMethods = PyNumberMethods {\n                add: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for +: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                multiply: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for *: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                ..PyNumberMethods::NOT_IMPLEMENTED\n            };\n            &AS_NUMBER\n        }\n    }\n\n    impl AsSequence for Blob {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: PySequenceMethods = PySequenceMethods {\n                length: AtomicCell::new(None),\n                concat: AtomicCell::new(None),\n                repeat: AtomicCell::new(None),\n                item: AtomicCell::new(None),\n                ass_item: AtomicCell::new(None),\n                contains: atomic_func!(|seq, _needle, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"argument of type '{}' is not iterable\",\n                        seq.obj.class().name(),\n                    )))\n                }),\n                inplace_concat: AtomicCell::new(None),\n                inplace_repeat: AtomicCell::new(None),\n            };\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(Debug, PyPayload)]\n    struct PrepareProtocol {}\n\n    #[pyclass()]\n    impl PrepareProtocol {}\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Statement\")]\n    #[derive(PyPayload)]\n    struct Statement {\n        st: PyMutex<SqliteStatement>,\n        pub is_dml: bool,\n    }\n\n    impl Debug for Statement {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(\n                f,\n                \"{} Statement\",\n                if self.is_dml { \"DML\" } else { \"Non-DML\" }\n            )\n        }\n    }\n\n    impl Unconstructible for Statement {}\n\n    #[pyclass(with(Unconstructible))]\n    impl Statement {\n        fn new(\n            connection: &Connection,\n            sql: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<Self>> {\n            if sql.as_str().contains('\\0') {\n                return Err(new_programming_error(\n                    vm,\n                    \"statement contains a null character.\".to_owned(),\n                ));\n            }\n            let sql_cstr = sql.to_cstring(vm)?;\n\n            let db = connection.db_lock(vm)?;\n\n            db.sql_limit(sql.byte_len(), vm)?;\n\n            let mut tail = null();\n            let st = db.prepare(sql_cstr.as_ptr(), &mut tail, vm)?;\n\n            let Some(st) = st else {\n                return Ok(None);\n            };\n\n            let tail = unsafe { CStr::from_ptr(tail) };\n            let tail = tail.to_bytes();\n            if lstrip_sql(tail).is_some() {\n                return Err(new_programming_error(\n                    vm,\n                    \"You can only execute one statement at a time.\".to_owned(),\n                ));\n            }\n\n            let is_dml = if let Some(head) = lstrip_sql(sql_cstr.as_bytes()) {\n                head.len() >= 6\n                    && (head[..6].eq_ignore_ascii_case(b\"insert\")\n                        || head[..6].eq_ignore_ascii_case(b\"update\")\n                        || head[..6].eq_ignore_ascii_case(b\"delete\")\n                        || (head.len() >= 7 && head[..7].eq_ignore_ascii_case(b\"replace\")))\n            } else {\n                false\n            };\n\n            Ok(Some(Self {\n                st: PyMutex::from(st),\n                is_dml,\n            }))\n        }\n\n        fn lock(&self) -> PyMutexGuard<'_, SqliteStatement> {\n            self.st.lock()\n        }\n    }\n\n    struct Sqlite {\n        raw: SqliteRaw,\n    }\n\n    impl From<SqliteRaw> for Sqlite {\n        fn from(raw: SqliteRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for Sqlite {\n        fn drop(&mut self) {\n            unsafe { sqlite3_close_v2(self.raw.db) };\n        }\n    }\n\n    impl Deref for Sqlite {\n        type Target = SqliteRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteRaw {\n        db: *mut sqlite3,\n    }\n\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"threading\")] {\n            unsafe impl Send for SqliteStatement {}\n            // unsafe impl Sync for SqliteStatement {}\n            unsafe impl Send for Sqlite {}\n            // unsafe impl Sync for Sqlite {}\n            unsafe impl Send for SqliteBlob {}\n        }\n    }\n\n    impl From<SqliteStatementRaw> for SqliteRaw {\n        fn from(stmt: SqliteStatementRaw) -> Self {\n            unsafe {\n                Self {\n                    db: sqlite3_db_handle(stmt.st),\n                }\n            }\n        }\n    }\n\n    impl SqliteRaw {\n        fn check(self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.error_extended(vm))\n            }\n        }\n\n        fn error_extended(self, vm: &VirtualMachine) -> PyBaseExceptionRef {\n            let errcode = unsafe { sqlite3_errcode(self.db) };\n            let typ = exception_type_from_errcode(errcode, vm);\n            let extended_errcode = unsafe { sqlite3_extended_errcode(self.db) };\n            let errmsg = unsafe { sqlite3_errmsg(self.db) };\n            let errmsg = unsafe { CStr::from_ptr(errmsg) };\n            let errmsg = errmsg.to_str().unwrap().to_owned();\n\n            raise_exception(typ.to_owned(), extended_errcode, errmsg, vm)\n        }\n\n        fn open(path: *const libc::c_char, uri: bool, vm: &VirtualMachine) -> PyResult<Self> {\n            let mut db = null_mut();\n            let ret = unsafe {\n                sqlite3_open_v2(\n                    path,\n                    &raw mut db,\n                    SQLITE_OPEN_READWRITE\n                        | SQLITE_OPEN_CREATE\n                        | if uri { SQLITE_OPEN_URI } else { 0 },\n                    null(),\n                )\n            };\n            let zelf = Self { db };\n            zelf.check(ret, vm).map(|_| zelf)\n        }\n\n        fn _exec(self, sql: &[u8], vm: &VirtualMachine) -> PyResult<()> {\n            let ret =\n                unsafe { sqlite3_exec(self.db, sql.as_ptr().cast(), None, null_mut(), null_mut()) };\n            self.check(ret, vm)\n        }\n\n        fn prepare(\n            self,\n            sql: *const libc::c_char,\n            tail: *mut *const libc::c_char,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<SqliteStatement>> {\n            let mut st = null_mut();\n            let ret = unsafe { sqlite3_prepare_v2(self.db, sql, -1, &mut st, tail) };\n            self.check(ret, vm)?;\n            if st.is_null() {\n                Ok(None)\n            } else {\n                Ok(Some(SqliteStatement::from(SqliteStatementRaw::from(st))))\n            }\n        }\n\n        fn limit(self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let old_limit = unsafe { sqlite3_limit(self.db, category, limit) };\n            if old_limit >= 0 {\n                Ok(old_limit)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"'category' is out of bounds\".to_owned(),\n                ))\n            }\n        }\n\n        fn sql_limit(self, len: usize, vm: &VirtualMachine) -> PyResult<()> {\n            if len <= unsafe { sqlite3_limit(self.db, SQLITE_LIMIT_SQL_LENGTH, -1) } as usize {\n                Ok(())\n            } else {\n                Err(new_data_error(vm, \"query string is too large\".to_owned()))\n            }\n        }\n\n        fn is_autocommit(self) -> bool {\n            unsafe { sqlite3_get_autocommit(self.db) != 0 }\n        }\n\n        fn changes(self) -> c_int {\n            unsafe { sqlite3_changes(self.db) }\n        }\n\n        fn total_changes(self) -> c_int {\n            unsafe { sqlite3_total_changes(self.db) }\n        }\n\n        fn lastrowid(self) -> c_longlong {\n            unsafe { sqlite3_last_insert_rowid(self.db) }\n        }\n\n        fn implicit_commit(self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.is_autocommit() {\n                Ok(())\n            } else {\n                self._exec(b\"COMMIT\\0\", vm)\n            }\n        }\n\n        fn begin_transaction(\n            self,\n            isolation_level: Option<PyStrRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(isolation_level) = isolation_level else {\n                return Ok(());\n            };\n            let mut s = Vec::with_capacity(16);\n            s.extend(b\"BEGIN \");\n            s.extend(isolation_level.as_str().bytes());\n            s.push(b'\\0');\n            self._exec(&s, vm)\n        }\n\n        fn interrupt(self) {\n            unsafe { sqlite3_interrupt(self.db) }\n        }\n\n        fn busy_timeout(self, timeout: i32) {\n            unsafe { sqlite3_busy_timeout(self.db, timeout) };\n        }\n\n        #[allow(clippy::too_many_arguments)]\n        fn create_function(\n            self,\n            name: *const libc::c_char,\n            narg: c_int,\n            flags: c_int,\n            data: *mut c_void,\n            func: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            step: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            finalize: Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n            destroy: Option<unsafe extern \"C\" fn(arg1: *mut c_void)>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let ret = unsafe {\n                sqlite3_create_function_v2(\n                    self.db, name, narg, flags, data, func, step, finalize, destroy,\n                )\n            };\n            self.check(ret, vm)\n                .map_err(|_| new_operational_error(vm, \"Error creating function\".to_owned()))\n        }\n    }\n\n    struct SqliteStatement {\n        raw: SqliteStatementRaw,\n    }\n\n    impl From<SqliteStatementRaw> for SqliteStatement {\n        fn from(raw: SqliteStatementRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for SqliteStatement {\n        fn drop(&mut self) {\n            unsafe {\n                sqlite3_finalize(self.raw.st);\n            }\n        }\n    }\n\n    impl Deref for SqliteStatement {\n        type Target = SqliteStatementRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteStatementRaw {\n        st: *mut sqlite3_stmt,\n    }\n\n    impl From<*mut sqlite3_stmt> for SqliteStatementRaw {\n        fn from(st: *mut sqlite3_stmt) -> Self {\n            SqliteStatementRaw { st }\n        }\n    }\n\n    impl SqliteStatementRaw {\n        fn step(self) -> c_int {\n            unsafe { sqlite3_step(self.st) }\n        }\n\n        fn step_row_else_done(self, vm: &VirtualMachine) -> PyResult<bool> {\n            let ret = self.step();\n\n            if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                Err(exc)\n            } else if ret == SQLITE_ROW {\n                Ok(true)\n            } else if ret == SQLITE_DONE {\n                Ok(false)\n            } else {\n                Err(SqliteRaw::from(self).error_extended(vm))\n            }\n        }\n\n        fn reset(self) {\n            unsafe { sqlite3_reset(self.st) };\n        }\n\n        fn data_count(self) -> c_int {\n            unsafe { sqlite3_data_count(self.st) }\n        }\n\n        fn bind_parameter(\n            self,\n            pos: c_int,\n            parameter: &PyObject,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let adapted;\n            let obj = if need_adapt(parameter, vm) {\n                adapted = _adapt(\n                    parameter,\n                    PrepareProtocol::class(&vm.ctx).to_owned(),\n                    |x| Ok(x.to_owned()),\n                    vm,\n                )?;\n                &adapted\n            } else {\n                parameter\n            };\n\n            let ret = if vm.is_none(obj) {\n                unsafe { sqlite3_bind_null(self.st, pos) }\n            } else if let Some(val) = obj.downcast_ref::<PyInt>() {\n                let val = val.try_to_primitive::<i64>(vm).map_err(|_| {\n                    vm.new_overflow_error(\"Python int too large to convert to SQLite INTEGER\")\n                })?;\n                unsafe { sqlite3_bind_int64(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyFloat>() {\n                let val = val.to_f64();\n                unsafe { sqlite3_bind_double(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyStr>() {\n                let val = val.try_as_utf8(vm)?;\n                let (ptr, len) = str_to_ptr_len(val, vm)?;\n                unsafe { sqlite3_bind_text(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, obj) {\n                let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                unsafe { sqlite3_bind_blob(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Error binding parameter {}: type '{}' is not supported\",\n                        pos,\n                        obj.class()\n                    ),\n                ));\n            };\n\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                let db = SqliteRaw::from(self);\n                db.check(ret, vm)\n            }\n        }\n\n        fn bind_parameters(self, parameters: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            if let Some(dict) = parameters.downcast_ref::<PyDict>() {\n                self.bind_parameters_name(dict, vm)\n            } else if let Ok(seq) = PySequence::try_protocol(parameters, vm) {\n                self.bind_parameters_sequence(seq, vm)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"parameters are of unsupported type\".to_owned(),\n                ))\n            }\n        }\n\n        fn bind_parameters_name(self, dict: &Py<PyDict>, vm: &VirtualMachine) -> PyResult<()> {\n            let num_needed = unsafe { sqlite3_bind_parameter_count(self.st) };\n\n            for i in 1..=num_needed {\n                let name = unsafe { sqlite3_bind_parameter_name(self.st, i) };\n                if name.is_null() {\n                    return Err(new_programming_error(vm, \"Binding {} has no name, but you supplied a dictionary (which has only names).\".to_owned()));\n                }\n                let name = unsafe { name.add(1) };\n                let name = ptr_to_str(name, vm)?;\n\n                let val = match dict.get_item_opt(name, vm)? {\n                    Some(val) => val,\n                    None => {\n                        return Err(new_programming_error(\n                            vm,\n                            format!(\"You did not supply a value for binding parameter :{name}.\",),\n                        ));\n                    }\n                };\n\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn bind_parameter_count(self) -> c_int {\n            unsafe { sqlite3_bind_parameter_count(self.st) }\n        }\n\n        fn bind_parameters_sequence(\n            self,\n            seq: PySequence<'_>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let num_needed = self.bind_parameter_count();\n            let num_supplied = seq.length(vm)?;\n\n            if num_supplied != num_needed as usize {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Incorrect number of bindings supplied. The current statement uses {}, and {} were supplied.\",\n                        num_needed, num_supplied\n                    ),\n                ));\n            }\n\n            for i in 1..=num_needed {\n                let val = seq.get_item(i as isize - 1, vm)?;\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn column_count(self) -> c_int {\n            unsafe { sqlite3_column_count(self.st) }\n        }\n\n        fn column_type(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_type(self.st, pos) }\n        }\n\n        fn column_int(self, pos: c_int) -> i64 {\n            unsafe { sqlite3_column_int64(self.st, pos) }\n        }\n\n        fn column_double(self, pos: c_int) -> f64 {\n            unsafe { sqlite3_column_double(self.st, pos) }\n        }\n\n        fn column_blob(self, pos: c_int) -> *const c_void {\n            unsafe { sqlite3_column_blob(self.st, pos) }\n        }\n\n        fn column_text(self, pos: c_int) -> *const u8 {\n            unsafe { sqlite3_column_text(self.st, pos) }\n        }\n\n        fn column_decltype(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_decltype(self.st, pos) }\n        }\n\n        fn column_bytes(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_bytes(self.st, pos) }\n        }\n\n        fn column_name(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_name(self.st, pos) }\n        }\n\n        fn columns_name(self, detect_types: i32, vm: &VirtualMachine) -> PyResult<Vec<PyStrRef>> {\n            let count = self.column_count();\n            (0..count)\n                .map(|i| {\n                    let name = self.column_name(i);\n                    let name_str = ptr_to_str(name, vm)?;\n\n                    // If PARSE_COLNAMES is enabled, strip everything after the first '[' (and preceding space)\n                    let processed_name = if detect_types & PARSE_COLNAMES != 0\n                        && let Some(bracket_pos) = name_str.find('[')\n                    {\n                        // Check if there's a single space before '[' and remove it (CPython compatibility)\n                        let end_pos = if bracket_pos > 0\n                            && name_str.chars().nth(bracket_pos - 1) == Some(' ')\n                        {\n                            bracket_pos - 1\n                        } else {\n                            bracket_pos\n                        };\n\n                        &name_str[..end_pos]\n                    } else {\n                        name_str\n                    };\n\n                    Ok(vm.ctx.new_str(processed_name))\n                })\n                .collect()\n        }\n\n        fn columns_description(\n            self,\n            detect_types: i32,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<PyTupleRef>> {\n            if self.column_count() == 0 {\n                return Ok(None);\n            }\n            let columns = self\n                .columns_name(detect_types, vm)?\n                .into_iter()\n                .map(|s| {\n                    vm.ctx\n                        .new_tuple(vec![\n                            s.into(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                        ])\n                        .into()\n                })\n                .collect();\n            Ok(Some(vm.ctx.new_tuple(columns)))\n        }\n\n        fn busy(self) -> bool {\n            unsafe { sqlite3_stmt_busy(self.st) != 0 }\n        }\n\n        fn readonly(self) -> bool {\n            unsafe { sqlite3_stmt_readonly(self.st) != 0 }\n        }\n    }\n\n    #[derive(Debug, Copy, Clone)]\n    struct SqliteBlob {\n        blob: *mut sqlite3_blob,\n    }\n\n    impl SqliteBlob {\n        fn bytes(self) -> c_int {\n            unsafe { sqlite3_blob_bytes(self.blob) }\n        }\n\n        fn write(self, buf: *const c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_write(self.blob, buf, length, offset) }\n        }\n\n        fn read(self, buf: *mut c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_read(self.blob, buf, length, offset) }\n        }\n\n        fn read_single(self, byte: &mut u8, offset: c_int) -> c_int {\n            self.read(byte as *mut u8 as *mut _, 1, offset)\n        }\n\n        fn write_single(self, byte: u8, offset: c_int) -> c_int {\n            self.write(&byte as *const u8 as *const _, 1, offset)\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteContext {\n        ctx: *mut sqlite3_context,\n    }\n\n    impl From<*mut sqlite3_context> for SqliteContext {\n        fn from(ctx: *mut sqlite3_context) -> Self {\n            Self { ctx }\n        }\n    }\n\n    impl SqliteContext {\n        fn user_data<T>(self) -> *mut T {\n            unsafe { sqlite3_user_data(self.ctx).cast() }\n        }\n\n        fn aggregate_context<T>(self) -> *mut T {\n            unsafe { sqlite3_aggregate_context(self.ctx, std::mem::size_of::<T>() as c_int).cast() }\n        }\n\n        fn result_exception(self, vm: &VirtualMachine, exc: PyBaseExceptionRef, msg: &str) {\n            if exc.fast_isinstance(vm.ctx.exceptions.memory_error) {\n                unsafe { sqlite3_result_error_nomem(self.ctx) }\n            } else if exc.fast_isinstance(vm.ctx.exceptions.overflow_error) {\n                unsafe { sqlite3_result_error_toobig(self.ctx) }\n            } else {\n                unsafe { sqlite3_result_error(self.ctx, msg.as_ptr().cast(), -1) }\n            }\n            if enable_traceback().load(Ordering::Relaxed) {\n                vm.print_exception(exc);\n            }\n        }\n\n        fn db_handle(self) -> *mut sqlite3 {\n            unsafe { sqlite3_context_db_handle(self.ctx) }\n        }\n\n        fn result_from_object(self, val: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            unsafe {\n                if vm.is_none(val) {\n                    sqlite3_result_null(self.ctx)\n                } else if let Some(val) = val.downcast_ref::<PyInt>() {\n                    sqlite3_result_int64(self.ctx, val.try_to_primitive(vm)?)\n                } else if let Some(val) = val.downcast_ref::<PyFloat>() {\n                    sqlite3_result_double(self.ctx, val.to_f64())\n                } else if let Some(val) = val.downcast_ref::<PyStr>() {\n                    let val = val.try_as_utf8(vm)?;\n                    let (ptr, len) = str_to_ptr_len(val, vm)?;\n                    sqlite3_result_text(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, val) {\n                    let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                    sqlite3_result_blob(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else {\n                    return Err(new_programming_error(\n                        vm,\n                        \"result type not support\".to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n    }\n\n    fn value_to_object(val: *mut sqlite3_value, db: *mut sqlite3, vm: &VirtualMachine) -> PyResult {\n        let obj = unsafe {\n            match sqlite3_value_type(val) {\n                SQLITE_INTEGER => vm.ctx.new_int(sqlite3_value_int64(val)).into(),\n                SQLITE_FLOAT => vm.ctx.new_float(sqlite3_value_double(val)).into(),\n                SQLITE_TEXT => {\n                    let text =\n                        ptr_to_vec(sqlite3_value_text(val), sqlite3_value_bytes(val), db, vm)?;\n                    let text = String::from_utf8(text)\n                        .map_err(|_| vm.new_value_error(\"invalid utf-8 with SQLITE_TEXT\"))?;\n                    vm.ctx.new_str(text).into()\n                }\n                SQLITE_BLOB => {\n                    let blob = ptr_to_vec(\n                        sqlite3_value_blob(val).cast(),\n                        sqlite3_value_bytes(val),\n                        db,\n                        vm,\n                    )?;\n                    vm.ctx.new_bytes(blob).into()\n                }\n                _ => vm.ctx.none(),\n            }\n        };\n        Ok(obj)\n    }\n\n    fn ptr_to_str<'a>(p: *const libc::c_char, vm: &VirtualMachine) -> PyResult<&'a str> {\n        if p.is_null() {\n            return Err(vm.new_memory_error(\"string pointer is null\"));\n        }\n        unsafe { CStr::from_ptr(p).to_str() }\n            .map_err(|_| vm.new_value_error(\"Invalid UIF-8 codepoint\"))\n    }\n\n    fn ptr_to_string(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<String> {\n        let s = ptr_to_vec(p, nbytes, db, vm)?;\n        String::from_utf8(s).map_err(|_| vm.new_value_error(\"invalid utf-8\"))\n    }\n\n    fn ptr_to_vec(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<Vec<u8>> {\n        if p.is_null() {\n            if !db.is_null() && unsafe { sqlite3_errcode(db) } == SQLITE_NOMEM {\n                Err(vm.new_memory_error(\"sqlite out of memory\"))\n            } else {\n                Ok(vec![])\n            }\n        } else if nbytes < 0 {\n            Err(vm.new_system_error(\"negative size with ptr\"))\n        } else {\n            Ok(unsafe { std::slice::from_raw_parts(p.cast(), nbytes as usize) }.to_vec())\n        }\n    }\n\n    fn str_to_ptr_len(s: &PyUtf8Str, vm: &VirtualMachine) -> PyResult<(*const libc::c_char, i32)> {\n        let s_str = s.as_str();\n        let len = c_int::try_from(s_str.len())\n            .map_err(|_| vm.new_overflow_error(\"TEXT longer than INT_MAX bytes\"))?;\n        let ptr = s_str.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn buffer_to_ptr_len(buffer: &PyBuffer, vm: &VirtualMachine) -> PyResult<(*const c_void, i32)> {\n        let bytes = buffer\n            .as_contiguous()\n            .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n        let len = c_int::try_from(bytes.len())\n            .map_err(|_| vm.new_overflow_error(\"BLOB longer than INT_MAX bytes\"))?;\n        let ptr = bytes.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn exception_type_from_errcode(errcode: c_int, vm: &VirtualMachine) -> &'static Py<PyType> {\n        match errcode {\n            SQLITE_INTERNAL | SQLITE_NOTFOUND => internal_error_type(),\n            SQLITE_NOMEM => vm.ctx.exceptions.memory_error,\n            SQLITE_ERROR | SQLITE_PERM | SQLITE_ABORT | SQLITE_BUSY | SQLITE_LOCKED\n            | SQLITE_READONLY | SQLITE_INTERRUPT | SQLITE_IOERR | SQLITE_FULL | SQLITE_CANTOPEN\n            | SQLITE_PROTOCOL | SQLITE_EMPTY | SQLITE_SCHEMA => operational_error_type(),\n            SQLITE_CORRUPT => database_error_type(),\n            SQLITE_TOOBIG => data_error_type(),\n            SQLITE_CONSTRAINT | SQLITE_MISMATCH => integrity_error_type(),\n            SQLITE_MISUSE | SQLITE_RANGE => interface_error_type(),\n            _ => database_error_type(),\n        }\n    }\n\n    fn name_from_errcode(errcode: c_int) -> &'static str {\n        for (name, code) in ERROR_CODES {\n            if *code == errcode {\n                return name;\n            }\n        }\n        \"unknown error code\"\n    }\n\n    fn raise_exception(\n        typ: PyTypeRef,\n        errcode: c_int,\n        msg: String,\n        vm: &VirtualMachine,\n    ) -> PyBaseExceptionRef {\n        let dict = vm.ctx.new_dict();\n        if let Err(e) = dict.set_item(\"sqlite_errorcode\", vm.ctx.new_int(errcode).into(), vm) {\n            return e;\n        }\n        let errname = name_from_errcode(errcode);\n        if let Err(e) = dict.set_item(\"sqlite_errorname\", vm.ctx.new_str(errname).into(), vm) {\n            return e;\n        }\n\n        vm.new_exception_msg_dict(typ, msg, dict)\n    }\n\n    static BEGIN_STATEMENTS: &[&[u8]] = &[\n        b\"BEGIN \",\n        b\"BEGIN DEFERRED\",\n        b\"BEGIN IMMEDIATE\",\n        b\"BEGIN EXCLUSIVE\",\n    ];\n\n    fn begin_statement_ptr_from_isolation_level(\n        s: &PyStr,\n        vm: &VirtualMachine,\n    ) -> PyResult<*const libc::c_char> {\n        BEGIN_STATEMENTS\n            .iter()\n            .find(|&&x| x[6..].eq_ignore_ascii_case(s.as_bytes()))\n            .map(|&x| x.as_ptr().cast())\n            .ok_or_else(|| {\n                vm.new_value_error(\n                    \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or 'EXCLUSIVE'\",\n                )\n            })\n    }\n\n    fn lstrip_sql(sql: &[u8]) -> Option<&[u8]> {\n        let mut pos = 0;\n\n        // This loop is borrowed from the SQLite source code.\n        while let Some(t_char) = sql.get(pos) {\n            match t_char {\n                b' ' | b'\\t' | b'\\x0c' | b'\\n' | b'\\r' => {\n                    // Skip whitespace.\n                    pos += 1;\n                }\n                b'-' => {\n                    // Skip line comments.\n                    if sql.get(pos + 1) == Some(&b'-') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'\\n' {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                b'/' => {\n                    // Skip C style comments.\n                    if sql.get(pos + 1) == Some(&b'*') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'*' && sql.get(pos + 1) == Some(&b'/') {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                        pos += 2;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                _ => {\n                    return Some(&sql[pos..]);\n                }\n            }\n        }\n\n        None\n    }\n}\n"
                }
              ],
              []
            ],
            "kind": "textEditGroup",
            "uri": {
              "$mid": 1,
              "external": "file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "fsPath": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "path": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "scheme": "file"
            }
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "textEditGroup",
          "input": {
            "done": true,
            "edits": [
              [
                {
                  "range": {
                    "endColumn": 1,
                    "endLineNumber": 3387,
                    "startColumn": 1,
                    "startLineNumber": 1
                  },
                  "text": "// spell-checker:ignore libsqlite3 threadsafety PYSQLITE decltypes colnames collseq cantinit dirtywal\n// spell-checker:ignore corruptfs narg setinputsizes setoutputsize lastrowid arraysize executemany\n// spell-checker:ignore blobopen executescript iterdump getlimit setlimit errorcode errorname\n// spell-checker:ignore rowid rowcount fetchone fetchmany fetchall errcode errname vtable pagecount\n// spell-checker:ignore autocommit libversion toobig errmsg nomem threadsafe longlong vdbe reindex\n// spell-checker:ignore savepoint cantopen ioerr nolfs nomem notadb notfound fullpath notempdir vtab\n// spell-checker:ignore checkreservedlock noent fstat rdlock shmlock shmmap shmopen shmsize sharedcache\n// spell-checker:ignore cantlock commithook foreignkey notnull primarykey gettemppath autoindex convpath\n// spell-checker:ignore dbmoved vnode nbytes\n\nuse rustpython_vm::{AsObject, PyRef, VirtualMachine, builtins::PyModule};\n\n// pub(crate) use _sqlite::make_module;\npub(crate) fn make_module(vm: &VirtualMachine) -> PyRef<PyModule> {\n    // TODO: sqlite version check\n    let module = _sqlite::make_module(vm);\n    _sqlite::setup_module(module.as_object(), vm);\n    module\n}\n\n#[pymodule]\nmod _sqlite {\n    use crossbeam_utils::atomic::AtomicCell;\n    use libsqlite3_sys::{\n        SQLITE_BLOB, SQLITE_DETERMINISTIC, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL,\n        SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, SQLITE_OPEN_URI, SQLITE_TEXT, SQLITE_TRACE_STMT,\n        SQLITE_TRANSIENT, SQLITE_UTF8, sqlite3, sqlite3_aggregate_context, sqlite3_backup_finish,\n        sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining,\n        sqlite3_backup_step, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64,\n        sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name,\n        sqlite3_bind_text, sqlite3_blob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open,\n        sqlite3_blob_read, sqlite3_blob_write, sqlite3_busy_timeout, sqlite3_changes,\n        sqlite3_close_v2, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count,\n        sqlite3_column_decltype, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_name,\n        sqlite3_column_text, sqlite3_column_type, sqlite3_complete, sqlite3_context,\n        sqlite3_context_db_handle, sqlite3_create_collation_v2, sqlite3_create_function_v2,\n        sqlite3_create_window_function, sqlite3_data_count, sqlite3_db_handle, sqlite3_errcode,\n        sqlite3_errmsg, sqlite3_exec, sqlite3_expanded_sql, sqlite3_extended_errcode,\n        sqlite3_finalize, sqlite3_get_autocommit, sqlite3_interrupt, sqlite3_last_insert_rowid,\n        sqlite3_libversion, sqlite3_limit, sqlite3_open_v2, sqlite3_prepare_v2,\n        sqlite3_progress_handler, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double,\n        sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_error_toobig,\n        sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_set_authorizer,\n        sqlite3_sleep, sqlite3_step, sqlite3_stmt, sqlite3_stmt_busy, sqlite3_stmt_readonly,\n        sqlite3_threadsafe, sqlite3_total_changes, sqlite3_trace_v2, sqlite3_user_data,\n        sqlite3_value, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double,\n        sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type,\n    };\n    use malachite_bigint::Sign;\n    use rustpython_common::{\n        atomic::{Ordering, PyAtomic, Radium},\n        hash::PyHash,\n        lock::{PyMappedMutexGuard, PyMutex, PyMutexGuard},\n        static_cell,\n    };\n    use rustpython_vm::{\n        __exports::paste,\n        AsObject, Py, PyAtomicRef, PyObject, PyObjectRef, PyPayload, PyRef, PyResult,\n        TryFromBorrowedObject, VirtualMachine, atomic_func,\n        builtins::{\n            PyBaseException, PyBaseExceptionRef, PyByteArray, PyBytes, PyDict, PyDictRef, PyFloat,\n            PyInt, PyIntRef, PySlice, PyStr, PyStrRef, PyTuple, PyTupleRef, PyType, PyTypeRef,\n            PyUtf8Str, PyUtf8StrRef,\n        },\n        convert::IntoObject,\n        function::{\n            ArgCallable, ArgIterable, FsPath, FuncArgs, OptionalArg, PyComparisonValue,\n            PySetterValue,\n        },\n        object::{Traverse, TraverseFn},\n        protocol::{\n            PyBuffer, PyIterReturn, PyMappingMethods, PyNumberMethods, PySequence,\n            PySequenceMethods,\n        },\n        sliceable::{SaturatedSliceIter, SliceableSequenceOp},\n        types::{\n            AsMapping, AsNumber, AsSequence, Callable, Comparable, Constructor, Hashable,\n            Initializer, IterNext, Iterable, PyComparisonOp, SelfIter, Unconstructible,\n        },\n        utils::ToCString,\n    };\n    use std::{\n        ffi::{CStr, c_int, c_longlong, c_uint, c_void},\n        fmt::Debug,\n        ops::Deref,\n        ptr::{NonNull, null, null_mut},\n        thread::ThreadId,\n    };\n\n    macro_rules! exceptions {\n        ($(($x:ident, $base:expr)),*) => {\n            paste::paste! {\n                static_cell! {\n                    $(\n                        static [<$x:snake:upper>]: PyTypeRef;\n                    )*\n                }\n                $(\n                    #[allow(dead_code)]\n                    fn [<new_ $x:snake>](vm: &VirtualMachine, msg: String) -> PyBaseExceptionRef {\n                        vm.new_exception_msg([<$x:snake _type>]().to_owned(), msg)\n                    }\n                    fn [<$x:snake _type>]() -> &'static Py<PyType> {\n                        [<$x:snake:upper>].get().expect(\"exception type not initialize\")\n                    }\n                )*\n                fn setup_module_exceptions(module: &PyObject, vm: &VirtualMachine) {\n                    $(\n                        #[allow(clippy::redundant_closure_call)]\n                        let exception = [<$x:snake:upper>].get_or_init(|| {\n                            let base = $base(vm);\n                            vm.ctx.new_exception_type(\"_sqlite3\", stringify!($x), Some(vec![base.to_owned()]))\n                        });\n                        module.set_attr(stringify!($x), exception.clone().into_object(), vm).unwrap();\n                    )*\n                }\n            }\n        };\n    }\n\n    exceptions!(\n        (Warning, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (Error, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (InterfaceError, |_| error_type()),\n        (DatabaseError, |_| error_type()),\n        (DataError, |_| database_error_type()),\n        (OperationalError, |_| database_error_type()),\n        (IntegrityError, |_| database_error_type()),\n        (InternalError, |_| database_error_type()),\n        (ProgrammingError, |_| database_error_type()),\n        (NotSupportedError, |_| database_error_type())\n    );\n\n    #[pyattr]\n    fn sqlite_version(vm: &VirtualMachine) -> String {\n        let s = unsafe { sqlite3_libversion() };\n        ptr_to_str(s, vm).unwrap().to_owned()\n    }\n\n    #[pyattr]\n    fn threadsafety(_: &VirtualMachine) -> c_int {\n        let mode = unsafe { sqlite3_threadsafe() };\n        match mode {\n            0 => 0,\n            1 => 3,\n            2 => 1,\n            _ => panic!(\"Unable to interpret SQLite threadsafety mode\"),\n        }\n    }\n\n    #[pyattr(name = \"_deprecated_version\")]\n    const PYSQLITE_VERSION: &str = \"2.6.0\";\n\n    #[pyattr]\n    const PARSE_DECLTYPES: c_int = 1;\n    #[pyattr]\n    const PARSE_COLNAMES: c_int = 2;\n\n    #[pyattr]\n    use libsqlite3_sys::{\n        SQLITE_ALTER_TABLE, SQLITE_ANALYZE, SQLITE_ATTACH, SQLITE_CREATE_INDEX,\n        SQLITE_CREATE_TABLE, SQLITE_CREATE_TEMP_INDEX, SQLITE_CREATE_TEMP_TABLE,\n        SQLITE_CREATE_TEMP_TRIGGER, SQLITE_CREATE_TEMP_VIEW, SQLITE_CREATE_TRIGGER,\n        SQLITE_CREATE_VIEW, SQLITE_CREATE_VTABLE, SQLITE_DELETE, SQLITE_DENY, SQLITE_DETACH,\n        SQLITE_DROP_INDEX, SQLITE_DROP_TABLE, SQLITE_DROP_TEMP_INDEX, SQLITE_DROP_TEMP_TABLE,\n        SQLITE_DROP_TEMP_TRIGGER, SQLITE_DROP_TEMP_VIEW, SQLITE_DROP_TRIGGER, SQLITE_DROP_VIEW,\n        SQLITE_DROP_VTABLE, SQLITE_FUNCTION, SQLITE_IGNORE, SQLITE_INSERT, SQLITE_LIMIT_ATTACHED,\n        SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH,\n        SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH,\n        SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER,\n        SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_PRAGMA, SQLITE_READ,\n        SQLITE_RECURSIVE, SQLITE_REINDEX, SQLITE_SAVEPOINT, SQLITE_SELECT, SQLITE_TRANSACTION,\n        SQLITE_UPDATE,\n    };\n\n    macro_rules! error_codes {\n        ($($x:ident),*) => {\n            $(\n                #[allow(unused_imports)]\n                use libsqlite3_sys::$x;\n            )*\n            static ERROR_CODES: &[(&str, c_int)] = &[\n            $(\n                (stringify!($x), libsqlite3_sys::$x),\n            )*\n            ];\n        };\n    }\n\n    error_codes!(\n        SQLITE_ABORT,\n        SQLITE_AUTH,\n        SQLITE_BUSY,\n        SQLITE_CANTOPEN,\n        SQLITE_CONSTRAINT,\n        SQLITE_CORRUPT,\n        SQLITE_DONE,\n        SQLITE_EMPTY,\n        SQLITE_ERROR,\n        SQLITE_FORMAT,\n        SQLITE_FULL,\n        SQLITE_INTERNAL,\n        SQLITE_INTERRUPT,\n        SQLITE_IOERR,\n        SQLITE_LOCKED,\n        SQLITE_MISMATCH,\n        SQLITE_MISUSE,\n        SQLITE_NOLFS,\n        SQLITE_NOMEM,\n        SQLITE_NOTADB,\n        SQLITE_NOTFOUND,\n        SQLITE_OK,\n        SQLITE_PERM,\n        SQLITE_PROTOCOL,\n        SQLITE_RANGE,\n        SQLITE_READONLY,\n        SQLITE_ROW,\n        SQLITE_SCHEMA,\n        SQLITE_TOOBIG,\n        SQLITE_NOTICE,\n        SQLITE_WARNING,\n        SQLITE_ABORT_ROLLBACK,\n        SQLITE_BUSY_RECOVERY,\n        SQLITE_CANTOPEN_FULLPATH,\n        SQLITE_CANTOPEN_ISDIR,\n        SQLITE_CANTOPEN_NOTEMPDIR,\n        SQLITE_CORRUPT_VTAB,\n        SQLITE_IOERR_ACCESS,\n        SQLITE_IOERR_BLOCKED,\n        SQLITE_IOERR_CHECKRESERVEDLOCK,\n        SQLITE_IOERR_CLOSE,\n        SQLITE_IOERR_DELETE,\n        SQLITE_IOERR_DELETE_NOENT,\n        SQLITE_IOERR_DIR_CLOSE,\n        SQLITE_IOERR_DIR_FSYNC,\n        SQLITE_IOERR_FSTAT,\n        SQLITE_IOERR_FSYNC,\n        SQLITE_IOERR_LOCK,\n        SQLITE_IOERR_NOMEM,\n        SQLITE_IOERR_RDLOCK,\n        SQLITE_IOERR_READ,\n        SQLITE_IOERR_SEEK,\n        SQLITE_IOERR_SHMLOCK,\n        SQLITE_IOERR_SHMMAP,\n        SQLITE_IOERR_SHMOPEN,\n        SQLITE_IOERR_SHMSIZE,\n        SQLITE_IOERR_SHORT_READ,\n        SQLITE_IOERR_TRUNCATE,\n        SQLITE_IOERR_UNLOCK,\n        SQLITE_IOERR_WRITE,\n        SQLITE_LOCKED_SHAREDCACHE,\n        SQLITE_READONLY_CANTLOCK,\n        SQLITE_READONLY_RECOVERY,\n        SQLITE_CONSTRAINT_CHECK,\n        SQLITE_CONSTRAINT_COMMITHOOK,\n        SQLITE_CONSTRAINT_FOREIGNKEY,\n        SQLITE_CONSTRAINT_FUNCTION,\n        SQLITE_CONSTRAINT_NOTNULL,\n        SQLITE_CONSTRAINT_PRIMARYKEY,\n        SQLITE_CONSTRAINT_TRIGGER,\n        SQLITE_CONSTRAINT_UNIQUE,\n        SQLITE_CONSTRAINT_VTAB,\n        SQLITE_READONLY_ROLLBACK,\n        SQLITE_IOERR_MMAP,\n        SQLITE_NOTICE_RECOVER_ROLLBACK,\n        SQLITE_NOTICE_RECOVER_WAL,\n        SQLITE_BUSY_SNAPSHOT,\n        SQLITE_IOERR_GETTEMPPATH,\n        SQLITE_WARNING_AUTOINDEX,\n        SQLITE_CANTOPEN_CONVPATH,\n        SQLITE_IOERR_CONVPATH,\n        SQLITE_CONSTRAINT_ROWID,\n        SQLITE_READONLY_DBMOVED,\n        SQLITE_AUTH_USER,\n        SQLITE_OK_LOAD_PERMANENTLY,\n        SQLITE_IOERR_VNODE,\n        SQLITE_IOERR_AUTH,\n        SQLITE_IOERR_BEGIN_ATOMIC,\n        SQLITE_IOERR_COMMIT_ATOMIC,\n        SQLITE_IOERR_ROLLBACK_ATOMIC,\n        SQLITE_ERROR_MISSING_COLLSEQ,\n        SQLITE_ERROR_RETRY,\n        SQLITE_READONLY_CANTINIT,\n        SQLITE_READONLY_DIRECTORY,\n        SQLITE_CORRUPT_SEQUENCE,\n        SQLITE_LOCKED_VTAB,\n        SQLITE_CANTOPEN_DIRTYWAL,\n        SQLITE_ERROR_SNAPSHOT,\n        SQLITE_CANTOPEN_SYMLINK,\n        SQLITE_CONSTRAINT_PINNED,\n        SQLITE_OK_SYMLINK,\n        SQLITE_BUSY_TIMEOUT,\n        SQLITE_CORRUPT_INDEX,\n        SQLITE_IOERR_DATA,\n        SQLITE_IOERR_CORRUPTFS\n    );\n\n    #[derive(FromArgs)]\n    struct ConnectArgs {\n        #[pyarg(any)]\n        database: FsPath,\n        #[pyarg(any, default = 5.0)]\n        timeout: f64,\n        #[pyarg(any, default = 0)]\n        detect_types: c_int,\n        #[pyarg(any, default = Some(vm.ctx.empty_str.to_owned()))]\n        isolation_level: Option<PyStrRef>,\n        #[pyarg(any, default = true)]\n        check_same_thread: bool,\n        #[pyarg(any, default = Connection::class(&vm.ctx).to_owned())]\n        factory: PyTypeRef,\n        // TODO: cache statements\n        #[allow(dead_code)]\n        #[pyarg(any, default = 0)]\n        cached_statements: c_int,\n        #[pyarg(any, default = false)]\n        uri: bool,\n    }\n\n    unsafe impl Traverse for ConnectArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.isolation_level.traverse(tracer_fn);\n            self.factory.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct BackupArgs {\n        #[pyarg(any)]\n        target: PyRef<Connection>,\n        #[pyarg(named, default = -1)]\n        pages: c_int,\n        #[pyarg(named, optional)]\n        progress: Option<ArgCallable>,\n        #[pyarg(named, optional)]\n        name: Option<PyStrRef>,\n        #[pyarg(named, default = 0.250)]\n        sleep: f64,\n    }\n\n    unsafe impl Traverse for BackupArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.progress.traverse(tracer_fn);\n            self.name.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct CreateFunctionArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(any)]\n        narg: c_int,\n        #[pyarg(any)]\n        func: PyObjectRef,\n        #[pyarg(named, default)]\n        deterministic: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct CreateAggregateArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(positional)]\n        narg: c_int,\n        #[pyarg(positional)]\n        aggregate_class: PyObjectRef,\n    }\n\n    #[derive(FromArgs)]\n    struct BlobOpenArgs {\n        #[pyarg(positional)]\n        table: PyStrRef,\n        #[pyarg(positional)]\n        column: PyStrRef,\n        #[pyarg(positional)]\n        row: i64,\n        #[pyarg(named, default)]\n        readonly: bool,\n        #[pyarg(named, default = vm.ctx.new_str(\"main\"))]\n        name: PyStrRef,\n    }\n\n    struct CallbackData {\n        obj: NonNull<PyObject>,\n        vm: *const VirtualMachine,\n    }\n\n    impl CallbackData {\n        fn new(obj: PyObjectRef, vm: &VirtualMachine) -> Option<Self> {\n            (!vm.is_none(&obj)).then_some(Self {\n                obj: obj.into_raw(),\n                vm,\n            })\n        }\n\n        fn retrieve(&self) -> (&PyObject, &VirtualMachine) {\n            unsafe { (self.obj.as_ref(), &*self.vm) }\n        }\n\n        unsafe extern \"C\" fn destructor(data: *mut c_void) {\n            drop(unsafe { Box::from_raw(data.cast::<Self>()) });\n        }\n\n        unsafe extern \"C\" fn func_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (func, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n\n                let val = func.call(args, vm)?;\n\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                context.result_exception(vm, exc, \"user-defined function raised exception\\0\")\n            }\n        }\n\n        unsafe extern \"C\" fn step_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (cls, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            if unsafe { (*instance).is_null() } {\n                match cls.call((), vm) {\n                    Ok(obj) => unsafe { *instance = obj.into_raw().as_ptr() },\n                    Err(exc) => {\n                        return context.result_exception(\n                            vm,\n                            exc,\n                            \"user-defined aggregate's '__init__' method raised error\\0\",\n                        );\n                    }\n                }\n            }\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"step\", args, vm);\n        }\n\n        unsafe extern \"C\" fn finalize_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let Some(instance) = (unsafe { (*instance).as_ref() }) else {\n                return;\n            };\n\n            Self::callback_result_from_method(context, instance, \"finalize\", vm);\n        }\n\n        unsafe extern \"C\" fn collation_callback(\n            data: *mut c_void,\n            a_len: c_int,\n            a_ptr: *const c_void,\n            b_len: c_int,\n            b_ptr: *const c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n\n            let f = || -> PyResult<c_int> {\n                let text1 = ptr_to_string(a_ptr.cast(), a_len, null_mut(), vm)?;\n                let text1 = vm.ctx.new_str(text1);\n                let text2 = ptr_to_string(b_ptr.cast(), b_len, null_mut(), vm)?;\n                let text2 = vm.ctx.new_str(text2);\n\n                let val = callable.call((text1, text2), vm)?;\n                let Some(val) = val.to_number().index(vm) else {\n                    return Ok(0);\n                };\n\n                let val = match val?.as_bigint().sign() {\n                    Sign::Plus => 1,\n                    Sign::Minus => -1,\n                    Sign::NoSign => 0,\n                };\n\n                Ok(val)\n            };\n\n            f().unwrap_or(0)\n        }\n\n        unsafe extern \"C\" fn value_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::callback_result_from_method(context, instance, \"value\", vm);\n        }\n\n        unsafe extern \"C\" fn inverse_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"inverse\", args, vm);\n        }\n\n        unsafe extern \"C\" fn authorizer_callback(\n            data: *mut c_void,\n            action: c_int,\n            arg1: *const libc::c_char,\n            arg2: *const libc::c_char,\n            db_name: *const libc::c_char,\n            access: *const libc::c_char,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let f = || -> PyResult<c_int> {\n                let arg1 = ptr_to_str(arg1, vm)?;\n                let arg2 = ptr_to_str(arg2, vm)?;\n                let db_name = ptr_to_str(db_name, vm)?;\n                let access = ptr_to_str(access, vm)?;\n\n                let val = callable.call((action, arg1, arg2, db_name, access), vm)?;\n                let Some(val) = val.downcast_ref::<PyInt>() else {\n                    return Ok(SQLITE_DENY);\n                };\n                val.try_to_primitive::<c_int>(vm)\n            };\n\n            f().unwrap_or(SQLITE_DENY)\n        }\n\n        unsafe extern \"C\" fn trace_callback(\n            _typ: c_uint,\n            data: *mut c_void,\n            stmt: *mut c_void,\n            sql: *mut c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let expanded = unsafe { sqlite3_expanded_sql(stmt.cast()) };\n            let f = || -> PyResult<()> {\n                let stmt = ptr_to_str(expanded, vm).or_else(|_| ptr_to_str(sql.cast(), vm))?;\n                callable.call((stmt,), vm)?;\n                Ok(())\n            };\n            let _ = f();\n            0\n        }\n\n        unsafe extern \"C\" fn progress_callback(data: *mut c_void) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            if let Ok(val) = callable.call((), vm)\n                && let Ok(val) = val.is_true(vm)\n            {\n                return val as c_int;\n            }\n            -1\n        }\n\n        fn callback_result_from_method(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let val = vm.call_method(instance, name, ())?;\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n\n        fn call_method_with_args(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            args: &[*mut sqlite3_value],\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n                vm.call_method(instance, name, args).map(drop)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n    }\n\n    impl Drop for CallbackData {\n        fn drop(&mut self) {\n            unsafe { PyObjectRef::from_raw(self.obj) };\n        }\n    }\n\n    #[pyfunction]\n    fn connect(args: ConnectArgs, vm: &VirtualMachine) -> PyResult {\n        Connection::py_new(args.factory.clone(), args, vm)\n    }\n\n    #[pyfunction]\n    fn complete_statement(statement: PyStrRef, vm: &VirtualMachine) -> PyResult<bool> {\n        let s = statement.to_cstring(vm)?;\n        let ret = unsafe { sqlite3_complete(s.as_ptr()) };\n        Ok(ret == 1)\n    }\n\n    #[pyfunction]\n    fn enable_callback_tracebacks(flag: bool) {\n        enable_traceback().store(flag, Ordering::Relaxed);\n    }\n\n    #[pyfunction]\n    fn register_adapter(typ: PyTypeRef, adapter: ArgCallable, vm: &VirtualMachine) -> PyResult<()> {\n        if typ.is(PyInt::class(&vm.ctx))\n            || typ.is(PyFloat::class(&vm.ctx))\n            || typ.is(PyStr::class(&vm.ctx))\n            || typ.is(PyByteArray::class(&vm.ctx))\n        {\n            let _ = BASE_TYPE_ADAPTED.set(());\n        }\n        let protocol = PrepareProtocol::class(&vm.ctx).to_owned();\n        let key = vm.ctx.new_tuple(vec![typ.into(), protocol.into()]);\n        adapters().set_item(key.as_object(), adapter.into(), vm)\n    }\n\n    #[pyfunction]\n    fn register_converter(\n        typename: PyStrRef,\n        converter: ArgCallable,\n        vm: &VirtualMachine,\n    ) -> PyResult<()> {\n        let name = typename.as_str().to_uppercase();\n        converters().set_item(&name, converter.into(), vm)\n    }\n\n    fn _adapt<F>(obj: &PyObject, proto: PyTypeRef, alt: F, vm: &VirtualMachine) -> PyResult\n    where\n        F: FnOnce(&PyObject) -> PyResult,\n    {\n        let proto = proto.into_object();\n        let key = vm\n            .ctx\n            .new_tuple(vec![obj.class().to_owned().into(), proto.clone()]);\n\n        if let Some(adapter) = adapters().get_item_opt(key.as_object(), vm)? {\n            return adapter.call((obj,), vm);\n        }\n        if let Ok(adapter) = proto.get_attr(\"__adapt__\", vm) {\n            match adapter.call((obj,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n        if let Ok(adapter) = obj.get_attr(\"__conform__\", vm) {\n            match adapter.call((proto,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n\n        alt(obj)\n    }\n\n    #[pyfunction]\n    fn adapt(\n        obj: PyObjectRef,\n        proto: OptionalArg<Option<PyTypeRef>>,\n        alt: OptionalArg<PyObjectRef>,\n        vm: &VirtualMachine,\n    ) -> PyResult {\n        if matches!(proto, OptionalArg::Present(None)) {\n            return if let OptionalArg::Present(alt) = alt {\n                Ok(alt)\n            } else {\n                Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n            };\n        }\n\n        let proto = proto\n            .flatten()\n            .unwrap_or_else(|| PrepareProtocol::class(&vm.ctx).to_owned());\n\n        _adapt(\n            &obj,\n            proto,\n            |_| {\n                if let OptionalArg::Present(alt) = alt {\n                    Ok(alt)\n                } else {\n                    Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n                }\n            },\n            vm,\n        )\n    }\n\n    fn need_adapt(obj: &PyObject, vm: &VirtualMachine) -> bool {\n        if BASE_TYPE_ADAPTED.get().is_some() {\n            true\n        } else {\n            let cls = obj.class();\n            !(cls.is(vm.ctx.types.int_type)\n                || cls.is(vm.ctx.types.float_type)\n                || cls.is(vm.ctx.types.str_type)\n                || cls.is(vm.ctx.types.bytearray_type))\n        }\n    }\n\n    static_cell! {\n        static CONVERTERS: PyDictRef;\n        static ADAPTERS: PyDictRef;\n        static BASE_TYPE_ADAPTED: ();\n        static USER_FUNCTION_EXCEPTION: PyAtomicRef<Option<PyBaseException>>;\n        static ENABLE_TRACEBACK: PyAtomic<bool>;\n    }\n\n    fn converters() -> &'static Py<PyDict> {\n        CONVERTERS.get().expect(\"converters not initialize\")\n    }\n\n    fn adapters() -> &'static Py<PyDict> {\n        ADAPTERS.get().expect(\"adapters not initialize\")\n    }\n\n    fn user_function_exception() -> &'static PyAtomicRef<Option<PyBaseException>> {\n        USER_FUNCTION_EXCEPTION\n            .get()\n            .expect(\"user function exception not initialize\")\n    }\n\n    fn enable_traceback() -> &'static PyAtomic<bool> {\n        ENABLE_TRACEBACK\n            .get()\n            .expect(\"enable traceback not initialize\")\n    }\n\n    pub(super) fn setup_module(module: &PyObject, vm: &VirtualMachine) {\n        for (name, code) in ERROR_CODES {\n            let name = vm.ctx.intern_str(*name);\n            let code = vm.new_pyobj(*code);\n            module.set_attr(name, code, vm).unwrap();\n        }\n\n        setup_module_exceptions(module, vm);\n\n        let _ = CONVERTERS.set(vm.ctx.new_dict());\n        let _ = ADAPTERS.set(vm.ctx.new_dict());\n        let _ = USER_FUNCTION_EXCEPTION.set(PyAtomicRef::from(None));\n        let _ = ENABLE_TRACEBACK.set(Radium::new(false));\n\n        module\n            .set_attr(\"converters\", converters().to_owned(), vm)\n            .unwrap();\n        module\n            .set_attr(\"adapters\", adapters().to_owned(), vm)\n            .unwrap();\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(PyPayload)]\n    struct Connection {\n        db: PyMutex<Option<Sqlite>>,\n        detect_types: PyAtomic<c_int>,\n        isolation_level: PyAtomicRef<Option<PyStr>>,\n        check_same_thread: PyAtomic<bool>,\n        thread_ident: PyMutex<ThreadId>,\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        text_factory: PyAtomicRef<PyObject>,\n    }\n\n    impl Debug for Connection {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"Sqlite3 Connection\")\n        }\n    }\n\n    impl Constructor for Connection {\n        type Args = ConnectArgs;\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n\n            // For non-subclassed Connection, initialize in __new__\n            // For subclassed Connection, leave db as None and require __init__ to be called\n            let is_base_class = cls.is(Connection::class(&vm.ctx).as_object());\n\n            let db = if is_base_class {\n                // Initialize immediately for base class\n                Some(Connection::initialize_db(&args, vm)?)\n            } else {\n                // For subclasses, require __init__ to be called\n                None\n            };\n\n            let conn = Self {\n                db: PyMutex::new(db),\n                detect_types: Radium::new(args.detect_types),\n                isolation_level: PyAtomicRef::from(args.isolation_level),\n                check_same_thread: Radium::new(args.check_same_thread),\n                thread_ident: PyMutex::new(std::thread::current().id()),\n                row_factory: PyAtomicRef::from(None),\n                text_factory: PyAtomicRef::from(text_factory),\n            };\n\n            Ok(conn.into_ref_with_type(vm, cls)?.into())\n        }\n    }\n\n    impl Callable for Connection {\n        type Args = FuncArgs;\n\n        fn call(zelf: &Py<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let _ = zelf.db_lock(vm)?;\n\n            let (sql,): (PyUtf8StrRef,) = args.bind(vm)?;\n\n            if let Some(stmt) = Statement::new(zelf, sql, vm)? {\n                Ok(stmt.into_ref(&vm.ctx).into())\n            } else {\n                Ok(vm.ctx.none())\n            }\n        }\n    }\n\n    impl Initializer for Connection {\n        type Args = ConnectArgs;\n\n        fn init(zelf: PyRef<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult<()> {\n            {\n                // Always drop the current database handle so __init__ can fully reconfigure it.\n                let mut guard = zelf.db.lock();\n                guard.take();\n            }\n\n            // Reset factories to their defaults, matching CPython's behavior.\n            let default_text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n            let _ = unsafe { zelf.row_factory.swap(None) };\n            let _ = unsafe { zelf.text_factory.swap(default_text_factory) };\n\n            // Attempt to open the new database before mutating other state so failures leave\n            // the connection uninitialized (and subsequent operations raise ProgrammingError).\n            let db = Self::initialize_db(&args, vm)?;\n\n            let ConnectArgs {\n                detect_types,\n                isolation_level,\n                check_same_thread,\n                ..\n            } = args;\n\n            zelf.detect_types.store(detect_types, Ordering::Relaxed);\n            zelf\n                .check_same_thread\n                .store(check_same_thread, Ordering::Relaxed);\n            *zelf.thread_ident.lock() = std::thread::current().id();\n            let _ = unsafe { zelf.isolation_level.swap(isolation_level) };\n\n            let mut guard = zelf.db.lock();\n            *guard = Some(db);\n            Ok(())\n        }\n    }\n\n    #[pyclass(with(Constructor, Callable, Initializer), flags(BASETYPE))]\n    impl Connection {\n        fn initialize_db(args: &ConnectArgs, vm: &VirtualMachine) -> PyResult<Sqlite> {\n            let path = args.database.to_cstring(vm)?;\n            let db = Sqlite::from(SqliteRaw::open(path.as_ptr(), args.uri, vm)?);\n            let timeout = (args.timeout * 1000.0) as c_int;\n            db.busy_timeout(timeout);\n            if let Some(isolation_level) = &args.isolation_level {\n                begin_statement_ptr_from_isolation_level(isolation_level, vm)?;\n            }\n            Ok(db)\n        }\n\n        fn db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            self.check_thread(vm)?;\n            self._db_lock(vm)\n        }\n\n        fn _db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            let guard = self.db.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Connection.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn cursor(\n            zelf: PyRef<Self>,\n            factory: OptionalArg<ArgCallable>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            zelf.db_lock(vm).map(drop)?;\n\n            let cursor = if let OptionalArg::Present(factory) = factory {\n                let cursor = factory.invoke((zelf.clone(),), vm)?;\n                let cursor = cursor.downcast::<Cursor>().map_err(|x| {\n                    vm.new_type_error(format!(\"factory must return a cursor, not {}\", x.class()))\n                })?;\n                let _ = unsafe { cursor.row_factory.swap(zelf.row_factory.to_owned()) };\n                cursor\n            } else {\n                let row_factory = zelf.row_factory.to_owned();\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx)\n            };\n            Ok(cursor)\n        }\n\n        #[pymethod]\n        fn blobopen(\n            zelf: PyRef<Self>,\n            args: BlobOpenArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Blob>> {\n            let table = args.table.to_cstring(vm)?;\n            let column = args.column.to_cstring(vm)?;\n            let name = args.name.to_cstring(vm)?;\n\n            let db = zelf.db_lock(vm)?;\n\n            let mut blob = null_mut();\n            let ret = unsafe {\n                sqlite3_blob_open(\n                    db.db,\n                    name.as_ptr(),\n                    table.as_ptr(),\n                    column.as_ptr(),\n                    args.row,\n                    (!args.readonly) as c_int,\n                    &mut blob,\n                )\n            };\n            db.check(ret, vm)?;\n            drop(db);\n\n            let blob = SqliteBlob { blob };\n            let blob = Blob {\n                connection: zelf,\n                inner: PyMutex::new(Some(BlobInner { blob, offset: 0 })),\n            };\n            Ok(blob.into_ref(&vm.ctx))\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.check_thread(vm)?;\n            self.db.lock().take();\n            Ok(())\n        }\n\n        #[pymethod]\n        fn commit(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.db_lock(vm)?.implicit_commit(vm)\n        }\n\n        #[pymethod]\n        fn rollback(&self, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            if !db.is_autocommit() {\n                db._exec(b\"ROLLBACK\\0\", vm)\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::execute(cursor, sql, parameters, vm)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::executemany(cursor, sql, seq_of_params, vm)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            Cursor::executescript(\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx),\n                script,\n                vm,\n            )\n        }\n\n        // TODO: Make it build without clippy::manual_c_str_literals\n        #[pymethod]\n        #[allow(clippy::manual_c_str_literals)]\n        fn backup(zelf: &Py<Self>, args: BackupArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let BackupArgs {\n                target,\n                pages,\n                progress,\n                name,\n                sleep,\n            } = args;\n            if zelf.is(&target) {\n                return Err(vm.new_value_error(\"target cannot be the same connection instance\"));\n            }\n\n            let pages = if pages == 0 { -1 } else { pages };\n\n            let name_cstring;\n            let name_ptr = if let Some(name) = &name {\n                name_cstring = name.to_cstring(vm)?;\n                name_cstring.as_ptr()\n            } else {\n                b\"main\\0\".as_ptr().cast()\n            };\n\n            let sleep_ms = (sleep * 1000.0) as c_int;\n\n            let db = zelf.db_lock(vm)?;\n            let target_db = target.db_lock(vm)?;\n\n            let handle = unsafe {\n                sqlite3_backup_init(target_db.db, b\"main\\0\".as_ptr().cast(), db.db, name_ptr)\n            };\n\n            if handle.is_null() {\n                return Err(target_db.error_extended(vm));\n            }\n\n            drop(db);\n            drop(target_db);\n\n            loop {\n                let ret = unsafe { sqlite3_backup_step(handle, pages) };\n\n                if let Some(progress) = &progress {\n                    let remaining = unsafe { sqlite3_backup_remaining(handle) };\n                    let pagecount = unsafe { sqlite3_backup_pagecount(handle) };\n                    if let Err(err) = progress.invoke((ret, remaining, pagecount), vm) {\n                        unsafe { sqlite3_backup_finish(handle) };\n                        return Err(err);\n                    }\n                }\n\n                if ret == SQLITE_BUSY || ret == SQLITE_LOCKED {\n                    unsafe { sqlite3_sleep(sleep_ms) };\n                } else if ret != SQLITE_OK {\n                    break;\n                }\n            }\n\n            let ret = unsafe { sqlite3_backup_finish(handle) };\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(target.db_lock(vm)?.error_extended(vm))\n            }\n        }\n\n        #[pymethod]\n        fn create_function(&self, args: CreateFunctionArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let flags = if args.deterministic {\n                SQLITE_UTF8 | SQLITE_DETERMINISTIC\n            } else {\n                SQLITE_UTF8\n            };\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.func, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    flags,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                flags,\n                Box::into_raw(Box::new(data)).cast(),\n                Some(CallbackData::func_callback),\n                None,\n                None,\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_aggregate(&self, args: CreateAggregateArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.aggregate_class, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    SQLITE_UTF8,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                SQLITE_UTF8,\n                Box::into_raw(Box::new(data)).cast(),\n                None,\n                Some(CallbackData::step_callback),\n                Some(CallbackData::finalize_callback),\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_collation(\n            &self,\n            name: PyUtf8StrRef,\n            callable: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable.clone(), vm) else {\n                unsafe {\n                    sqlite3_create_collation_v2(\n                        db.db,\n                        name.as_ptr(),\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                    );\n                }\n                return Ok(());\n            };\n            let data = Box::into_raw(Box::new(data));\n\n            if !callable.is_callable() {\n                return Err(vm.new_type_error(\"parameter must be callable\"));\n            }\n\n            let ret = unsafe {\n                sqlite3_create_collation_v2(\n                    db.db,\n                    name.as_ptr(),\n                    SQLITE_UTF8,\n                    data.cast(),\n                    Some(CallbackData::collation_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n\n            db.check(ret, vm).inspect_err(|_| {\n                // create_collation do not call destructor if error occur\n                let _ = unsafe { Box::from_raw(data) };\n            })\n        }\n\n        #[pymethod]\n        fn create_window_function(\n            &self,\n            name: PyStrRef,\n            narg: c_int,\n            aggregate_class: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(aggregate_class, vm) else {\n                unsafe {\n                    sqlite3_create_window_function(\n                        db.db,\n                        name.as_ptr(),\n                        narg,\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                        None,\n                        None,\n                        None,\n                    )\n                };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_create_window_function(\n                    db.db,\n                    name.as_ptr(),\n                    narg,\n                    SQLITE_UTF8,\n                    Box::into_raw(Box::new(data)).cast(),\n                    Some(CallbackData::step_callback),\n                    Some(CallbackData::finalize_callback),\n                    Some(CallbackData::value_callback),\n                    Some(CallbackData::inverse_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n            db.check(ret, vm)\n                .map_err(|_| new_programming_error(vm, \"Error creating window function\".to_owned()))\n        }\n\n        #[pymethod]\n        fn set_authorizer(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_set_authorizer(db.db, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_set_authorizer(\n                    db.db,\n                    Some(CallbackData::authorizer_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n            db.check(ret, vm).map_err(|_| {\n                new_operational_error(vm, \"Error setting authorizer callback\".to_owned())\n            })\n        }\n\n        #[pymethod]\n        fn set_trace_callback(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_trace_v2(db.db, SQLITE_TRACE_STMT as u32, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_trace_v2(\n                    db.db,\n                    SQLITE_TRACE_STMT as u32,\n                    Some(CallbackData::trace_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            db.check(ret, vm)\n        }\n\n        #[pymethod]\n        fn set_progress_handler(\n            &self,\n            callable: PyObjectRef,\n            n: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_progress_handler(db.db, n, None, null_mut()) };\n                return Ok(());\n            };\n\n            unsafe {\n                sqlite3_progress_handler(\n                    db.db,\n                    n,\n                    Some(CallbackData::progress_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            Ok(())\n        }\n\n        #[pymethod]\n        fn iterdump(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            let module = vm.import(\"sqlite3.dump\", 0)?;\n            let func = module.get_attr(\"_iterdump\", vm)?;\n            func.call((zelf,), vm)\n        }\n\n        #[pymethod]\n        fn interrupt(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // DO NOT check thread safety\n            self._db_lock(vm).map(|x| x.interrupt())\n        }\n\n        #[pymethod]\n        fn getlimit(&self, category: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, -1, vm)\n        }\n\n        #[pymethod]\n        fn setlimit(&self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, limit, vm)\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>) -> PyRef<Self> {\n            zelf\n        }\n\n        #[pymethod]\n        fn __exit__(\n            &self,\n            cls: PyObjectRef,\n            exc: PyObjectRef,\n            tb: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            if vm.is_none(&cls) && vm.is_none(&exc) && vm.is_none(&tb) {\n                self.commit(vm)\n            } else {\n                self.rollback(vm)\n            }\n        }\n\n        #[pygetset]\n        fn isolation_level(&self) -> Option<PyStrRef> {\n            self.isolation_level.deref().map(|x| x.to_owned())\n        }\n        #[pygetset(setter)]\n        fn set_isolation_level(\n            &self,\n            value: PySetterValue<Option<PyStrRef>>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            match value {\n                PySetterValue::Assign(value) => {\n                    if let Some(val_str) = &value {\n                        begin_statement_ptr_from_isolation_level(val_str, vm)?;\n                    }\n\n                    // If setting isolation_level to None (auto-commit mode), commit any pending transaction\n                    if value.is_none() {\n                        let db = self.db_lock(vm)?;\n                        if !db.is_autocommit() {\n                            // Keep the lock and call implicit_commit directly to avoid race conditions\n                            db.implicit_commit(vm)?;\n                        }\n                    }\n                    let _ = unsafe { self.isolation_level.swap(value) };\n                    Ok(())\n                }\n                PySetterValue::Delete => Err(vm.new_attribute_error(\n                    \"'isolation_level' attribute cannot be deleted\".to_owned(),\n                )),\n            }\n        }\n\n        #[pygetset]\n        fn text_factory(&self) -> PyObjectRef {\n            self.text_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_text_factory(&self, val: PyObjectRef) {\n            let _ = unsafe { self.text_factory.swap(val) };\n        }\n\n        #[pygetset]\n        fn row_factory(&self) -> Option<PyObjectRef> {\n            self.row_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_row_factory(&self, val: Option<PyObjectRef>) {\n            let _ = unsafe { self.row_factory.swap(val) };\n        }\n\n        fn check_thread(&self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.check_same_thread && (std::thread::current().id() != self.thread_ident) {\n                Err(new_programming_error(\n                    vm,\n                    \"SQLite objects created in a thread can only be used in that same thread.\"\n                        .to_owned(),\n                ))\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pygetset]\n        fn in_transaction(&self, vm: &VirtualMachine) -> PyResult<bool> {\n            self._db_lock(vm).map(|x| !x.is_autocommit())\n        }\n\n        #[pygetset]\n        fn total_changes(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self._db_lock(vm).map(|x| x.total_changes())\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Cursor {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        arraysize: PyAtomic<c_int>,\n        #[pytraverse(skip)]\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        inner: PyMutex<Option<CursorInner>>,\n    }\n\n    #[derive(Debug, Traverse)]\n    struct CursorInner {\n        description: Option<PyTupleRef>,\n        row_cast_map: Vec<Option<PyObjectRef>>,\n        #[pytraverse(skip)]\n        lastrowid: i64,\n        #[pytraverse(skip)]\n        rowcount: i64,\n        statement: Option<PyRef<Statement>>,\n        #[pytraverse(skip)]\n        closed: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct FetchManyArgs {\n        #[pyarg(any, name = \"size\", optional)]\n        size: Option<c_int>,\n    }\n\n    #[pyclass(with(Constructor, IterNext, Iterable), flags(BASETYPE))]\n    impl Cursor {\n        fn new(\n            connection: PyRef<Connection>,\n            row_factory: Option<PyObjectRef>,\n            _vm: &VirtualMachine,\n        ) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(row_factory),\n                inner: PyMutex::from(Some(CursorInner {\n                    description: None,\n                    row_cast_map: vec![],\n                    lastrowid: -1,\n                    rowcount: -1,\n                    statement: None,\n                    closed: false,\n                })),\n            }\n        }\n\n        fn new_uninitialized(connection: PyRef<Connection>, _vm: &VirtualMachine) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(None),\n                inner: PyMutex::from(None),\n            }\n        }\n\n        #[pymethod]\n        fn __init__(&self, _connection: PyRef<Connection>, _vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = self.inner.lock();\n            if guard.is_some() {\n                // Already initialized (e.g., from a call to super().__init__)\n                return Ok(());\n            }\n            *guard = Some(CursorInner {\n                description: None,\n                row_cast_map: vec![],\n                lastrowid: -1,\n                rowcount: -1,\n                statement: None,\n                closed: false,\n            });\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, CursorInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                let inner_guard =\n                    PyMutexGuard::map(guard, |x| unsafe { x.as_mut().unwrap_unchecked() });\n                if inner_guard.closed {\n                    return Err(new_programming_error(\n                        vm,\n                        \"Cannot operate on a closed cursor.\".to_owned(),\n                    ));\n                }\n                Ok(inner_guard)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let st = stmt.lock();\n            let params_needed = st.bind_parameter_count();\n\n            if let OptionalArg::Present(parameters) = parameters {\n                st.bind_parameters(&parameters, vm)?;\n            } else if params_needed > 0 {\n                let msg = format!(\n                    \"Incorrect number of bindings supplied. The current statement uses {}, and 0 were supplied.\",\n                    params_needed\n                );\n                return Err(new_programming_error(vm, msg));\n            }\n\n            let ret = st.step();\n\n            if ret != SQLITE_DONE && ret != SQLITE_ROW {\n                if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                    return Err(exc);\n                }\n                return Err(db.error_extended(vm));\n            }\n\n            inner.row_cast_map = zelf.build_row_cast_map(&st, vm)?;\n\n            inner.description = st.columns_description(zelf.connection.detect_types, vm)?;\n\n            if ret == SQLITE_ROW {\n                drop(st);\n                inner.statement = Some(stmt);\n            } else {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount += db.changes() as i64;\n                }\n            }\n\n            inner.lastrowid = db.lastrowid();\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            let st = stmt.lock();\n\n            if st.readonly() {\n                return Err(new_programming_error(\n                    vm,\n                    \"executemany() can only execute DML statements.\".to_owned(),\n                ));\n            }\n\n            inner.description = st.columns_description(zelf.connection.detect_types, vm)?;\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let iter = seq_of_params.iter(vm)?;\n            for params in iter {\n                let params = params?;\n                st.bind_parameters(&params, vm)?;\n\n                if !st.step_row_else_done(vm)? {\n                    if stmt.is_dml {\n                        inner.rowcount += db.changes() as i64;\n                    }\n                    st.reset();\n                }\n\n                // if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                //     return Err(exc);\n                // }\n            }\n\n            if st.busy() {\n                drop(st);\n                inner.statement = Some(stmt);\n            }\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let db = zelf.connection.db_lock(vm)?;\n\n            db.sql_limit(script.byte_len(), vm)?;\n\n            db.implicit_commit(vm)?;\n\n            let script = script.to_cstring(vm)?;\n            let mut ptr = script.as_ptr();\n\n            while let Some(st) = db.prepare(ptr, &mut ptr, vm)? {\n                while st.step_row_else_done(vm)? {}\n            }\n\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn fetchone(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult {\n            Self::next(zelf, vm).map(|x| match x {\n                PyIterReturn::Return(row) => row,\n                PyIterReturn::StopIteration(_) => vm.ctx.none(),\n            })\n        }\n\n        #[pymethod]\n        fn fetchmany(\n            zelf: &Py<Self>,\n            args: FetchManyArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<PyObjectRef>> {\n            let max_rows = args\n                .size\n                .unwrap_or_else(|| zelf.arraysize.load(Ordering::Relaxed));\n\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Cursor::next(zelf, vm)? {\n                list.push(row);\n                if max_rows > 0 && list.len() as c_int >= max_rows {\n                    break;\n                }\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn fetchall(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Self::next(zelf, vm)? {\n                list.push(row);\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // Check if __init__ was called\n            let mut guard = self.inner.lock();\n            if guard.is_none() {\n                return Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ));\n            }\n\n            if let Some(inner) = guard.as_mut() {\n                if let Some(stmt) = &inner.statement {\n                    stmt.lock().reset();\n                }\n                inner.closed = true;\n            }\n            Ok(())\n        }\n\n        #[pymethod]\n        fn setinputsizes(&self, _sizes: PyObjectRef) {}\n        #[pymethod]\n        fn setoutputsize(&self, _size: PyObjectRef, _column: OptionalArg<PyObjectRef>) {}\n\n        #[pygetset]\n        fn connection(&self) -> PyRef<Connection> {\n            self.connection.clone()\n        }\n\n        #[pygetset]\n        fn lastrowid(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.lastrowid)\n        }\n\n        #[pygetset]\n        fn rowcount(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.rowcount)\n        }\n\n        #[pygetset]\n        fn description(&self, vm: &VirtualMachine) -> PyResult<Option<PyTupleRef>> {\n            self.inner(vm).map(|x| x.description.clone())\n        }\n\n        #[pygetset]\n        fn arraysize(&self) -> c_int {\n            self.arraysize.load(Ordering::Relaxed)\n        }\n        #[pygetset(setter)]\n        fn set_arraysize(&self, val: c_int) {\n            self.arraysize.store(val, Ordering::Relaxed);\n        }\n\n        fn build_row_cast_map(\n            &self,\n            st: &SqliteStatementRaw,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<Option<PyObjectRef>>> {\n            if self.connection.detect_types == 0 {\n                return Ok(vec![]);\n            }\n\n            let mut cast_map = vec![];\n            let num_cols = st.column_count();\n\n            for i in 0..num_cols {\n                if self.connection.detect_types & PARSE_COLNAMES != 0 {\n                    let col_name = st.column_name(i);\n                    let col_name = ptr_to_str(col_name, vm)?;\n                    let col_name = col_name\n                        .chars()\n                        .skip_while(|&x| x != '[')\n                        .skip(1)\n                        .take_while(|&x| x != ']')\n                        .flat_map(|x| x.to_uppercase())\n                        .collect::<String>();\n                    if let Some(converter) = converters().get_item_opt(&col_name, vm)? {\n                        cast_map.push(Some(converter.clone()));\n                        continue;\n                    }\n                }\n                if self.connection.detect_types & PARSE_DECLTYPES != 0 {\n                    let decltype = st.column_decltype(i);\n                    let decltype = ptr_to_str(decltype, vm)?;\n                    if let Some(decltype) = decltype.split_terminator(&[' ', '(']).next() {\n                        let decltype = decltype.to_uppercase();\n                        if let Some(converter) = converters().get_item_opt(&decltype, vm)? {\n                            cast_map.push(Some(converter.clone()));\n                            continue;\n                        }\n                    }\n                }\n                cast_map.push(None);\n            }\n\n            Ok(cast_map)\n        }\n    }\n\n    impl Constructor for Cursor {\n        type Args = (PyRef<Connection>,);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            Self::new_uninitialized(args.0, vm)\n                .into_ref_with_type(vm, cls)\n                .map(Into::into)\n        }\n    }\n\n    impl SelfIter for Cursor {}\n    impl IterNext for Cursor {\n        fn next(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyIterReturn> {\n            let mut inner = zelf.inner(vm)?;\n            let Some(stmt) = &inner.statement else {\n                return Ok(PyIterReturn::StopIteration(None));\n            };\n            let st = stmt.lock();\n            let db = zelf.connection.db_lock(vm)?;\n            // fetch_one_row\n\n            let num_cols = st.data_count();\n\n            let mut row = Vec::with_capacity(num_cols as usize);\n\n            for i in 0..num_cols {\n                let val = if let Some(converter) =\n                    inner.row_cast_map.get(i as usize).cloned().flatten()\n                {\n                    let blob = st.column_blob(i);\n                    if blob.is_null() {\n                        vm.ctx.none()\n                    } else {\n                        let nbytes = st.column_bytes(i);\n                        let blob = unsafe {\n                            std::slice::from_raw_parts(blob.cast::<u8>(), nbytes as usize)\n                        };\n                        let blob = vm.ctx.new_bytes(blob.to_vec());\n                        converter.call((blob,), vm)?\n                    }\n                } else {\n                    let col_type = st.column_type(i);\n                    match col_type {\n                        SQLITE_NULL => vm.ctx.none(),\n                        SQLITE_INTEGER => vm.ctx.new_int(st.column_int(i)).into(),\n                        SQLITE_FLOAT => vm.ctx.new_float(st.column_double(i)).into(),\n                        SQLITE_TEXT => {\n                            let text =\n                                ptr_to_vec(st.column_text(i), st.column_bytes(i), db.db, vm)?;\n\n                            let text_factory = zelf.connection.text_factory.to_owned();\n\n                            if text_factory.is(PyStr::class(&vm.ctx)) {\n                                let text = String::from_utf8(text).map_err(|err| {\n                                    let col_name = st.column_name(i);\n                                    let col_name_str = ptr_to_str(col_name, vm).unwrap_or(\"?\");\n                                    let valid_up_to = err.utf8_error().valid_up_to();\n                                    let text_prefix = String::from_utf8_lossy(&err.as_bytes()[..valid_up_to]);\n                                    let msg = format!(\n                                        \"Could not decode to UTF-8 column '{col_name_str}' with text '{text_prefix}'\"\n                                    );\n                                    new_operational_error(vm, msg)\n                                })?;\n                                vm.ctx.new_str(text).into()\n                            } else if text_factory.is(PyBytes::class(&vm.ctx)) {\n                                vm.ctx.new_bytes(text).into()\n                            } else if text_factory.is(PyByteArray::class(&vm.ctx)) {\n                                PyByteArray::from(text).into_ref(&vm.ctx).into()\n                            } else {\n                                let bytes = vm.ctx.new_bytes(text);\n                                text_factory.call((bytes,), vm)?\n                            }\n                        }\n                        SQLITE_BLOB => {\n                            let blob = ptr_to_vec(\n                                st.column_blob(i).cast(),\n                                st.column_bytes(i),\n                                db.db,\n                                vm,\n                            )?;\n\n                            vm.ctx.new_bytes(blob).into()\n                        }\n                        _ => {\n                            return Err(vm.new_not_implemented_error(format!(\n                                \"unknown column type: {col_type}\"\n                            )));\n                        }\n                    }\n                };\n\n                row.push(val);\n            }\n\n            if !st.step_row_else_done(vm)? {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount = db.changes() as i64;\n                }\n                inner.statement = None;\n            } else {\n                drop(st);\n            }\n\n            drop(db);\n            drop(inner);\n\n            let row = vm.ctx.new_tuple(row);\n\n            if let Some(row_factory) = zelf.row_factory.to_owned() {\n                row_factory\n                    .call((zelf.to_owned(), row), vm)\n                    .map(PyIterReturn::Return)\n            } else {\n                Ok(PyIterReturn::Return(row.into()))\n            }\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Row {\n        data: PyTupleRef,\n        description: PyTupleRef,\n    }\n\n    #[pyclass(\n        with(Constructor, Hashable, Comparable, Iterable, AsMapping, AsSequence),\n        flags(BASETYPE)\n    )]\n    impl Row {\n        #[pymethod]\n        fn keys(&self, _vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            Ok(self\n                .description\n                .iter()\n                .map(|x| x.downcast_ref::<PyTuple>().unwrap().as_slice()[0].clone())\n                .collect())\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            if let Some(i) = needle.downcast_ref::<PyInt>() {\n                let i = i.try_to_primitive::<isize>(vm)?;\n                self.data.getitem_by_index(vm, i)\n            } else if let Some(name) = needle.downcast_ref::<PyStr>() {\n                for (obj, i) in self.description.iter().zip(0..) {\n                    let obj = &obj.downcast_ref::<PyTuple>().unwrap().as_slice()[0];\n                    let Some(obj) = obj.downcast_ref::<PyStr>() else {\n                        break;\n                    };\n                    let a_iter = name.as_str().chars().flat_map(|x| x.to_uppercase());\n                    let b_iter = obj.as_str().chars().flat_map(|x| x.to_uppercase());\n\n                    if a_iter.eq(b_iter) {\n                        return self.data.getitem_by_index(vm, i);\n                    }\n                }\n                Err(vm.new_index_error(\"No item with that key\"))\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let list = self.data.getitem_by_slice(vm, slice.to_saturated(vm)?)?;\n                Ok(vm.ctx.new_tuple(list).into())\n            } else {\n                Err(vm.new_index_error(\"Index must be int or string\"))\n            }\n        }\n    }\n\n    impl Constructor for Row {\n        type Args = (PyRef<Cursor>, PyTupleRef);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let description = args\n                .0\n                .inner(vm)?\n                .description\n                .clone()\n                .ok_or_else(|| vm.new_value_error(\"no description in Cursor\"))?;\n\n            Self {\n                data: args.1,\n                description,\n            }\n            .into_ref_with_type(vm, cls)\n            .map(Into::into)\n        }\n    }\n\n    impl Hashable for Row {\n        fn hash(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyHash> {\n            Ok(zelf.description.as_object().hash(vm)? | zelf.data.as_object().hash(vm)?)\n        }\n    }\n\n    impl Comparable for Row {\n        fn cmp(\n            zelf: &Py<Self>,\n            other: &PyObject,\n            op: PyComparisonOp,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyComparisonValue> {\n            op.eq_only(|| {\n                if let Some(other) = other.downcast_ref::<Self>() {\n                    let eq = vm\n                        .bool_eq(zelf.description.as_object(), other.description.as_object())?\n                        && vm.bool_eq(zelf.data.as_object(), other.data.as_object())?;\n                    Ok(eq.into())\n                } else {\n                    Ok(PyComparisonValue::NotImplemented)\n                }\n            })\n        }\n    }\n\n    impl Iterable for Row {\n        fn iter(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            Iterable::iter(zelf.data.clone(), vm)\n        }\n    }\n\n    impl AsMapping for Row {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: std::sync::LazyLock<PyMappingMethods> =\n                std::sync::LazyLock::new(|| PyMappingMethods {\n                    length: atomic_func!(|mapping, _vm| Ok(Row::mapping_downcast(mapping)\n                        .data\n                        .len())),\n                    subscript: atomic_func!(|mapping, needle, vm| {\n                        Row::mapping_downcast(mapping).subscript(needle, vm)\n                    }),\n                    ..PyMappingMethods::NOT_IMPLEMENTED\n                });\n            &AS_MAPPING\n        }\n    }\n\n    impl AsSequence for Row {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: std::sync::LazyLock<PySequenceMethods> =\n                std::sync::LazyLock::new(|| PySequenceMethods {\n                    length: atomic_func!(|seq, _vm| Ok(Row::sequence_downcast(seq).data.len())),\n                    item: atomic_func!(|seq, i, vm| Row::sequence_downcast(seq)\n                        .data\n                        .getitem_by_index(vm, i)),\n                    ..PySequenceMethods::NOT_IMPLEMENTED\n                });\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Blob\", traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Blob {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        inner: PyMutex<Option<BlobInner>>,\n    }\n\n    impl Unconstructible for Blob {}\n\n    #[derive(Debug)]\n    struct BlobInner {\n        blob: SqliteBlob,\n        offset: c_int,\n    }\n\n    impl Drop for BlobInner {\n        fn drop(&mut self) {\n            unsafe { sqlite3_blob_close(self.blob.blob) };\n        }\n    }\n\n    #[pyclass(with(AsMapping, Unconstructible, AsNumber, AsSequence))]\n    impl Blob {\n        #[pymethod]\n        fn close(&self) {\n            self.inner.lock().take();\n        }\n\n        #[pymethod]\n        fn read(\n            &self,\n            length: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<PyBytes>> {\n            let mut length = length.unwrap_or(-1);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let max_read = blob_len - inner.offset;\n\n            if length < 0 || length > max_read {\n                length = max_read;\n            }\n\n            if length == 0 {\n                Ok(vm.ctx.empty_bytes.clone())\n            } else {\n                let mut buf = Vec::<u8>::with_capacity(length as usize);\n                let ret = inner\n                    .blob\n                    .read(buf.as_mut_ptr().cast(), length, inner.offset);\n                self.check(ret, vm)?;\n                unsafe { buf.set_len(length as usize) };\n                inner.offset += length;\n                Ok(vm.ctx.new_bytes(buf))\n            }\n        }\n\n        #[pymethod]\n        fn write(&self, data: PyBuffer, vm: &VirtualMachine) -> PyResult<()> {\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let length = Self::expect_write(blob_len, data.desc.len, inner.offset, vm)?;\n\n            let ret = data.contiguous_or_collect(|buf| {\n                inner.blob.write(buf.as_ptr().cast(), length, inner.offset)\n            });\n\n            self.check(ret, vm)?;\n            inner.offset += length;\n            Ok(())\n        }\n\n        #[pymethod]\n        fn tell(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.inner(vm).map(|x| x.offset)\n        }\n\n        #[pymethod]\n        fn seek(\n            &self,\n            mut offset: c_int,\n            origin: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let origin = origin.unwrap_or(libc::SEEK_SET);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n\n            let overflow_err = || vm.new_overflow_error(\"seek offset results in overflow\");\n\n            match origin {\n                libc::SEEK_SET => {}\n                libc::SEEK_CUR => {\n                    offset = offset.checked_add(inner.offset).ok_or_else(overflow_err)?\n                }\n                libc::SEEK_END => offset = offset.checked_add(blob_len).ok_or_else(overflow_err)?,\n                _ => {\n                    return Err(vm.new_value_error(\n                        \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\",\n                    ));\n                }\n            }\n\n            if offset < 0 || offset > blob_len {\n                Err(vm.new_value_error(\"offset out of blob range\"))\n            } else {\n                inner.offset = offset;\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult<PyRef<Self>> {\n            let _ = zelf.inner(vm)?;\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn __exit__(&self, _args: FuncArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let _ = self.inner(vm)?;\n            self.close();\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, BlobInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Cannot operate on a closed blob.\".to_owned(),\n                ))\n            }\n        }\n\n        fn wrapped_index(index: PyIntRef, length: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let mut index = index.try_to_primitive::<c_int>(vm)?;\n            if index < 0 {\n                index += length;\n            }\n            if index < 0 || index >= length {\n                Err(vm.new_index_error(\"Blob index out of range\"))\n            } else {\n                Ok(index)\n            }\n        }\n\n        fn expect_write(\n            blob_len: c_int,\n            length: usize,\n            offset: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<c_int> {\n            let max_write = blob_len - offset;\n            if length <= max_write as usize {\n                Ok(length as c_int)\n            } else {\n                Err(vm.new_value_error(\"data longer than blob length\"))\n            }\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            let inner = self.inner(vm)?;\n            if let Some(index) = needle.try_index_opt(vm) {\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                let mut byte: u8 = 0;\n                let ret = inner.blob.read_single(&mut byte, index);\n                self.check(ret, vm).map(|_| vm.ctx.new_int(byte).into())\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, length) = slice.adjust_indices(blob_len as usize);\n                let mut buf = Vec::<u8>::with_capacity(length);\n\n                if step == 1 {\n                    let ret = inner.blob.read(\n                        buf.as_mut_ptr().cast(),\n                        length as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n                    unsafe { buf.set_len(length) };\n                } else {\n                    let iter = SaturatedSliceIter::from_adjust_indices(range, step, length);\n                    let mut byte: u8 = 0;\n                    for index in iter {\n                        let ret = inner.blob.read_single(&mut byte, index as c_int);\n                        self.check(ret, vm)?;\n                        buf.push(byte);\n                    }\n                }\n                Ok(vm.ctx.new_bytes(buf).into())\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn ass_subscript(\n            &self,\n            needle: &PyObject,\n            value: Option<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(value) = value else {\n                return Err(vm.new_type_error(\"Blob doesn't support slice deletion\"));\n            };\n            let inner = self.inner(vm)?;\n\n            if let Some(index) = needle.try_index_opt(vm) {\n                // Handle single item assignment: blob[i] = b\n                let Some(value) = value.downcast_ref::<PyInt>() else {\n                    return Err(vm.new_type_error(format!(\n                        \"'{}' object cannot be interpreted as an integer\",\n                        value.class()\n                    )));\n                };\n                let value = value.try_to_primitive::<u8>(vm)?;\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                Self::expect_write(blob_len, 1, index, vm)?;\n                let ret = inner.blob.write_single(value, index);\n                self.check(ret, vm)\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                // Handle slice assignment: blob[a:b:c] = b\"...\"\n                let value_buf = PyBuffer::try_from_borrowed_object(vm, &value)?;\n\n                let buf = value_buf\n                    .as_contiguous()\n                    .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, slice_len) = slice.adjust_indices(blob_len as usize);\n\n                if step == 0 {\n                    return Err(vm.new_value_error(\"slice step cannot be zero\"));\n                }\n\n                if buf.len() != slice_len {\n                    return Err(vm.new_index_error(\"Blob slice assignment is wrong size\"));\n                }\n\n                if slice_len == 0 {\n                    return Ok(());\n                }\n\n                if step == 1 {\n                    let ret = inner.blob.write(\n                        buf.as_ptr().cast(),\n                        buf.len() as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                } else {\n                    let span_len = range.end - range.start;\n                    let mut temp_buf = vec![0u8; span_len];\n\n                    let ret = inner.blob.read(\n                        temp_buf.as_mut_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n\n                    let mut i_in_temp: usize = 0;\n                    for i_in_src in 0..slice_len {\n                        temp_buf[i_in_temp] = buf[i_in_src];\n                        i_in_temp += step as usize;\n                    }\n\n                    let ret = inner.blob.write(\n                        temp_buf.as_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                }\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn check(&self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.connection.db_lock(vm)?.error_extended(vm))\n            }\n        }\n    }\n\n    impl AsMapping for Blob {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: PyMappingMethods = PyMappingMethods {\n                length: atomic_func!(|mapping, vm| Blob::mapping_downcast(mapping)\n                    .inner(vm)\n                    .map(|x| x.blob.bytes() as usize)),\n                subscript: atomic_func!(|mapping, needle, vm| {\n                    Blob::mapping_downcast(mapping).subscript(needle, vm)\n                }),\n                ass_subscript: atomic_func!(|mapping, needle, value, vm| {\n                    Blob::mapping_downcast(mapping).ass_subscript(needle, value, vm)\n                }),\n            };\n            &AS_MAPPING\n        }\n    }\n\n    impl AsNumber for Blob {\n        fn as_number() -> &'static PyNumberMethods {\n            static AS_NUMBER: PyNumberMethods = PyNumberMethods {\n                add: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for +: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                multiply: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for *: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                ..PyNumberMethods::NOT_IMPLEMENTED\n            };\n            &AS_NUMBER\n        }\n    }\n\n    impl AsSequence for Blob {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: PySequenceMethods = PySequenceMethods {\n                length: AtomicCell::new(None),\n                concat: AtomicCell::new(None),\n                repeat: AtomicCell::new(None),\n                item: AtomicCell::new(None),\n                ass_item: AtomicCell::new(None),\n                contains: atomic_func!(|seq, _needle, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"argument of type '{}' is not iterable\",\n                        seq.obj.class().name(),\n                    )))\n                }),\n                inplace_concat: AtomicCell::new(None),\n                inplace_repeat: AtomicCell::new(None),\n            };\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(Debug, PyPayload)]\n    struct PrepareProtocol {}\n\n    #[pyclass()]\n    impl PrepareProtocol {}\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Statement\")]\n    #[derive(PyPayload)]\n    struct Statement {\n        st: PyMutex<SqliteStatement>,\n        pub is_dml: bool,\n    }\n\n    impl Debug for Statement {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(\n                f,\n                \"{} Statement\",\n                if self.is_dml { \"DML\" } else { \"Non-DML\" }\n            )\n        }\n    }\n\n    impl Unconstructible for Statement {}\n\n    #[pyclass(with(Unconstructible))]\n    impl Statement {\n        fn new(\n            connection: &Connection,\n            sql: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<Self>> {\n            if sql.as_str().contains('\\0') {\n                return Err(new_programming_error(\n                    vm,\n                    \"statement contains a null character.\".to_owned(),\n                ));\n            }\n            let sql_cstr = sql.to_cstring(vm)?;\n\n            let db = connection.db_lock(vm)?;\n\n            db.sql_limit(sql.byte_len(), vm)?;\n\n            let mut tail = null();\n            let st = db.prepare(sql_cstr.as_ptr(), &mut tail, vm)?;\n\n            let Some(st) = st else {\n                return Ok(None);\n            };\n\n            let tail = unsafe { CStr::from_ptr(tail) };\n            let tail = tail.to_bytes();\n            if lstrip_sql(tail).is_some() {\n                return Err(new_programming_error(\n                    vm,\n                    \"You can only execute one statement at a time.\".to_owned(),\n                ));\n            }\n\n            let is_dml = if let Some(head) = lstrip_sql(sql_cstr.as_bytes()) {\n                head.len() >= 6\n                    && (head[..6].eq_ignore_ascii_case(b\"insert\")\n                        || head[..6].eq_ignore_ascii_case(b\"update\")\n                        || head[..6].eq_ignore_ascii_case(b\"delete\")\n                        || (head.len() >= 7 && head[..7].eq_ignore_ascii_case(b\"replace\")))\n            } else {\n                false\n            };\n\n            Ok(Some(Self {\n                st: PyMutex::from(st),\n                is_dml,\n            }))\n        }\n\n        fn lock(&self) -> PyMutexGuard<'_, SqliteStatement> {\n            self.st.lock()\n        }\n    }\n\n    struct Sqlite {\n        raw: SqliteRaw,\n    }\n\n    impl From<SqliteRaw> for Sqlite {\n        fn from(raw: SqliteRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for Sqlite {\n        fn drop(&mut self) {\n            unsafe { sqlite3_close_v2(self.raw.db) };\n        }\n    }\n\n    impl Deref for Sqlite {\n        type Target = SqliteRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteRaw {\n        db: *mut sqlite3,\n    }\n\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"threading\")] {\n            unsafe impl Send for SqliteStatement {}\n            // unsafe impl Sync for SqliteStatement {}\n            unsafe impl Send for Sqlite {}\n            // unsafe impl Sync for Sqlite {}\n            unsafe impl Send for SqliteBlob {}\n        }\n    }\n\n    impl From<SqliteStatementRaw> for SqliteRaw {\n        fn from(stmt: SqliteStatementRaw) -> Self {\n            unsafe {\n                Self {\n                    db: sqlite3_db_handle(stmt.st),\n                }\n            }\n        }\n    }\n\n    impl SqliteRaw {\n        fn check(self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.error_extended(vm))\n            }\n        }\n\n        fn error_extended(self, vm: &VirtualMachine) -> PyBaseExceptionRef {\n            let errcode = unsafe { sqlite3_errcode(self.db) };\n            let typ = exception_type_from_errcode(errcode, vm);\n            let extended_errcode = unsafe { sqlite3_extended_errcode(self.db) };\n            let errmsg = unsafe { sqlite3_errmsg(self.db) };\n            let errmsg = unsafe { CStr::from_ptr(errmsg) };\n            let errmsg = errmsg.to_str().unwrap().to_owned();\n\n            raise_exception(typ.to_owned(), extended_errcode, errmsg, vm)\n        }\n\n        fn open(path: *const libc::c_char, uri: bool, vm: &VirtualMachine) -> PyResult<Self> {\n            let mut db = null_mut();\n            let ret = unsafe {\n                sqlite3_open_v2(\n                    path,\n                    &raw mut db,\n                    SQLITE_OPEN_READWRITE\n                        | SQLITE_OPEN_CREATE\n                        | if uri { SQLITE_OPEN_URI } else { 0 },\n                    null(),\n                )\n            };\n            let zelf = Self { db };\n            zelf.check(ret, vm).map(|_| zelf)\n        }\n\n        fn _exec(self, sql: &[u8], vm: &VirtualMachine) -> PyResult<()> {\n            let ret =\n                unsafe { sqlite3_exec(self.db, sql.as_ptr().cast(), None, null_mut(), null_mut()) };\n            self.check(ret, vm)\n        }\n\n        fn prepare(\n            self,\n            sql: *const libc::c_char,\n            tail: *mut *const libc::c_char,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<SqliteStatement>> {\n            let mut st = null_mut();\n            let ret = unsafe { sqlite3_prepare_v2(self.db, sql, -1, &mut st, tail) };\n            self.check(ret, vm)?;\n            if st.is_null() {\n                Ok(None)\n            } else {\n                Ok(Some(SqliteStatement::from(SqliteStatementRaw::from(st))))\n            }\n        }\n\n        fn limit(self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let old_limit = unsafe { sqlite3_limit(self.db, category, limit) };\n            if old_limit >= 0 {\n                Ok(old_limit)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"'category' is out of bounds\".to_owned(),\n                ))\n            }\n        }\n\n        fn sql_limit(self, len: usize, vm: &VirtualMachine) -> PyResult<()> {\n            if len <= unsafe { sqlite3_limit(self.db, SQLITE_LIMIT_SQL_LENGTH, -1) } as usize {\n                Ok(())\n            } else {\n                Err(new_data_error(vm, \"query string is too large\".to_owned()))\n            }\n        }\n\n        fn is_autocommit(self) -> bool {\n            unsafe { sqlite3_get_autocommit(self.db) != 0 }\n        }\n\n        fn changes(self) -> c_int {\n            unsafe { sqlite3_changes(self.db) }\n        }\n\n        fn total_changes(self) -> c_int {\n            unsafe { sqlite3_total_changes(self.db) }\n        }\n\n        fn lastrowid(self) -> c_longlong {\n            unsafe { sqlite3_last_insert_rowid(self.db) }\n        }\n\n        fn implicit_commit(self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.is_autocommit() {\n                Ok(())\n            } else {\n                self._exec(b\"COMMIT\\0\", vm)\n            }\n        }\n\n        fn begin_transaction(\n            self,\n            isolation_level: Option<PyStrRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(isolation_level) = isolation_level else {\n                return Ok(());\n            };\n            let mut s = Vec::with_capacity(16);\n            s.extend(b\"BEGIN \");\n            s.extend(isolation_level.as_str().bytes());\n            s.push(b'\\0');\n            self._exec(&s, vm)\n        }\n\n        fn interrupt(self) {\n            unsafe { sqlite3_interrupt(self.db) }\n        }\n\n        fn busy_timeout(self, timeout: i32) {\n            unsafe { sqlite3_busy_timeout(self.db, timeout) };\n        }\n\n        #[allow(clippy::too_many_arguments)]\n        fn create_function(\n            self,\n            name: *const libc::c_char,\n            narg: c_int,\n            flags: c_int,\n            data: *mut c_void,\n            func: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            step: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            finalize: Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n            destroy: Option<unsafe extern \"C\" fn(arg1: *mut c_void)>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let ret = unsafe {\n                sqlite3_create_function_v2(\n                    self.db, name, narg, flags, data, func, step, finalize, destroy,\n                )\n            };\n            self.check(ret, vm)\n                .map_err(|_| new_operational_error(vm, \"Error creating function\".to_owned()))\n        }\n    }\n\n    struct SqliteStatement {\n        raw: SqliteStatementRaw,\n    }\n\n    impl From<SqliteStatementRaw> for SqliteStatement {\n        fn from(raw: SqliteStatementRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for SqliteStatement {\n        fn drop(&mut self) {\n            unsafe {\n                sqlite3_finalize(self.raw.st);\n            }\n        }\n    }\n\n    impl Deref for SqliteStatement {\n        type Target = SqliteStatementRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteStatementRaw {\n        st: *mut sqlite3_stmt,\n    }\n\n    impl From<*mut sqlite3_stmt> for SqliteStatementRaw {\n        fn from(st: *mut sqlite3_stmt) -> Self {\n            SqliteStatementRaw { st }\n        }\n    }\n\n    impl SqliteStatementRaw {\n        fn step(self) -> c_int {\n            unsafe { sqlite3_step(self.st) }\n        }\n\n        fn step_row_else_done(self, vm: &VirtualMachine) -> PyResult<bool> {\n            let ret = self.step();\n\n            if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                Err(exc)\n            } else if ret == SQLITE_ROW {\n                Ok(true)\n            } else if ret == SQLITE_DONE {\n                Ok(false)\n            } else {\n                Err(SqliteRaw::from(self).error_extended(vm))\n            }\n        }\n\n        fn reset(self) {\n            unsafe { sqlite3_reset(self.st) };\n        }\n\n        fn data_count(self) -> c_int {\n            unsafe { sqlite3_data_count(self.st) }\n        }\n\n        fn bind_parameter(\n            self,\n            pos: c_int,\n            parameter: &PyObject,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let adapted;\n            let obj = if need_adapt(parameter, vm) {\n                adapted = _adapt(\n                    parameter,\n                    PrepareProtocol::class(&vm.ctx).to_owned(),\n                    |x| Ok(x.to_owned()),\n                    vm,\n                )?;\n                &adapted\n            } else {\n                parameter\n            };\n\n            let ret = if vm.is_none(obj) {\n                unsafe { sqlite3_bind_null(self.st, pos) }\n            } else if let Some(val) = obj.downcast_ref::<PyInt>() {\n                let val = val.try_to_primitive::<i64>(vm).map_err(|_| {\n                    vm.new_overflow_error(\"Python int too large to convert to SQLite INTEGER\")\n                })?;\n                unsafe { sqlite3_bind_int64(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyFloat>() {\n                let val = val.to_f64();\n                unsafe { sqlite3_bind_double(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyStr>() {\n                let val = val.try_as_utf8(vm)?;\n                let (ptr, len) = str_to_ptr_len(val, vm)?;\n                unsafe { sqlite3_bind_text(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, obj) {\n                let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                unsafe { sqlite3_bind_blob(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Error binding parameter {}: type '{}' is not supported\",\n                        pos,\n                        obj.class()\n                    ),\n                ));\n            };\n\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                let db = SqliteRaw::from(self);\n                db.check(ret, vm)\n            }\n        }\n\n        fn bind_parameters(self, parameters: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            if let Some(dict) = parameters.downcast_ref::<PyDict>() {\n                self.bind_parameters_name(dict, vm)\n            } else if let Ok(seq) = PySequence::try_protocol(parameters, vm) {\n                self.bind_parameters_sequence(seq, vm)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"parameters are of unsupported type\".to_owned(),\n                ))\n            }\n        }\n\n        fn bind_parameters_name(self, dict: &Py<PyDict>, vm: &VirtualMachine) -> PyResult<()> {\n            let num_needed = unsafe { sqlite3_bind_parameter_count(self.st) };\n\n            for i in 1..=num_needed {\n                let name = unsafe { sqlite3_bind_parameter_name(self.st, i) };\n                if name.is_null() {\n                    return Err(new_programming_error(vm, \"Binding {} has no name, but you supplied a dictionary (which has only names).\".to_owned()));\n                }\n                let name = unsafe { name.add(1) };\n                let name = ptr_to_str(name, vm)?;\n\n                let val = match dict.get_item_opt(name, vm)? {\n                    Some(val) => val,\n                    None => {\n                        return Err(new_programming_error(\n                            vm,\n                            format!(\"You did not supply a value for binding parameter :{name}.\",),\n                        ));\n                    }\n                };\n\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn bind_parameter_count(self) -> c_int {\n            unsafe { sqlite3_bind_parameter_count(self.st) }\n        }\n\n        fn bind_parameters_sequence(\n            self,\n            seq: PySequence<'_>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let num_needed = self.bind_parameter_count();\n            let num_supplied = seq.length(vm)?;\n\n            if num_supplied != num_needed as usize {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Incorrect number of bindings supplied. The current statement uses {}, and {} were supplied.\",\n                        num_needed, num_supplied\n                    ),\n                ));\n            }\n\n            for i in 1..=num_needed {\n                let val = seq.get_item(i as isize - 1, vm)?;\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn column_count(self) -> c_int {\n            unsafe { sqlite3_column_count(self.st) }\n        }\n\n        fn column_type(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_type(self.st, pos) }\n        }\n\n        fn column_int(self, pos: c_int) -> i64 {\n            unsafe { sqlite3_column_int64(self.st, pos) }\n        }\n\n        fn column_double(self, pos: c_int) -> f64 {\n            unsafe { sqlite3_column_double(self.st, pos) }\n        }\n\n        fn column_blob(self, pos: c_int) -> *const c_void {\n            unsafe { sqlite3_column_blob(self.st, pos) }\n        }\n\n        fn column_text(self, pos: c_int) -> *const u8 {\n            unsafe { sqlite3_column_text(self.st, pos) }\n        }\n\n        fn column_decltype(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_decltype(self.st, pos) }\n        }\n\n        fn column_bytes(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_bytes(self.st, pos) }\n        }\n\n        fn column_name(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_name(self.st, pos) }\n        }\n\n        fn columns_name(self, detect_types: i32, vm: &VirtualMachine) -> PyResult<Vec<PyStrRef>> {\n            let count = self.column_count();\n            (0..count)\n                .map(|i| {\n                    let name = self.column_name(i);\n                    let name_str = ptr_to_str(name, vm)?;\n\n                    // If PARSE_COLNAMES is enabled, strip everything after the first '[' (and preceding space)\n                    let processed_name = if detect_types & PARSE_COLNAMES != 0\n                        && let Some(bracket_pos) = name_str.find('[')\n                    {\n                        // Check if there's a single space before '[' and remove it (CPython compatibility)\n                        let end_pos = if bracket_pos > 0\n                            && name_str.chars().nth(bracket_pos - 1) == Some(' ')\n                        {\n                            bracket_pos - 1\n                        } else {\n                            bracket_pos\n                        };\n\n                        &name_str[..end_pos]\n                    } else {\n                        name_str\n                    };\n\n                    Ok(vm.ctx.new_str(processed_name))\n                })\n                .collect()\n        }\n\n        fn columns_description(\n            self,\n            detect_types: i32,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<PyTupleRef>> {\n            if self.column_count() == 0 {\n                return Ok(None);\n            }\n            let columns = self\n                .columns_name(detect_types, vm)?\n                .into_iter()\n                .map(|s| {\n                    vm.ctx\n                        .new_tuple(vec![\n                            s.into(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                        ])\n                        .into()\n                })\n                .collect();\n            Ok(Some(vm.ctx.new_tuple(columns)))\n        }\n\n        fn busy(self) -> bool {\n            unsafe { sqlite3_stmt_busy(self.st) != 0 }\n        }\n\n        fn readonly(self) -> bool {\n            unsafe { sqlite3_stmt_readonly(self.st) != 0 }\n        }\n    }\n\n    #[derive(Debug, Copy, Clone)]\n    struct SqliteBlob {\n        blob: *mut sqlite3_blob,\n    }\n\n    impl SqliteBlob {\n        fn bytes(self) -> c_int {\n            unsafe { sqlite3_blob_bytes(self.blob) }\n        }\n\n        fn write(self, buf: *const c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_write(self.blob, buf, length, offset) }\n        }\n\n        fn read(self, buf: *mut c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_read(self.blob, buf, length, offset) }\n        }\n\n        fn read_single(self, byte: &mut u8, offset: c_int) -> c_int {\n            self.read(byte as *mut u8 as *mut _, 1, offset)\n        }\n\n        fn write_single(self, byte: u8, offset: c_int) -> c_int {\n            self.write(&byte as *const u8 as *const _, 1, offset)\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteContext {\n        ctx: *mut sqlite3_context,\n    }\n\n    impl From<*mut sqlite3_context> for SqliteContext {\n        fn from(ctx: *mut sqlite3_context) -> Self {\n            Self { ctx }\n        }\n    }\n\n    impl SqliteContext {\n        fn user_data<T>(self) -> *mut T {\n            unsafe { sqlite3_user_data(self.ctx).cast() }\n        }\n\n        fn aggregate_context<T>(self) -> *mut T {\n            unsafe { sqlite3_aggregate_context(self.ctx, std::mem::size_of::<T>() as c_int).cast() }\n        }\n\n        fn result_exception(self, vm: &VirtualMachine, exc: PyBaseExceptionRef, msg: &str) {\n            if exc.fast_isinstance(vm.ctx.exceptions.memory_error) {\n                unsafe { sqlite3_result_error_nomem(self.ctx) }\n            } else if exc.fast_isinstance(vm.ctx.exceptions.overflow_error) {\n                unsafe { sqlite3_result_error_toobig(self.ctx) }\n            } else {\n                unsafe { sqlite3_result_error(self.ctx, msg.as_ptr().cast(), -1) }\n            }\n            if enable_traceback().load(Ordering::Relaxed) {\n                vm.print_exception(exc);\n            }\n        }\n\n        fn db_handle(self) -> *mut sqlite3 {\n            unsafe { sqlite3_context_db_handle(self.ctx) }\n        }\n\n        fn result_from_object(self, val: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            unsafe {\n                if vm.is_none(val) {\n                    sqlite3_result_null(self.ctx)\n                } else if let Some(val) = val.downcast_ref::<PyInt>() {\n                    sqlite3_result_int64(self.ctx, val.try_to_primitive(vm)?)\n                } else if let Some(val) = val.downcast_ref::<PyFloat>() {\n                    sqlite3_result_double(self.ctx, val.to_f64())\n                } else if let Some(val) = val.downcast_ref::<PyStr>() {\n                    let val = val.try_as_utf8(vm)?;\n                    let (ptr, len) = str_to_ptr_len(val, vm)?;\n                    sqlite3_result_text(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, val) {\n                    let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                    sqlite3_result_blob(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else {\n                    return Err(new_programming_error(\n                        vm,\n                        \"result type not support\".to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n    }\n\n    fn value_to_object(val: *mut sqlite3_value, db: *mut sqlite3, vm: &VirtualMachine) -> PyResult {\n        let obj = unsafe {\n            match sqlite3_value_type(val) {\n                SQLITE_INTEGER => vm.ctx.new_int(sqlite3_value_int64(val)).into(),\n                SQLITE_FLOAT => vm.ctx.new_float(sqlite3_value_double(val)).into(),\n                SQLITE_TEXT => {\n                    let text =\n                        ptr_to_vec(sqlite3_value_text(val), sqlite3_value_bytes(val), db, vm)?;\n                    let text = String::from_utf8(text)\n                        .map_err(|_| vm.new_value_error(\"invalid utf-8 with SQLITE_TEXT\"))?;\n                    vm.ctx.new_str(text).into()\n                }\n                SQLITE_BLOB => {\n                    let blob = ptr_to_vec(\n                        sqlite3_value_blob(val).cast(),\n                        sqlite3_value_bytes(val),\n                        db,\n                        vm,\n                    )?;\n                    vm.ctx.new_bytes(blob).into()\n                }\n                _ => vm.ctx.none(),\n            }\n        };\n        Ok(obj)\n    }\n\n    fn ptr_to_str<'a>(p: *const libc::c_char, vm: &VirtualMachine) -> PyResult<&'a str> {\n        if p.is_null() {\n            return Err(vm.new_memory_error(\"string pointer is null\"));\n        }\n        unsafe { CStr::from_ptr(p).to_str() }\n            .map_err(|_| vm.new_value_error(\"Invalid UIF-8 codepoint\"))\n    }\n\n    fn ptr_to_string(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<String> {\n        let s = ptr_to_vec(p, nbytes, db, vm)?;\n        String::from_utf8(s).map_err(|_| vm.new_value_error(\"invalid utf-8\"))\n    }\n\n    fn ptr_to_vec(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<Vec<u8>> {\n        if p.is_null() {\n            if !db.is_null() && unsafe { sqlite3_errcode(db) } == SQLITE_NOMEM {\n                Err(vm.new_memory_error(\"sqlite out of memory\"))\n            } else {\n                Ok(vec![])\n            }\n        } else if nbytes < 0 {\n            Err(vm.new_system_error(\"negative size with ptr\"))\n        } else {\n            Ok(unsafe { std::slice::from_raw_parts(p.cast(), nbytes as usize) }.to_vec())\n        }\n    }\n\n    fn str_to_ptr_len(s: &PyUtf8Str, vm: &VirtualMachine) -> PyResult<(*const libc::c_char, i32)> {\n        let s_str = s.as_str();\n        let len = c_int::try_from(s_str.len())\n            .map_err(|_| vm.new_overflow_error(\"TEXT longer than INT_MAX bytes\"))?;\n        let ptr = s_str.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn buffer_to_ptr_len(buffer: &PyBuffer, vm: &VirtualMachine) -> PyResult<(*const c_void, i32)> {\n        let bytes = buffer\n            .as_contiguous()\n            .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n        let len = c_int::try_from(bytes.len())\n            .map_err(|_| vm.new_overflow_error(\"BLOB longer than INT_MAX bytes\"))?;\n        let ptr = bytes.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn exception_type_from_errcode(errcode: c_int, vm: &VirtualMachine) -> &'static Py<PyType> {\n        match errcode {\n            SQLITE_INTERNAL | SQLITE_NOTFOUND => internal_error_type(),\n            SQLITE_NOMEM => vm.ctx.exceptions.memory_error,\n            SQLITE_ERROR | SQLITE_PERM | SQLITE_ABORT | SQLITE_BUSY | SQLITE_LOCKED\n            | SQLITE_READONLY | SQLITE_INTERRUPT | SQLITE_IOERR | SQLITE_FULL | SQLITE_CANTOPEN\n            | SQLITE_PROTOCOL | SQLITE_EMPTY | SQLITE_SCHEMA => operational_error_type(),\n            SQLITE_CORRUPT => database_error_type(),\n            SQLITE_TOOBIG => data_error_type(),\n            SQLITE_CONSTRAINT | SQLITE_MISMATCH => integrity_error_type(),\n            SQLITE_MISUSE | SQLITE_RANGE => interface_error_type(),\n            _ => database_error_type(),\n        }\n    }\n\n    fn name_from_errcode(errcode: c_int) -> &'static str {\n        for (name, code) in ERROR_CODES {\n            if *code == errcode {\n                return name;\n            }\n        }\n        \"unknown error code\"\n    }\n\n    fn raise_exception(\n        typ: PyTypeRef,\n        errcode: c_int,\n        msg: String,\n        vm: &VirtualMachine,\n    ) -> PyBaseExceptionRef {\n        let dict = vm.ctx.new_dict();\n        if let Err(e) = dict.set_item(\"sqlite_errorcode\", vm.ctx.new_int(errcode).into(), vm) {\n            return e;\n        }\n        let errname = name_from_errcode(errcode);\n        if let Err(e) = dict.set_item(\"sqlite_errorname\", vm.ctx.new_str(errname).into(), vm) {\n            return e;\n        }\n\n        vm.new_exception_msg_dict(typ, msg, dict)\n    }\n\n    static BEGIN_STATEMENTS: &[&[u8]] = &[\n        b\"BEGIN \",\n        b\"BEGIN DEFERRED\",\n        b\"BEGIN IMMEDIATE\",\n        b\"BEGIN EXCLUSIVE\",\n    ];\n\n    fn begin_statement_ptr_from_isolation_level(\n        s: &PyStr,\n        vm: &VirtualMachine,\n    ) -> PyResult<*const libc::c_char> {\n        BEGIN_STATEMENTS\n            .iter()\n            .find(|&&x| x[6..].eq_ignore_ascii_case(s.as_bytes()))\n            .map(|&x| x.as_ptr().cast())\n            .ok_or_else(|| {\n                vm.new_value_error(\n                    \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or 'EXCLUSIVE'\",\n                )\n            })\n    }\n\n    fn lstrip_sql(sql: &[u8]) -> Option<&[u8]> {\n        let mut pos = 0;\n\n        // This loop is borrowed from the SQLite source code.\n        while let Some(t_char) = sql.get(pos) {\n            match t_char {\n                b' ' | b'\\t' | b'\\x0c' | b'\\n' | b'\\r' => {\n                    // Skip whitespace.\n                    pos += 1;\n                }\n                b'-' => {\n                    // Skip line comments.\n                    if sql.get(pos + 1) == Some(&b'-') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'\\n' {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                b'/' => {\n                    // Skip C style comments.\n                    if sql.get(pos + 1) == Some(&b'*') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'*' && sql.get(pos + 1) == Some(&b'/') {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                        pos += 2;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                _ => {\n                    return Some(&sql[pos..]);\n                }\n            }\n        }\n\n        None\n    }\n}\n"
                }
              ],
              []
            ],
            "kind": "textEditGroup",
            "uri": {
              "$mid": 1,
              "external": "file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "fsPath": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "path": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "scheme": "file"
            }
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#900-900), 900 줄에서 1020 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `fn check_thread` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#1440-1440), 1440 줄에서 1505 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "textEditGroup",
          "input": {
            "done": true,
            "edits": [
              [
                {
                  "range": {
                    "endColumn": 1,
                    "endLineNumber": 3389,
                    "startColumn": 1,
                    "startLineNumber": 1
                  },
                  "text": "// spell-checker:ignore libsqlite3 threadsafety PYSQLITE decltypes colnames collseq cantinit dirtywal\n// spell-checker:ignore corruptfs narg setinputsizes setoutputsize lastrowid arraysize executemany\n// spell-checker:ignore blobopen executescript iterdump getlimit setlimit errorcode errorname\n// spell-checker:ignore rowid rowcount fetchone fetchmany fetchall errcode errname vtable pagecount\n// spell-checker:ignore autocommit libversion toobig errmsg nomem threadsafe longlong vdbe reindex\n// spell-checker:ignore savepoint cantopen ioerr nolfs nomem notadb notfound fullpath notempdir vtab\n// spell-checker:ignore checkreservedlock noent fstat rdlock shmlock shmmap shmopen shmsize sharedcache\n// spell-checker:ignore cantlock commithook foreignkey notnull primarykey gettemppath autoindex convpath\n// spell-checker:ignore dbmoved vnode nbytes\n\nuse rustpython_vm::{AsObject, PyRef, VirtualMachine, builtins::PyModule};\n\n// pub(crate) use _sqlite::make_module;\npub(crate) fn make_module(vm: &VirtualMachine) -> PyRef<PyModule> {\n    // TODO: sqlite version check\n    let module = _sqlite::make_module(vm);\n    _sqlite::setup_module(module.as_object(), vm);\n    module\n}\n\n#[pymodule]\nmod _sqlite {\n    use crossbeam_utils::atomic::AtomicCell;\n    use libsqlite3_sys::{\n        SQLITE_BLOB, SQLITE_DETERMINISTIC, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL,\n        SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, SQLITE_OPEN_URI, SQLITE_TEXT, SQLITE_TRACE_STMT,\n        SQLITE_TRANSIENT, SQLITE_UTF8, sqlite3, sqlite3_aggregate_context, sqlite3_backup_finish,\n        sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining,\n        sqlite3_backup_step, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64,\n        sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name,\n        sqlite3_bind_text, sqlite3_blob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open,\n        sqlite3_blob_read, sqlite3_blob_write, sqlite3_busy_timeout, sqlite3_changes,\n        sqlite3_close_v2, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count,\n        sqlite3_column_decltype, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_name,\n        sqlite3_column_text, sqlite3_column_type, sqlite3_complete, sqlite3_context,\n        sqlite3_context_db_handle, sqlite3_create_collation_v2, sqlite3_create_function_v2,\n        sqlite3_create_window_function, sqlite3_data_count, sqlite3_db_handle, sqlite3_errcode,\n        sqlite3_errmsg, sqlite3_exec, sqlite3_expanded_sql, sqlite3_extended_errcode,\n        sqlite3_finalize, sqlite3_get_autocommit, sqlite3_interrupt, sqlite3_last_insert_rowid,\n        sqlite3_libversion, sqlite3_limit, sqlite3_open_v2, sqlite3_prepare_v2,\n        sqlite3_progress_handler, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double,\n        sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_error_toobig,\n        sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_set_authorizer,\n        sqlite3_sleep, sqlite3_step, sqlite3_stmt, sqlite3_stmt_busy, sqlite3_stmt_readonly,\n        sqlite3_threadsafe, sqlite3_total_changes, sqlite3_trace_v2, sqlite3_user_data,\n        sqlite3_value, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double,\n        sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type,\n    };\n    use malachite_bigint::Sign;\n    use rustpython_common::{\n        atomic::{Ordering, PyAtomic, Radium},\n        hash::PyHash,\n        lock::{PyMappedMutexGuard, PyMutex, PyMutexGuard},\n        static_cell,\n    };\n    use rustpython_vm::{\n        __exports::paste,\n        AsObject, Py, PyAtomicRef, PyObject, PyObjectRef, PyPayload, PyRef, PyResult,\n        TryFromBorrowedObject, VirtualMachine, atomic_func,\n        builtins::{\n            PyBaseException, PyBaseExceptionRef, PyByteArray, PyBytes, PyDict, PyDictRef, PyFloat,\n            PyInt, PyIntRef, PySlice, PyStr, PyStrRef, PyTuple, PyTupleRef, PyType, PyTypeRef,\n            PyUtf8Str, PyUtf8StrRef,\n        },\n        convert::IntoObject,\n        function::{\n            ArgCallable, ArgIterable, FsPath, FuncArgs, OptionalArg, PyComparisonValue,\n            PySetterValue,\n        },\n        object::{Traverse, TraverseFn},\n        protocol::{\n            PyBuffer, PyIterReturn, PyMappingMethods, PyNumberMethods, PySequence,\n            PySequenceMethods,\n        },\n        sliceable::{SaturatedSliceIter, SliceableSequenceOp},\n        types::{\n            AsMapping, AsNumber, AsSequence, Callable, Comparable, Constructor, Hashable,\n            Initializer, IterNext, Iterable, PyComparisonOp, SelfIter, Unconstructible,\n        },\n        utils::ToCString,\n    };\n    use std::{\n        ffi::{CStr, c_int, c_longlong, c_uint, c_void},\n        fmt::Debug,\n        ops::Deref,\n        ptr::{NonNull, null, null_mut},\n        thread::ThreadId,\n    };\n\n    macro_rules! exceptions {\n        ($(($x:ident, $base:expr)),*) => {\n            paste::paste! {\n                static_cell! {\n                    $(\n                        static [<$x:snake:upper>]: PyTypeRef;\n                    )*\n                }\n                $(\n                    #[allow(dead_code)]\n                    fn [<new_ $x:snake>](vm: &VirtualMachine, msg: String) -> PyBaseExceptionRef {\n                        vm.new_exception_msg([<$x:snake _type>]().to_owned(), msg)\n                    }\n                    fn [<$x:snake _type>]() -> &'static Py<PyType> {\n                        [<$x:snake:upper>].get().expect(\"exception type not initialize\")\n                    }\n                )*\n                fn setup_module_exceptions(module: &PyObject, vm: &VirtualMachine) {\n                    $(\n                        #[allow(clippy::redundant_closure_call)]\n                        let exception = [<$x:snake:upper>].get_or_init(|| {\n                            let base = $base(vm);\n                            vm.ctx.new_exception_type(\"_sqlite3\", stringify!($x), Some(vec![base.to_owned()]))\n                        });\n                        module.set_attr(stringify!($x), exception.clone().into_object(), vm).unwrap();\n                    )*\n                }\n            }\n        };\n    }\n\n    exceptions!(\n        (Warning, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (Error, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (InterfaceError, |_| error_type()),\n        (DatabaseError, |_| error_type()),\n        (DataError, |_| database_error_type()),\n        (OperationalError, |_| database_error_type()),\n        (IntegrityError, |_| database_error_type()),\n        (InternalError, |_| database_error_type()),\n        (ProgrammingError, |_| database_error_type()),\n        (NotSupportedError, |_| database_error_type())\n    );\n\n    #[pyattr]\n    fn sqlite_version(vm: &VirtualMachine) -> String {\n        let s = unsafe { sqlite3_libversion() };\n        ptr_to_str(s, vm).unwrap().to_owned()\n    }\n\n    #[pyattr]\n    fn threadsafety(_: &VirtualMachine) -> c_int {\n        let mode = unsafe { sqlite3_threadsafe() };\n        match mode {\n            0 => 0,\n            1 => 3,\n            2 => 1,\n            _ => panic!(\"Unable to interpret SQLite threadsafety mode\"),\n        }\n    }\n\n    #[pyattr(name = \"_deprecated_version\")]\n    const PYSQLITE_VERSION: &str = \"2.6.0\";\n\n    #[pyattr]\n    const PARSE_DECLTYPES: c_int = 1;\n    #[pyattr]\n    const PARSE_COLNAMES: c_int = 2;\n\n    #[pyattr]\n    use libsqlite3_sys::{\n        SQLITE_ALTER_TABLE, SQLITE_ANALYZE, SQLITE_ATTACH, SQLITE_CREATE_INDEX,\n        SQLITE_CREATE_TABLE, SQLITE_CREATE_TEMP_INDEX, SQLITE_CREATE_TEMP_TABLE,\n        SQLITE_CREATE_TEMP_TRIGGER, SQLITE_CREATE_TEMP_VIEW, SQLITE_CREATE_TRIGGER,\n        SQLITE_CREATE_VIEW, SQLITE_CREATE_VTABLE, SQLITE_DELETE, SQLITE_DENY, SQLITE_DETACH,\n        SQLITE_DROP_INDEX, SQLITE_DROP_TABLE, SQLITE_DROP_TEMP_INDEX, SQLITE_DROP_TEMP_TABLE,\n        SQLITE_DROP_TEMP_TRIGGER, SQLITE_DROP_TEMP_VIEW, SQLITE_DROP_TRIGGER, SQLITE_DROP_VIEW,\n        SQLITE_DROP_VTABLE, SQLITE_FUNCTION, SQLITE_IGNORE, SQLITE_INSERT, SQLITE_LIMIT_ATTACHED,\n        SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH,\n        SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH,\n        SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER,\n        SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_PRAGMA, SQLITE_READ,\n        SQLITE_RECURSIVE, SQLITE_REINDEX, SQLITE_SAVEPOINT, SQLITE_SELECT, SQLITE_TRANSACTION,\n        SQLITE_UPDATE,\n    };\n\n    macro_rules! error_codes {\n        ($($x:ident),*) => {\n            $(\n                #[allow(unused_imports)]\n                use libsqlite3_sys::$x;\n            )*\n            static ERROR_CODES: &[(&str, c_int)] = &[\n            $(\n                (stringify!($x), libsqlite3_sys::$x),\n            )*\n            ];\n        };\n    }\n\n    error_codes!(\n        SQLITE_ABORT,\n        SQLITE_AUTH,\n        SQLITE_BUSY,\n        SQLITE_CANTOPEN,\n        SQLITE_CONSTRAINT,\n        SQLITE_CORRUPT,\n        SQLITE_DONE,\n        SQLITE_EMPTY,\n        SQLITE_ERROR,\n        SQLITE_FORMAT,\n        SQLITE_FULL,\n        SQLITE_INTERNAL,\n        SQLITE_INTERRUPT,\n        SQLITE_IOERR,\n        SQLITE_LOCKED,\n        SQLITE_MISMATCH,\n        SQLITE_MISUSE,\n        SQLITE_NOLFS,\n        SQLITE_NOMEM,\n        SQLITE_NOTADB,\n        SQLITE_NOTFOUND,\n        SQLITE_OK,\n        SQLITE_PERM,\n        SQLITE_PROTOCOL,\n        SQLITE_RANGE,\n        SQLITE_READONLY,\n        SQLITE_ROW,\n        SQLITE_SCHEMA,\n        SQLITE_TOOBIG,\n        SQLITE_NOTICE,\n        SQLITE_WARNING,\n        SQLITE_ABORT_ROLLBACK,\n        SQLITE_BUSY_RECOVERY,\n        SQLITE_CANTOPEN_FULLPATH,\n        SQLITE_CANTOPEN_ISDIR,\n        SQLITE_CANTOPEN_NOTEMPDIR,\n        SQLITE_CORRUPT_VTAB,\n        SQLITE_IOERR_ACCESS,\n        SQLITE_IOERR_BLOCKED,\n        SQLITE_IOERR_CHECKRESERVEDLOCK,\n        SQLITE_IOERR_CLOSE,\n        SQLITE_IOERR_DELETE,\n        SQLITE_IOERR_DELETE_NOENT,\n        SQLITE_IOERR_DIR_CLOSE,\n        SQLITE_IOERR_DIR_FSYNC,\n        SQLITE_IOERR_FSTAT,\n        SQLITE_IOERR_FSYNC,\n        SQLITE_IOERR_LOCK,\n        SQLITE_IOERR_NOMEM,\n        SQLITE_IOERR_RDLOCK,\n        SQLITE_IOERR_READ,\n        SQLITE_IOERR_SEEK,\n        SQLITE_IOERR_SHMLOCK,\n        SQLITE_IOERR_SHMMAP,\n        SQLITE_IOERR_SHMOPEN,\n        SQLITE_IOERR_SHMSIZE,\n        SQLITE_IOERR_SHORT_READ,\n        SQLITE_IOERR_TRUNCATE,\n        SQLITE_IOERR_UNLOCK,\n        SQLITE_IOERR_WRITE,\n        SQLITE_LOCKED_SHAREDCACHE,\n        SQLITE_READONLY_CANTLOCK,\n        SQLITE_READONLY_RECOVERY,\n        SQLITE_CONSTRAINT_CHECK,\n        SQLITE_CONSTRAINT_COMMITHOOK,\n        SQLITE_CONSTRAINT_FOREIGNKEY,\n        SQLITE_CONSTRAINT_FUNCTION,\n        SQLITE_CONSTRAINT_NOTNULL,\n        SQLITE_CONSTRAINT_PRIMARYKEY,\n        SQLITE_CONSTRAINT_TRIGGER,\n        SQLITE_CONSTRAINT_UNIQUE,\n        SQLITE_CONSTRAINT_VTAB,\n        SQLITE_READONLY_ROLLBACK,\n        SQLITE_IOERR_MMAP,\n        SQLITE_NOTICE_RECOVER_ROLLBACK,\n        SQLITE_NOTICE_RECOVER_WAL,\n        SQLITE_BUSY_SNAPSHOT,\n        SQLITE_IOERR_GETTEMPPATH,\n        SQLITE_WARNING_AUTOINDEX,\n        SQLITE_CANTOPEN_CONVPATH,\n        SQLITE_IOERR_CONVPATH,\n        SQLITE_CONSTRAINT_ROWID,\n        SQLITE_READONLY_DBMOVED,\n        SQLITE_AUTH_USER,\n        SQLITE_OK_LOAD_PERMANENTLY,\n        SQLITE_IOERR_VNODE,\n        SQLITE_IOERR_AUTH,\n        SQLITE_IOERR_BEGIN_ATOMIC,\n        SQLITE_IOERR_COMMIT_ATOMIC,\n        SQLITE_IOERR_ROLLBACK_ATOMIC,\n        SQLITE_ERROR_MISSING_COLLSEQ,\n        SQLITE_ERROR_RETRY,\n        SQLITE_READONLY_CANTINIT,\n        SQLITE_READONLY_DIRECTORY,\n        SQLITE_CORRUPT_SEQUENCE,\n        SQLITE_LOCKED_VTAB,\n        SQLITE_CANTOPEN_DIRTYWAL,\n        SQLITE_ERROR_SNAPSHOT,\n        SQLITE_CANTOPEN_SYMLINK,\n        SQLITE_CONSTRAINT_PINNED,\n        SQLITE_OK_SYMLINK,\n        SQLITE_BUSY_TIMEOUT,\n        SQLITE_CORRUPT_INDEX,\n        SQLITE_IOERR_DATA,\n        SQLITE_IOERR_CORRUPTFS\n    );\n\n    #[derive(FromArgs)]\n    struct ConnectArgs {\n        #[pyarg(any)]\n        database: FsPath,\n        #[pyarg(any, default = 5.0)]\n        timeout: f64,\n        #[pyarg(any, default = 0)]\n        detect_types: c_int,\n        #[pyarg(any, default = Some(vm.ctx.empty_str.to_owned()))]\n        isolation_level: Option<PyStrRef>,\n        #[pyarg(any, default = true)]\n        check_same_thread: bool,\n        #[pyarg(any, default = Connection::class(&vm.ctx).to_owned())]\n        factory: PyTypeRef,\n        // TODO: cache statements\n        #[allow(dead_code)]\n        #[pyarg(any, default = 0)]\n        cached_statements: c_int,\n        #[pyarg(any, default = false)]\n        uri: bool,\n    }\n\n    unsafe impl Traverse for ConnectArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.isolation_level.traverse(tracer_fn);\n            self.factory.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct BackupArgs {\n        #[pyarg(any)]\n        target: PyRef<Connection>,\n        #[pyarg(named, default = -1)]\n        pages: c_int,\n        #[pyarg(named, optional)]\n        progress: Option<ArgCallable>,\n        #[pyarg(named, optional)]\n        name: Option<PyStrRef>,\n        #[pyarg(named, default = 0.250)]\n        sleep: f64,\n    }\n\n    unsafe impl Traverse for BackupArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.progress.traverse(tracer_fn);\n            self.name.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct CreateFunctionArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(any)]\n        narg: c_int,\n        #[pyarg(any)]\n        func: PyObjectRef,\n        #[pyarg(named, default)]\n        deterministic: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct CreateAggregateArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(positional)]\n        narg: c_int,\n        #[pyarg(positional)]\n        aggregate_class: PyObjectRef,\n    }\n\n    #[derive(FromArgs)]\n    struct BlobOpenArgs {\n        #[pyarg(positional)]\n        table: PyStrRef,\n        #[pyarg(positional)]\n        column: PyStrRef,\n        #[pyarg(positional)]\n        row: i64,\n        #[pyarg(named, default)]\n        readonly: bool,\n        #[pyarg(named, default = vm.ctx.new_str(\"main\"))]\n        name: PyStrRef,\n    }\n\n    struct CallbackData {\n        obj: NonNull<PyObject>,\n        vm: *const VirtualMachine,\n    }\n\n    impl CallbackData {\n        fn new(obj: PyObjectRef, vm: &VirtualMachine) -> Option<Self> {\n            (!vm.is_none(&obj)).then_some(Self {\n                obj: obj.into_raw(),\n                vm,\n            })\n        }\n\n        fn retrieve(&self) -> (&PyObject, &VirtualMachine) {\n            unsafe { (self.obj.as_ref(), &*self.vm) }\n        }\n\n        unsafe extern \"C\" fn destructor(data: *mut c_void) {\n            drop(unsafe { Box::from_raw(data.cast::<Self>()) });\n        }\n\n        unsafe extern \"C\" fn func_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (func, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n\n                let val = func.call(args, vm)?;\n\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                context.result_exception(vm, exc, \"user-defined function raised exception\\0\")\n            }\n        }\n\n        unsafe extern \"C\" fn step_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (cls, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            if unsafe { (*instance).is_null() } {\n                match cls.call((), vm) {\n                    Ok(obj) => unsafe { *instance = obj.into_raw().as_ptr() },\n                    Err(exc) => {\n                        return context.result_exception(\n                            vm,\n                            exc,\n                            \"user-defined aggregate's '__init__' method raised error\\0\",\n                        );\n                    }\n                }\n            }\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"step\", args, vm);\n        }\n\n        unsafe extern \"C\" fn finalize_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let Some(instance) = (unsafe { (*instance).as_ref() }) else {\n                return;\n            };\n\n            Self::callback_result_from_method(context, instance, \"finalize\", vm);\n        }\n\n        unsafe extern \"C\" fn collation_callback(\n            data: *mut c_void,\n            a_len: c_int,\n            a_ptr: *const c_void,\n            b_len: c_int,\n            b_ptr: *const c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n\n            let f = || -> PyResult<c_int> {\n                let text1 = ptr_to_string(a_ptr.cast(), a_len, null_mut(), vm)?;\n                let text1 = vm.ctx.new_str(text1);\n                let text2 = ptr_to_string(b_ptr.cast(), b_len, null_mut(), vm)?;\n                let text2 = vm.ctx.new_str(text2);\n\n                let val = callable.call((text1, text2), vm)?;\n                let Some(val) = val.to_number().index(vm) else {\n                    return Ok(0);\n                };\n\n                let val = match val?.as_bigint().sign() {\n                    Sign::Plus => 1,\n                    Sign::Minus => -1,\n                    Sign::NoSign => 0,\n                };\n\n                Ok(val)\n            };\n\n            f().unwrap_or(0)\n        }\n\n        unsafe extern \"C\" fn value_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::callback_result_from_method(context, instance, \"value\", vm);\n        }\n\n        unsafe extern \"C\" fn inverse_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"inverse\", args, vm);\n        }\n\n        unsafe extern \"C\" fn authorizer_callback(\n            data: *mut c_void,\n            action: c_int,\n            arg1: *const libc::c_char,\n            arg2: *const libc::c_char,\n            db_name: *const libc::c_char,\n            access: *const libc::c_char,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let f = || -> PyResult<c_int> {\n                let arg1 = ptr_to_str(arg1, vm)?;\n                let arg2 = ptr_to_str(arg2, vm)?;\n                let db_name = ptr_to_str(db_name, vm)?;\n                let access = ptr_to_str(access, vm)?;\n\n                let val = callable.call((action, arg1, arg2, db_name, access), vm)?;\n                let Some(val) = val.downcast_ref::<PyInt>() else {\n                    return Ok(SQLITE_DENY);\n                };\n                val.try_to_primitive::<c_int>(vm)\n            };\n\n            f().unwrap_or(SQLITE_DENY)\n        }\n\n        unsafe extern \"C\" fn trace_callback(\n            _typ: c_uint,\n            data: *mut c_void,\n            stmt: *mut c_void,\n            sql: *mut c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let expanded = unsafe { sqlite3_expanded_sql(stmt.cast()) };\n            let f = || -> PyResult<()> {\n                let stmt = ptr_to_str(expanded, vm).or_else(|_| ptr_to_str(sql.cast(), vm))?;\n                callable.call((stmt,), vm)?;\n                Ok(())\n            };\n            let _ = f();\n            0\n        }\n\n        unsafe extern \"C\" fn progress_callback(data: *mut c_void) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            if let Ok(val) = callable.call((), vm)\n                && let Ok(val) = val.is_true(vm)\n            {\n                return val as c_int;\n            }\n            -1\n        }\n\n        fn callback_result_from_method(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let val = vm.call_method(instance, name, ())?;\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n\n        fn call_method_with_args(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            args: &[*mut sqlite3_value],\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n                vm.call_method(instance, name, args).map(drop)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n    }\n\n    impl Drop for CallbackData {\n        fn drop(&mut self) {\n            unsafe { PyObjectRef::from_raw(self.obj) };\n        }\n    }\n\n    #[pyfunction]\n    fn connect(args: ConnectArgs, vm: &VirtualMachine) -> PyResult {\n        Connection::py_new(args.factory.clone(), args, vm)\n    }\n\n    #[pyfunction]\n    fn complete_statement(statement: PyStrRef, vm: &VirtualMachine) -> PyResult<bool> {\n        let s = statement.to_cstring(vm)?;\n        let ret = unsafe { sqlite3_complete(s.as_ptr()) };\n        Ok(ret == 1)\n    }\n\n    #[pyfunction]\n    fn enable_callback_tracebacks(flag: bool) {\n        enable_traceback().store(flag, Ordering::Relaxed);\n    }\n\n    #[pyfunction]\n    fn register_adapter(typ: PyTypeRef, adapter: ArgCallable, vm: &VirtualMachine) -> PyResult<()> {\n        if typ.is(PyInt::class(&vm.ctx))\n            || typ.is(PyFloat::class(&vm.ctx))\n            || typ.is(PyStr::class(&vm.ctx))\n            || typ.is(PyByteArray::class(&vm.ctx))\n        {\n            let _ = BASE_TYPE_ADAPTED.set(());\n        }\n        let protocol = PrepareProtocol::class(&vm.ctx).to_owned();\n        let key = vm.ctx.new_tuple(vec![typ.into(), protocol.into()]);\n        adapters().set_item(key.as_object(), adapter.into(), vm)\n    }\n\n    #[pyfunction]\n    fn register_converter(\n        typename: PyStrRef,\n        converter: ArgCallable,\n        vm: &VirtualMachine,\n    ) -> PyResult<()> {\n        let name = typename.as_str().to_uppercase();\n        converters().set_item(&name, converter.into(), vm)\n    }\n\n    fn _adapt<F>(obj: &PyObject, proto: PyTypeRef, alt: F, vm: &VirtualMachine) -> PyResult\n    where\n        F: FnOnce(&PyObject) -> PyResult,\n    {\n        let proto = proto.into_object();\n        let key = vm\n            .ctx\n            .new_tuple(vec![obj.class().to_owned().into(), proto.clone()]);\n\n        if let Some(adapter) = adapters().get_item_opt(key.as_object(), vm)? {\n            return adapter.call((obj,), vm);\n        }\n        if let Ok(adapter) = proto.get_attr(\"__adapt__\", vm) {\n            match adapter.call((obj,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n        if let Ok(adapter) = obj.get_attr(\"__conform__\", vm) {\n            match adapter.call((proto,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n\n        alt(obj)\n    }\n\n    #[pyfunction]\n    fn adapt(\n        obj: PyObjectRef,\n        proto: OptionalArg<Option<PyTypeRef>>,\n        alt: OptionalArg<PyObjectRef>,\n        vm: &VirtualMachine,\n    ) -> PyResult {\n        if matches!(proto, OptionalArg::Present(None)) {\n            return if let OptionalArg::Present(alt) = alt {\n                Ok(alt)\n            } else {\n                Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n            };\n        }\n\n        let proto = proto\n            .flatten()\n            .unwrap_or_else(|| PrepareProtocol::class(&vm.ctx).to_owned());\n\n        _adapt(\n            &obj,\n            proto,\n            |_| {\n                if let OptionalArg::Present(alt) = alt {\n                    Ok(alt)\n                } else {\n                    Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n                }\n            },\n            vm,\n        )\n    }\n\n    fn need_adapt(obj: &PyObject, vm: &VirtualMachine) -> bool {\n        if BASE_TYPE_ADAPTED.get().is_some() {\n            true\n        } else {\n            let cls = obj.class();\n            !(cls.is(vm.ctx.types.int_type)\n                || cls.is(vm.ctx.types.float_type)\n                || cls.is(vm.ctx.types.str_type)\n                || cls.is(vm.ctx.types.bytearray_type))\n        }\n    }\n\n    static_cell! {\n        static CONVERTERS: PyDictRef;\n        static ADAPTERS: PyDictRef;\n        static BASE_TYPE_ADAPTED: ();\n        static USER_FUNCTION_EXCEPTION: PyAtomicRef<Option<PyBaseException>>;\n        static ENABLE_TRACEBACK: PyAtomic<bool>;\n    }\n\n    fn converters() -> &'static Py<PyDict> {\n        CONVERTERS.get().expect(\"converters not initialize\")\n    }\n\n    fn adapters() -> &'static Py<PyDict> {\n        ADAPTERS.get().expect(\"adapters not initialize\")\n    }\n\n    fn user_function_exception() -> &'static PyAtomicRef<Option<PyBaseException>> {\n        USER_FUNCTION_EXCEPTION\n            .get()\n            .expect(\"user function exception not initialize\")\n    }\n\n    fn enable_traceback() -> &'static PyAtomic<bool> {\n        ENABLE_TRACEBACK\n            .get()\n            .expect(\"enable traceback not initialize\")\n    }\n\n    pub(super) fn setup_module(module: &PyObject, vm: &VirtualMachine) {\n        for (name, code) in ERROR_CODES {\n            let name = vm.ctx.intern_str(*name);\n            let code = vm.new_pyobj(*code);\n            module.set_attr(name, code, vm).unwrap();\n        }\n\n        setup_module_exceptions(module, vm);\n\n        let _ = CONVERTERS.set(vm.ctx.new_dict());\n        let _ = ADAPTERS.set(vm.ctx.new_dict());\n        let _ = USER_FUNCTION_EXCEPTION.set(PyAtomicRef::from(None));\n        let _ = ENABLE_TRACEBACK.set(Radium::new(false));\n\n        module\n            .set_attr(\"converters\", converters().to_owned(), vm)\n            .unwrap();\n        module\n            .set_attr(\"adapters\", adapters().to_owned(), vm)\n            .unwrap();\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(PyPayload)]\n    struct Connection {\n        db: PyMutex<Option<Sqlite>>,\n        detect_types: PyAtomic<c_int>,\n        isolation_level: PyAtomicRef<Option<PyStr>>,\n        check_same_thread: PyAtomic<bool>,\n        thread_ident: PyMutex<ThreadId>,\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        text_factory: PyAtomicRef<PyObject>,\n    }\n\n    impl Debug for Connection {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"Sqlite3 Connection\")\n        }\n    }\n\n    impl Constructor for Connection {\n        type Args = ConnectArgs;\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n\n            // For non-subclassed Connection, initialize in __new__\n            // For subclassed Connection, leave db as None and require __init__ to be called\n            let is_base_class = cls.is(Connection::class(&vm.ctx).as_object());\n\n            let db = if is_base_class {\n                // Initialize immediately for base class\n                Some(Connection::initialize_db(&args, vm)?)\n            } else {\n                // For subclasses, require __init__ to be called\n                None\n            };\n\n            let conn = Self {\n                db: PyMutex::new(db),\n                detect_types: Radium::new(args.detect_types),\n                isolation_level: PyAtomicRef::from(args.isolation_level),\n                check_same_thread: Radium::new(args.check_same_thread),\n                thread_ident: PyMutex::new(std::thread::current().id()),\n                row_factory: PyAtomicRef::from(None),\n                text_factory: PyAtomicRef::from(text_factory),\n            };\n\n            Ok(conn.into_ref_with_type(vm, cls)?.into())\n        }\n    }\n\n    impl Callable for Connection {\n        type Args = FuncArgs;\n\n        fn call(zelf: &Py<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let _ = zelf.db_lock(vm)?;\n\n            let (sql,): (PyUtf8StrRef,) = args.bind(vm)?;\n\n            if let Some(stmt) = Statement::new(zelf, sql, vm)? {\n                Ok(stmt.into_ref(&vm.ctx).into())\n            } else {\n                Ok(vm.ctx.none())\n            }\n        }\n    }\n\n    impl Initializer for Connection {\n        type Args = ConnectArgs;\n\n        fn init(zelf: PyRef<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult<()> {\n            {\n                // Always drop the current database handle so __init__ can fully reconfigure it.\n                let mut guard = zelf.db.lock();\n                guard.take();\n            }\n\n            // Reset factories to their defaults, matching CPython's behavior.\n            let default_text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n            let _ = unsafe { zelf.row_factory.swap(None) };\n            let _ = unsafe { zelf.text_factory.swap(default_text_factory) };\n\n            // Attempt to open the new database before mutating other state so failures leave\n            // the connection uninitialized (and subsequent operations raise ProgrammingError).\n            let db = Self::initialize_db(&args, vm)?;\n\n            let ConnectArgs {\n                detect_types,\n                isolation_level,\n                check_same_thread,\n                ..\n            } = args;\n\n            zelf.detect_types.store(detect_types, Ordering::Relaxed);\n            zelf\n                .check_same_thread\n                .store(check_same_thread, Ordering::Relaxed);\n            *zelf.thread_ident.lock() = std::thread::current().id();\n            let _ = unsafe { zelf.isolation_level.swap(isolation_level) };\n\n            let mut guard = zelf.db.lock();\n            *guard = Some(db);\n            Ok(())\n        }\n    }\n\n    #[pyclass(with(Constructor, Callable, Initializer), flags(BASETYPE))]\n    impl Connection {\n        fn initialize_db(args: &ConnectArgs, vm: &VirtualMachine) -> PyResult<Sqlite> {\n            let path = args.database.to_cstring(vm)?;\n            let db = Sqlite::from(SqliteRaw::open(path.as_ptr(), args.uri, vm)?);\n            let timeout = (args.timeout * 1000.0) as c_int;\n            db.busy_timeout(timeout);\n            if let Some(isolation_level) = &args.isolation_level {\n                begin_statement_ptr_from_isolation_level(isolation_level, vm)?;\n            }\n            Ok(db)\n        }\n\n        fn db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            self.check_thread(vm)?;\n            self._db_lock(vm)\n        }\n\n        fn _db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            let guard = self.db.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Connection.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn cursor(\n            zelf: PyRef<Self>,\n            factory: OptionalArg<ArgCallable>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            zelf.db_lock(vm).map(drop)?;\n\n            let cursor = if let OptionalArg::Present(factory) = factory {\n                let cursor = factory.invoke((zelf.clone(),), vm)?;\n                let cursor = cursor.downcast::<Cursor>().map_err(|x| {\n                    vm.new_type_error(format!(\"factory must return a cursor, not {}\", x.class()))\n                })?;\n                let _ = unsafe { cursor.row_factory.swap(zelf.row_factory.to_owned()) };\n                cursor\n            } else {\n                let row_factory = zelf.row_factory.to_owned();\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx)\n            };\n            Ok(cursor)\n        }\n\n        #[pymethod]\n        fn blobopen(\n            zelf: PyRef<Self>,\n            args: BlobOpenArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Blob>> {\n            let table = args.table.to_cstring(vm)?;\n            let column = args.column.to_cstring(vm)?;\n            let name = args.name.to_cstring(vm)?;\n\n            let db = zelf.db_lock(vm)?;\n\n            let mut blob = null_mut();\n            let ret = unsafe {\n                sqlite3_blob_open(\n                    db.db,\n                    name.as_ptr(),\n                    table.as_ptr(),\n                    column.as_ptr(),\n                    args.row,\n                    (!args.readonly) as c_int,\n                    &mut blob,\n                )\n            };\n            db.check(ret, vm)?;\n            drop(db);\n\n            let blob = SqliteBlob { blob };\n            let blob = Blob {\n                connection: zelf,\n                inner: PyMutex::new(Some(BlobInner { blob, offset: 0 })),\n            };\n            Ok(blob.into_ref(&vm.ctx))\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.check_thread(vm)?;\n            self.db.lock().take();\n            Ok(())\n        }\n\n        #[pymethod]\n        fn commit(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.db_lock(vm)?.implicit_commit(vm)\n        }\n\n        #[pymethod]\n        fn rollback(&self, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            if !db.is_autocommit() {\n                db._exec(b\"ROLLBACK\\0\", vm)\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::execute(cursor, sql, parameters, vm)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::executemany(cursor, sql, seq_of_params, vm)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            Cursor::executescript(\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx),\n                script,\n                vm,\n            )\n        }\n\n        // TODO: Make it build without clippy::manual_c_str_literals\n        #[pymethod]\n        #[allow(clippy::manual_c_str_literals)]\n        fn backup(zelf: &Py<Self>, args: BackupArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let BackupArgs {\n                target,\n                pages,\n                progress,\n                name,\n                sleep,\n            } = args;\n            if zelf.is(&target) {\n                return Err(vm.new_value_error(\"target cannot be the same connection instance\"));\n            }\n\n            let pages = if pages == 0 { -1 } else { pages };\n\n            let name_cstring;\n            let name_ptr = if let Some(name) = &name {\n                name_cstring = name.to_cstring(vm)?;\n                name_cstring.as_ptr()\n            } else {\n                b\"main\\0\".as_ptr().cast()\n            };\n\n            let sleep_ms = (sleep * 1000.0) as c_int;\n\n            let db = zelf.db_lock(vm)?;\n            let target_db = target.db_lock(vm)?;\n\n            let handle = unsafe {\n                sqlite3_backup_init(target_db.db, b\"main\\0\".as_ptr().cast(), db.db, name_ptr)\n            };\n\n            if handle.is_null() {\n                return Err(target_db.error_extended(vm));\n            }\n\n            drop(db);\n            drop(target_db);\n\n            loop {\n                let ret = unsafe { sqlite3_backup_step(handle, pages) };\n\n                if let Some(progress) = &progress {\n                    let remaining = unsafe { sqlite3_backup_remaining(handle) };\n                    let pagecount = unsafe { sqlite3_backup_pagecount(handle) };\n                    if let Err(err) = progress.invoke((ret, remaining, pagecount), vm) {\n                        unsafe { sqlite3_backup_finish(handle) };\n                        return Err(err);\n                    }\n                }\n\n                if ret == SQLITE_BUSY || ret == SQLITE_LOCKED {\n                    unsafe { sqlite3_sleep(sleep_ms) };\n                } else if ret != SQLITE_OK {\n                    break;\n                }\n            }\n\n            let ret = unsafe { sqlite3_backup_finish(handle) };\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(target.db_lock(vm)?.error_extended(vm))\n            }\n        }\n\n        #[pymethod]\n        fn create_function(&self, args: CreateFunctionArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let flags = if args.deterministic {\n                SQLITE_UTF8 | SQLITE_DETERMINISTIC\n            } else {\n                SQLITE_UTF8\n            };\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.func, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    flags,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                flags,\n                Box::into_raw(Box::new(data)).cast(),\n                Some(CallbackData::func_callback),\n                None,\n                None,\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_aggregate(&self, args: CreateAggregateArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.aggregate_class, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    SQLITE_UTF8,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                SQLITE_UTF8,\n                Box::into_raw(Box::new(data)).cast(),\n                None,\n                Some(CallbackData::step_callback),\n                Some(CallbackData::finalize_callback),\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_collation(\n            &self,\n            name: PyUtf8StrRef,\n            callable: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable.clone(), vm) else {\n                unsafe {\n                    sqlite3_create_collation_v2(\n                        db.db,\n                        name.as_ptr(),\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                    );\n                }\n                return Ok(());\n            };\n            let data = Box::into_raw(Box::new(data));\n\n            if !callable.is_callable() {\n                return Err(vm.new_type_error(\"parameter must be callable\"));\n            }\n\n            let ret = unsafe {\n                sqlite3_create_collation_v2(\n                    db.db,\n                    name.as_ptr(),\n                    SQLITE_UTF8,\n                    data.cast(),\n                    Some(CallbackData::collation_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n\n            db.check(ret, vm).inspect_err(|_| {\n                // create_collation do not call destructor if error occur\n                let _ = unsafe { Box::from_raw(data) };\n            })\n        }\n\n        #[pymethod]\n        fn create_window_function(\n            &self,\n            name: PyStrRef,\n            narg: c_int,\n            aggregate_class: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(aggregate_class, vm) else {\n                unsafe {\n                    sqlite3_create_window_function(\n                        db.db,\n                        name.as_ptr(),\n                        narg,\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                        None,\n                        None,\n                        None,\n                    )\n                };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_create_window_function(\n                    db.db,\n                    name.as_ptr(),\n                    narg,\n                    SQLITE_UTF8,\n                    Box::into_raw(Box::new(data)).cast(),\n                    Some(CallbackData::step_callback),\n                    Some(CallbackData::finalize_callback),\n                    Some(CallbackData::value_callback),\n                    Some(CallbackData::inverse_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n            db.check(ret, vm)\n                .map_err(|_| new_programming_error(vm, \"Error creating window function\".to_owned()))\n        }\n\n        #[pymethod]\n        fn set_authorizer(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_set_authorizer(db.db, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_set_authorizer(\n                    db.db,\n                    Some(CallbackData::authorizer_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n            db.check(ret, vm).map_err(|_| {\n                new_operational_error(vm, \"Error setting authorizer callback\".to_owned())\n            })\n        }\n\n        #[pymethod]\n        fn set_trace_callback(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_trace_v2(db.db, SQLITE_TRACE_STMT as u32, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_trace_v2(\n                    db.db,\n                    SQLITE_TRACE_STMT as u32,\n                    Some(CallbackData::trace_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            db.check(ret, vm)\n        }\n\n        #[pymethod]\n        fn set_progress_handler(\n            &self,\n            callable: PyObjectRef,\n            n: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_progress_handler(db.db, n, None, null_mut()) };\n                return Ok(());\n            };\n\n            unsafe {\n                sqlite3_progress_handler(\n                    db.db,\n                    n,\n                    Some(CallbackData::progress_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            Ok(())\n        }\n\n        #[pymethod]\n        fn iterdump(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            let module = vm.import(\"sqlite3.dump\", 0)?;\n            let func = module.get_attr(\"_iterdump\", vm)?;\n            func.call((zelf,), vm)\n        }\n\n        #[pymethod]\n        fn interrupt(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // DO NOT check thread safety\n            self._db_lock(vm).map(|x| x.interrupt())\n        }\n\n        #[pymethod]\n        fn getlimit(&self, category: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, -1, vm)\n        }\n\n        #[pymethod]\n        fn setlimit(&self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, limit, vm)\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>) -> PyRef<Self> {\n            zelf\n        }\n\n        #[pymethod]\n        fn __exit__(\n            &self,\n            cls: PyObjectRef,\n            exc: PyObjectRef,\n            tb: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            if vm.is_none(&cls) && vm.is_none(&exc) && vm.is_none(&tb) {\n                self.commit(vm)\n            } else {\n                self.rollback(vm)\n            }\n        }\n\n        #[pygetset]\n        fn isolation_level(&self) -> Option<PyStrRef> {\n            self.isolation_level.deref().map(|x| x.to_owned())\n        }\n        #[pygetset(setter)]\n        fn set_isolation_level(\n            &self,\n            value: PySetterValue<Option<PyStrRef>>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            match value {\n                PySetterValue::Assign(value) => {\n                    if let Some(val_str) = &value {\n                        begin_statement_ptr_from_isolation_level(val_str, vm)?;\n                    }\n\n                    // If setting isolation_level to None (auto-commit mode), commit any pending transaction\n                    if value.is_none() {\n                        let db = self.db_lock(vm)?;\n                        if !db.is_autocommit() {\n                            // Keep the lock and call implicit_commit directly to avoid race conditions\n                            db.implicit_commit(vm)?;\n                        }\n                    }\n                    let _ = unsafe { self.isolation_level.swap(value) };\n                    Ok(())\n                }\n                PySetterValue::Delete => Err(vm.new_attribute_error(\n                    \"'isolation_level' attribute cannot be deleted\".to_owned(),\n                )),\n            }\n        }\n\n        #[pygetset]\n        fn text_factory(&self) -> PyObjectRef {\n            self.text_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_text_factory(&self, val: PyObjectRef) {\n            let _ = unsafe { self.text_factory.swap(val) };\n        }\n\n        #[pygetset]\n        fn row_factory(&self) -> Option<PyObjectRef> {\n            self.row_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_row_factory(&self, val: Option<PyObjectRef>) {\n            let _ = unsafe { self.row_factory.swap(val) };\n        }\n\n        fn check_thread(&self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.check_same_thread.load(Ordering::Relaxed) {\n                let creator_id = *self.thread_ident.lock();\n                if std::thread::current().id() != creator_id {\n                    return Err(new_programming_error(\n                        vm,\n                        \"SQLite objects created in a thread can only be used in that same thread.\"\n                            .to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n\n        #[pygetset]\n        fn in_transaction(&self, vm: &VirtualMachine) -> PyResult<bool> {\n            self._db_lock(vm).map(|x| !x.is_autocommit())\n        }\n\n        #[pygetset]\n        fn total_changes(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self._db_lock(vm).map(|x| x.total_changes())\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Cursor {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        arraysize: PyAtomic<c_int>,\n        #[pytraverse(skip)]\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        inner: PyMutex<Option<CursorInner>>,\n    }\n\n    #[derive(Debug, Traverse)]\n    struct CursorInner {\n        description: Option<PyTupleRef>,\n        row_cast_map: Vec<Option<PyObjectRef>>,\n        #[pytraverse(skip)]\n        lastrowid: i64,\n        #[pytraverse(skip)]\n        rowcount: i64,\n        statement: Option<PyRef<Statement>>,\n        #[pytraverse(skip)]\n        closed: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct FetchManyArgs {\n        #[pyarg(any, name = \"size\", optional)]\n        size: Option<c_int>,\n    }\n\n    #[pyclass(with(Constructor, IterNext, Iterable), flags(BASETYPE))]\n    impl Cursor {\n        fn new(\n            connection: PyRef<Connection>,\n            row_factory: Option<PyObjectRef>,\n            _vm: &VirtualMachine,\n        ) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(row_factory),\n                inner: PyMutex::from(Some(CursorInner {\n                    description: None,\n                    row_cast_map: vec![],\n                    lastrowid: -1,\n                    rowcount: -1,\n                    statement: None,\n                    closed: false,\n                })),\n            }\n        }\n\n        fn new_uninitialized(connection: PyRef<Connection>, _vm: &VirtualMachine) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(None),\n                inner: PyMutex::from(None),\n            }\n        }\n\n        #[pymethod]\n        fn __init__(&self, _connection: PyRef<Connection>, _vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = self.inner.lock();\n            if guard.is_some() {\n                // Already initialized (e.g., from a call to super().__init__)\n                return Ok(());\n            }\n            *guard = Some(CursorInner {\n                description: None,\n                row_cast_map: vec![],\n                lastrowid: -1,\n                rowcount: -1,\n                statement: None,\n                closed: false,\n            });\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, CursorInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                let inner_guard =\n                    PyMutexGuard::map(guard, |x| unsafe { x.as_mut().unwrap_unchecked() });\n                if inner_guard.closed {\n                    return Err(new_programming_error(\n                        vm,\n                        \"Cannot operate on a closed cursor.\".to_owned(),\n                    ));\n                }\n                Ok(inner_guard)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let st = stmt.lock();\n            let params_needed = st.bind_parameter_count();\n\n            if let OptionalArg::Present(parameters) = parameters {\n                st.bind_parameters(&parameters, vm)?;\n            } else if params_needed > 0 {\n                let msg = format!(\n                    \"Incorrect number of bindings supplied. The current statement uses {}, and 0 were supplied.\",\n                    params_needed\n                );\n                return Err(new_programming_error(vm, msg));\n            }\n\n            let ret = st.step();\n\n            if ret != SQLITE_DONE && ret != SQLITE_ROW {\n                if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                    return Err(exc);\n                }\n                return Err(db.error_extended(vm));\n            }\n\n            inner.row_cast_map = zelf.build_row_cast_map(&st, vm)?;\n\n            inner.description = st.columns_description(zelf.connection.detect_types, vm)?;\n\n            if ret == SQLITE_ROW {\n                drop(st);\n                inner.statement = Some(stmt);\n            } else {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount += db.changes() as i64;\n                }\n            }\n\n            inner.lastrowid = db.lastrowid();\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            let st = stmt.lock();\n\n            if st.readonly() {\n                return Err(new_programming_error(\n                    vm,\n                    \"executemany() can only execute DML statements.\".to_owned(),\n                ));\n            }\n\n            inner.description = st.columns_description(zelf.connection.detect_types, vm)?;\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let iter = seq_of_params.iter(vm)?;\n            for params in iter {\n                let params = params?;\n                st.bind_parameters(&params, vm)?;\n\n                if !st.step_row_else_done(vm)? {\n                    if stmt.is_dml {\n                        inner.rowcount += db.changes() as i64;\n                    }\n                    st.reset();\n                }\n\n                // if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                //     return Err(exc);\n                // }\n            }\n\n            if st.busy() {\n                drop(st);\n                inner.statement = Some(stmt);\n            }\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let db = zelf.connection.db_lock(vm)?;\n\n            db.sql_limit(script.byte_len(), vm)?;\n\n            db.implicit_commit(vm)?;\n\n            let script = script.to_cstring(vm)?;\n            let mut ptr = script.as_ptr();\n\n            while let Some(st) = db.prepare(ptr, &mut ptr, vm)? {\n                while st.step_row_else_done(vm)? {}\n            }\n\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn fetchone(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult {\n            Self::next(zelf, vm).map(|x| match x {\n                PyIterReturn::Return(row) => row,\n                PyIterReturn::StopIteration(_) => vm.ctx.none(),\n            })\n        }\n\n        #[pymethod]\n        fn fetchmany(\n            zelf: &Py<Self>,\n            args: FetchManyArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<PyObjectRef>> {\n            let max_rows = args\n                .size\n                .unwrap_or_else(|| zelf.arraysize.load(Ordering::Relaxed));\n\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Cursor::next(zelf, vm)? {\n                list.push(row);\n                if max_rows > 0 && list.len() as c_int >= max_rows {\n                    break;\n                }\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn fetchall(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Self::next(zelf, vm)? {\n                list.push(row);\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // Check if __init__ was called\n            let mut guard = self.inner.lock();\n            if guard.is_none() {\n                return Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ));\n            }\n\n            if let Some(inner) = guard.as_mut() {\n                if let Some(stmt) = &inner.statement {\n                    stmt.lock().reset();\n                }\n                inner.closed = true;\n            }\n            Ok(())\n        }\n\n        #[pymethod]\n        fn setinputsizes(&self, _sizes: PyObjectRef) {}\n        #[pymethod]\n        fn setoutputsize(&self, _size: PyObjectRef, _column: OptionalArg<PyObjectRef>) {}\n\n        #[pygetset]\n        fn connection(&self) -> PyRef<Connection> {\n            self.connection.clone()\n        }\n\n        #[pygetset]\n        fn lastrowid(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.lastrowid)\n        }\n\n        #[pygetset]\n        fn rowcount(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.rowcount)\n        }\n\n        #[pygetset]\n        fn description(&self, vm: &VirtualMachine) -> PyResult<Option<PyTupleRef>> {\n            self.inner(vm).map(|x| x.description.clone())\n        }\n\n        #[pygetset]\n        fn arraysize(&self) -> c_int {\n            self.arraysize.load(Ordering::Relaxed)\n        }\n        #[pygetset(setter)]\n        fn set_arraysize(&self, val: c_int) {\n            self.arraysize.store(val, Ordering::Relaxed);\n        }\n\n        fn build_row_cast_map(\n            &self,\n            st: &SqliteStatementRaw,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<Option<PyObjectRef>>> {\n            if self.connection.detect_types == 0 {\n                return Ok(vec![]);\n            }\n\n            let mut cast_map = vec![];\n            let num_cols = st.column_count();\n\n            for i in 0..num_cols {\n                if self.connection.detect_types & PARSE_COLNAMES != 0 {\n                    let col_name = st.column_name(i);\n                    let col_name = ptr_to_str(col_name, vm)?;\n                    let col_name = col_name\n                        .chars()\n                        .skip_while(|&x| x != '[')\n                        .skip(1)\n                        .take_while(|&x| x != ']')\n                        .flat_map(|x| x.to_uppercase())\n                        .collect::<String>();\n                    if let Some(converter) = converters().get_item_opt(&col_name, vm)? {\n                        cast_map.push(Some(converter.clone()));\n                        continue;\n                    }\n                }\n                if self.connection.detect_types & PARSE_DECLTYPES != 0 {\n                    let decltype = st.column_decltype(i);\n                    let decltype = ptr_to_str(decltype, vm)?;\n                    if let Some(decltype) = decltype.split_terminator(&[' ', '(']).next() {\n                        let decltype = decltype.to_uppercase();\n                        if let Some(converter) = converters().get_item_opt(&decltype, vm)? {\n                            cast_map.push(Some(converter.clone()));\n                            continue;\n                        }\n                    }\n                }\n                cast_map.push(None);\n            }\n\n            Ok(cast_map)\n        }\n    }\n\n    impl Constructor for Cursor {\n        type Args = (PyRef<Connection>,);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            Self::new_uninitialized(args.0, vm)\n                .into_ref_with_type(vm, cls)\n                .map(Into::into)\n        }\n    }\n\n    impl SelfIter for Cursor {}\n    impl IterNext for Cursor {\n        fn next(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyIterReturn> {\n            let mut inner = zelf.inner(vm)?;\n            let Some(stmt) = &inner.statement else {\n                return Ok(PyIterReturn::StopIteration(None));\n            };\n            let st = stmt.lock();\n            let db = zelf.connection.db_lock(vm)?;\n            // fetch_one_row\n\n            let num_cols = st.data_count();\n\n            let mut row = Vec::with_capacity(num_cols as usize);\n\n            for i in 0..num_cols {\n                let val = if let Some(converter) =\n                    inner.row_cast_map.get(i as usize).cloned().flatten()\n                {\n                    let blob = st.column_blob(i);\n                    if blob.is_null() {\n                        vm.ctx.none()\n                    } else {\n                        let nbytes = st.column_bytes(i);\n                        let blob = unsafe {\n                            std::slice::from_raw_parts(blob.cast::<u8>(), nbytes as usize)\n                        };\n                        let blob = vm.ctx.new_bytes(blob.to_vec());\n                        converter.call((blob,), vm)?\n                    }\n                } else {\n                    let col_type = st.column_type(i);\n                    match col_type {\n                        SQLITE_NULL => vm.ctx.none(),\n                        SQLITE_INTEGER => vm.ctx.new_int(st.column_int(i)).into(),\n                        SQLITE_FLOAT => vm.ctx.new_float(st.column_double(i)).into(),\n                        SQLITE_TEXT => {\n                            let text =\n                                ptr_to_vec(st.column_text(i), st.column_bytes(i), db.db, vm)?;\n\n                            let text_factory = zelf.connection.text_factory.to_owned();\n\n                            if text_factory.is(PyStr::class(&vm.ctx)) {\n                                let text = String::from_utf8(text).map_err(|err| {\n                                    let col_name = st.column_name(i);\n                                    let col_name_str = ptr_to_str(col_name, vm).unwrap_or(\"?\");\n                                    let valid_up_to = err.utf8_error().valid_up_to();\n                                    let text_prefix = String::from_utf8_lossy(&err.as_bytes()[..valid_up_to]);\n                                    let msg = format!(\n                                        \"Could not decode to UTF-8 column '{col_name_str}' with text '{text_prefix}'\"\n                                    );\n                                    new_operational_error(vm, msg)\n                                })?;\n                                vm.ctx.new_str(text).into()\n                            } else if text_factory.is(PyBytes::class(&vm.ctx)) {\n                                vm.ctx.new_bytes(text).into()\n                            } else if text_factory.is(PyByteArray::class(&vm.ctx)) {\n                                PyByteArray::from(text).into_ref(&vm.ctx).into()\n                            } else {\n                                let bytes = vm.ctx.new_bytes(text);\n                                text_factory.call((bytes,), vm)?\n                            }\n                        }\n                        SQLITE_BLOB => {\n                            let blob = ptr_to_vec(\n                                st.column_blob(i).cast(),\n                                st.column_bytes(i),\n                                db.db,\n                                vm,\n                            )?;\n\n                            vm.ctx.new_bytes(blob).into()\n                        }\n                        _ => {\n                            return Err(vm.new_not_implemented_error(format!(\n                                \"unknown column type: {col_type}\"\n                            )));\n                        }\n                    }\n                };\n\n                row.push(val);\n            }\n\n            if !st.step_row_else_done(vm)? {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount = db.changes() as i64;\n                }\n                inner.statement = None;\n            } else {\n                drop(st);\n            }\n\n            drop(db);\n            drop(inner);\n\n            let row = vm.ctx.new_tuple(row);\n\n            if let Some(row_factory) = zelf.row_factory.to_owned() {\n                row_factory\n                    .call((zelf.to_owned(), row), vm)\n                    .map(PyIterReturn::Return)\n            } else {\n                Ok(PyIterReturn::Return(row.into()))\n            }\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Row {\n        data: PyTupleRef,\n        description: PyTupleRef,\n    }\n\n    #[pyclass(\n        with(Constructor, Hashable, Comparable, Iterable, AsMapping, AsSequence),\n        flags(BASETYPE)\n    )]\n    impl Row {\n        #[pymethod]\n        fn keys(&self, _vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            Ok(self\n                .description\n                .iter()\n                .map(|x| x.downcast_ref::<PyTuple>().unwrap().as_slice()[0].clone())\n                .collect())\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            if let Some(i) = needle.downcast_ref::<PyInt>() {\n                let i = i.try_to_primitive::<isize>(vm)?;\n                self.data.getitem_by_index(vm, i)\n            } else if let Some(name) = needle.downcast_ref::<PyStr>() {\n                for (obj, i) in self.description.iter().zip(0..) {\n                    let obj = &obj.downcast_ref::<PyTuple>().unwrap().as_slice()[0];\n                    let Some(obj) = obj.downcast_ref::<PyStr>() else {\n                        break;\n                    };\n                    let a_iter = name.as_str().chars().flat_map(|x| x.to_uppercase());\n                    let b_iter = obj.as_str().chars().flat_map(|x| x.to_uppercase());\n\n                    if a_iter.eq(b_iter) {\n                        return self.data.getitem_by_index(vm, i);\n                    }\n                }\n                Err(vm.new_index_error(\"No item with that key\"))\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let list = self.data.getitem_by_slice(vm, slice.to_saturated(vm)?)?;\n                Ok(vm.ctx.new_tuple(list).into())\n            } else {\n                Err(vm.new_index_error(\"Index must be int or string\"))\n            }\n        }\n    }\n\n    impl Constructor for Row {\n        type Args = (PyRef<Cursor>, PyTupleRef);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let description = args\n                .0\n                .inner(vm)?\n                .description\n                .clone()\n                .ok_or_else(|| vm.new_value_error(\"no description in Cursor\"))?;\n\n            Self {\n                data: args.1,\n                description,\n            }\n            .into_ref_with_type(vm, cls)\n            .map(Into::into)\n        }\n    }\n\n    impl Hashable for Row {\n        fn hash(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyHash> {\n            Ok(zelf.description.as_object().hash(vm)? | zelf.data.as_object().hash(vm)?)\n        }\n    }\n\n    impl Comparable for Row {\n        fn cmp(\n            zelf: &Py<Self>,\n            other: &PyObject,\n            op: PyComparisonOp,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyComparisonValue> {\n            op.eq_only(|| {\n                if let Some(other) = other.downcast_ref::<Self>() {\n                    let eq = vm\n                        .bool_eq(zelf.description.as_object(), other.description.as_object())?\n                        && vm.bool_eq(zelf.data.as_object(), other.data.as_object())?;\n                    Ok(eq.into())\n                } else {\n                    Ok(PyComparisonValue::NotImplemented)\n                }\n            })\n        }\n    }\n\n    impl Iterable for Row {\n        fn iter(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            Iterable::iter(zelf.data.clone(), vm)\n        }\n    }\n\n    impl AsMapping for Row {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: std::sync::LazyLock<PyMappingMethods> =\n                std::sync::LazyLock::new(|| PyMappingMethods {\n                    length: atomic_func!(|mapping, _vm| Ok(Row::mapping_downcast(mapping)\n                        .data\n                        .len())),\n                    subscript: atomic_func!(|mapping, needle, vm| {\n                        Row::mapping_downcast(mapping).subscript(needle, vm)\n                    }),\n                    ..PyMappingMethods::NOT_IMPLEMENTED\n                });\n            &AS_MAPPING\n        }\n    }\n\n    impl AsSequence for Row {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: std::sync::LazyLock<PySequenceMethods> =\n                std::sync::LazyLock::new(|| PySequenceMethods {\n                    length: atomic_func!(|seq, _vm| Ok(Row::sequence_downcast(seq).data.len())),\n                    item: atomic_func!(|seq, i, vm| Row::sequence_downcast(seq)\n                        .data\n                        .getitem_by_index(vm, i)),\n                    ..PySequenceMethods::NOT_IMPLEMENTED\n                });\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Blob\", traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Blob {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        inner: PyMutex<Option<BlobInner>>,\n    }\n\n    impl Unconstructible for Blob {}\n\n    #[derive(Debug)]\n    struct BlobInner {\n        blob: SqliteBlob,\n        offset: c_int,\n    }\n\n    impl Drop for BlobInner {\n        fn drop(&mut self) {\n            unsafe { sqlite3_blob_close(self.blob.blob) };\n        }\n    }\n\n    #[pyclass(with(AsMapping, Unconstructible, AsNumber, AsSequence))]\n    impl Blob {\n        #[pymethod]\n        fn close(&self) {\n            self.inner.lock().take();\n        }\n\n        #[pymethod]\n        fn read(\n            &self,\n            length: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<PyBytes>> {\n            let mut length = length.unwrap_or(-1);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let max_read = blob_len - inner.offset;\n\n            if length < 0 || length > max_read {\n                length = max_read;\n            }\n\n            if length == 0 {\n                Ok(vm.ctx.empty_bytes.clone())\n            } else {\n                let mut buf = Vec::<u8>::with_capacity(length as usize);\n                let ret = inner\n                    .blob\n                    .read(buf.as_mut_ptr().cast(), length, inner.offset);\n                self.check(ret, vm)?;\n                unsafe { buf.set_len(length as usize) };\n                inner.offset += length;\n                Ok(vm.ctx.new_bytes(buf))\n            }\n        }\n\n        #[pymethod]\n        fn write(&self, data: PyBuffer, vm: &VirtualMachine) -> PyResult<()> {\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let length = Self::expect_write(blob_len, data.desc.len, inner.offset, vm)?;\n\n            let ret = data.contiguous_or_collect(|buf| {\n                inner.blob.write(buf.as_ptr().cast(), length, inner.offset)\n            });\n\n            self.check(ret, vm)?;\n            inner.offset += length;\n            Ok(())\n        }\n\n        #[pymethod]\n        fn tell(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.inner(vm).map(|x| x.offset)\n        }\n\n        #[pymethod]\n        fn seek(\n            &self,\n            mut offset: c_int,\n            origin: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let origin = origin.unwrap_or(libc::SEEK_SET);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n\n            let overflow_err = || vm.new_overflow_error(\"seek offset results in overflow\");\n\n            match origin {\n                libc::SEEK_SET => {}\n                libc::SEEK_CUR => {\n                    offset = offset.checked_add(inner.offset).ok_or_else(overflow_err)?\n                }\n                libc::SEEK_END => offset = offset.checked_add(blob_len).ok_or_else(overflow_err)?,\n                _ => {\n                    return Err(vm.new_value_error(\n                        \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\",\n                    ));\n                }\n            }\n\n            if offset < 0 || offset > blob_len {\n                Err(vm.new_value_error(\"offset out of blob range\"))\n            } else {\n                inner.offset = offset;\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult<PyRef<Self>> {\n            let _ = zelf.inner(vm)?;\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn __exit__(&self, _args: FuncArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let _ = self.inner(vm)?;\n            self.close();\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, BlobInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Cannot operate on a closed blob.\".to_owned(),\n                ))\n            }\n        }\n\n        fn wrapped_index(index: PyIntRef, length: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let mut index = index.try_to_primitive::<c_int>(vm)?;\n            if index < 0 {\n                index += length;\n            }\n            if index < 0 || index >= length {\n                Err(vm.new_index_error(\"Blob index out of range\"))\n            } else {\n                Ok(index)\n            }\n        }\n\n        fn expect_write(\n            blob_len: c_int,\n            length: usize,\n            offset: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<c_int> {\n            let max_write = blob_len - offset;\n            if length <= max_write as usize {\n                Ok(length as c_int)\n            } else {\n                Err(vm.new_value_error(\"data longer than blob length\"))\n            }\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            let inner = self.inner(vm)?;\n            if let Some(index) = needle.try_index_opt(vm) {\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                let mut byte: u8 = 0;\n                let ret = inner.blob.read_single(&mut byte, index);\n                self.check(ret, vm).map(|_| vm.ctx.new_int(byte).into())\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, length) = slice.adjust_indices(blob_len as usize);\n                let mut buf = Vec::<u8>::with_capacity(length);\n\n                if step == 1 {\n                    let ret = inner.blob.read(\n                        buf.as_mut_ptr().cast(),\n                        length as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n                    unsafe { buf.set_len(length) };\n                } else {\n                    let iter = SaturatedSliceIter::from_adjust_indices(range, step, length);\n                    let mut byte: u8 = 0;\n                    for index in iter {\n                        let ret = inner.blob.read_single(&mut byte, index as c_int);\n                        self.check(ret, vm)?;\n                        buf.push(byte);\n                    }\n                }\n                Ok(vm.ctx.new_bytes(buf).into())\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn ass_subscript(\n            &self,\n            needle: &PyObject,\n            value: Option<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(value) = value else {\n                return Err(vm.new_type_error(\"Blob doesn't support slice deletion\"));\n            };\n            let inner = self.inner(vm)?;\n\n            if let Some(index) = needle.try_index_opt(vm) {\n                // Handle single item assignment: blob[i] = b\n                let Some(value) = value.downcast_ref::<PyInt>() else {\n                    return Err(vm.new_type_error(format!(\n                        \"'{}' object cannot be interpreted as an integer\",\n                        value.class()\n                    )));\n                };\n                let value = value.try_to_primitive::<u8>(vm)?;\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                Self::expect_write(blob_len, 1, index, vm)?;\n                let ret = inner.blob.write_single(value, index);\n                self.check(ret, vm)\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                // Handle slice assignment: blob[a:b:c] = b\"...\"\n                let value_buf = PyBuffer::try_from_borrowed_object(vm, &value)?;\n\n                let buf = value_buf\n                    .as_contiguous()\n                    .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, slice_len) = slice.adjust_indices(blob_len as usize);\n\n                if step == 0 {\n                    return Err(vm.new_value_error(\"slice step cannot be zero\"));\n                }\n\n                if buf.len() != slice_len {\n                    return Err(vm.new_index_error(\"Blob slice assignment is wrong size\"));\n                }\n\n                if slice_len == 0 {\n                    return Ok(());\n                }\n\n                if step == 1 {\n                    let ret = inner.blob.write(\n                        buf.as_ptr().cast(),\n                        buf.len() as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                } else {\n                    let span_len = range.end - range.start;\n                    let mut temp_buf = vec![0u8; span_len];\n\n                    let ret = inner.blob.read(\n                        temp_buf.as_mut_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n\n                    let mut i_in_temp: usize = 0;\n                    for i_in_src in 0..slice_len {\n                        temp_buf[i_in_temp] = buf[i_in_src];\n                        i_in_temp += step as usize;\n                    }\n\n                    let ret = inner.blob.write(\n                        temp_buf.as_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                }\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn check(&self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.connection.db_lock(vm)?.error_extended(vm))\n            }\n        }\n    }\n\n    impl AsMapping for Blob {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: PyMappingMethods = PyMappingMethods {\n                length: atomic_func!(|mapping, vm| Blob::mapping_downcast(mapping)\n                    .inner(vm)\n                    .map(|x| x.blob.bytes() as usize)),\n                subscript: atomic_func!(|mapping, needle, vm| {\n                    Blob::mapping_downcast(mapping).subscript(needle, vm)\n                }),\n                ass_subscript: atomic_func!(|mapping, needle, value, vm| {\n                    Blob::mapping_downcast(mapping).ass_subscript(needle, value, vm)\n                }),\n            };\n            &AS_MAPPING\n        }\n    }\n\n    impl AsNumber for Blob {\n        fn as_number() -> &'static PyNumberMethods {\n            static AS_NUMBER: PyNumberMethods = PyNumberMethods {\n                add: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for +: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                multiply: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for *: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                ..PyNumberMethods::NOT_IMPLEMENTED\n            };\n            &AS_NUMBER\n        }\n    }\n\n    impl AsSequence for Blob {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: PySequenceMethods = PySequenceMethods {\n                length: AtomicCell::new(None),\n                concat: AtomicCell::new(None),\n                repeat: AtomicCell::new(None),\n                item: AtomicCell::new(None),\n                ass_item: AtomicCell::new(None),\n                contains: atomic_func!(|seq, _needle, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"argument of type '{}' is not iterable\",\n                        seq.obj.class().name(),\n                    )))\n                }),\n                inplace_concat: AtomicCell::new(None),\n                inplace_repeat: AtomicCell::new(None),\n            };\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(Debug, PyPayload)]\n    struct PrepareProtocol {}\n\n    #[pyclass()]\n    impl PrepareProtocol {}\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Statement\")]\n    #[derive(PyPayload)]\n    struct Statement {\n        st: PyMutex<SqliteStatement>,\n        pub is_dml: bool,\n    }\n\n    impl Debug for Statement {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(\n                f,\n                \"{} Statement\",\n                if self.is_dml { \"DML\" } else { \"Non-DML\" }\n            )\n        }\n    }\n\n    impl Unconstructible for Statement {}\n\n    #[pyclass(with(Unconstructible))]\n    impl Statement {\n        fn new(\n            connection: &Connection,\n            sql: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<Self>> {\n            if sql.as_str().contains('\\0') {\n                return Err(new_programming_error(\n                    vm,\n                    \"statement contains a null character.\".to_owned(),\n                ));\n            }\n            let sql_cstr = sql.to_cstring(vm)?;\n\n            let db = connection.db_lock(vm)?;\n\n            db.sql_limit(sql.byte_len(), vm)?;\n\n            let mut tail = null();\n            let st = db.prepare(sql_cstr.as_ptr(), &mut tail, vm)?;\n\n            let Some(st) = st else {\n                return Ok(None);\n            };\n\n            let tail = unsafe { CStr::from_ptr(tail) };\n            let tail = tail.to_bytes();\n            if lstrip_sql(tail).is_some() {\n                return Err(new_programming_error(\n                    vm,\n                    \"You can only execute one statement at a time.\".to_owned(),\n                ));\n            }\n\n            let is_dml = if let Some(head) = lstrip_sql(sql_cstr.as_bytes()) {\n                head.len() >= 6\n                    && (head[..6].eq_ignore_ascii_case(b\"insert\")\n                        || head[..6].eq_ignore_ascii_case(b\"update\")\n                        || head[..6].eq_ignore_ascii_case(b\"delete\")\n                        || (head.len() >= 7 && head[..7].eq_ignore_ascii_case(b\"replace\")))\n            } else {\n                false\n            };\n\n            Ok(Some(Self {\n                st: PyMutex::from(st),\n                is_dml,\n            }))\n        }\n\n        fn lock(&self) -> PyMutexGuard<'_, SqliteStatement> {\n            self.st.lock()\n        }\n    }\n\n    struct Sqlite {\n        raw: SqliteRaw,\n    }\n\n    impl From<SqliteRaw> for Sqlite {\n        fn from(raw: SqliteRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for Sqlite {\n        fn drop(&mut self) {\n            unsafe { sqlite3_close_v2(self.raw.db) };\n        }\n    }\n\n    impl Deref for Sqlite {\n        type Target = SqliteRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteRaw {\n        db: *mut sqlite3,\n    }\n\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"threading\")] {\n            unsafe impl Send for SqliteStatement {}\n            // unsafe impl Sync for SqliteStatement {}\n            unsafe impl Send for Sqlite {}\n            // unsafe impl Sync for Sqlite {}\n            unsafe impl Send for SqliteBlob {}\n        }\n    }\n\n    impl From<SqliteStatementRaw> for SqliteRaw {\n        fn from(stmt: SqliteStatementRaw) -> Self {\n            unsafe {\n                Self {\n                    db: sqlite3_db_handle(stmt.st),\n                }\n            }\n        }\n    }\n\n    impl SqliteRaw {\n        fn check(self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.error_extended(vm))\n            }\n        }\n\n        fn error_extended(self, vm: &VirtualMachine) -> PyBaseExceptionRef {\n            let errcode = unsafe { sqlite3_errcode(self.db) };\n            let typ = exception_type_from_errcode(errcode, vm);\n            let extended_errcode = unsafe { sqlite3_extended_errcode(self.db) };\n            let errmsg = unsafe { sqlite3_errmsg(self.db) };\n            let errmsg = unsafe { CStr::from_ptr(errmsg) };\n            let errmsg = errmsg.to_str().unwrap().to_owned();\n\n            raise_exception(typ.to_owned(), extended_errcode, errmsg, vm)\n        }\n\n        fn open(path: *const libc::c_char, uri: bool, vm: &VirtualMachine) -> PyResult<Self> {\n            let mut db = null_mut();\n            let ret = unsafe {\n                sqlite3_open_v2(\n                    path,\n                    &raw mut db,\n                    SQLITE_OPEN_READWRITE\n                        | SQLITE_OPEN_CREATE\n                        | if uri { SQLITE_OPEN_URI } else { 0 },\n                    null(),\n                )\n            };\n            let zelf = Self { db };\n            zelf.check(ret, vm).map(|_| zelf)\n        }\n\n        fn _exec(self, sql: &[u8], vm: &VirtualMachine) -> PyResult<()> {\n            let ret =\n                unsafe { sqlite3_exec(self.db, sql.as_ptr().cast(), None, null_mut(), null_mut()) };\n            self.check(ret, vm)\n        }\n\n        fn prepare(\n            self,\n            sql: *const libc::c_char,\n            tail: *mut *const libc::c_char,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<SqliteStatement>> {\n            let mut st = null_mut();\n            let ret = unsafe { sqlite3_prepare_v2(self.db, sql, -1, &mut st, tail) };\n            self.check(ret, vm)?;\n            if st.is_null() {\n                Ok(None)\n            } else {\n                Ok(Some(SqliteStatement::from(SqliteStatementRaw::from(st))))\n            }\n        }\n\n        fn limit(self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let old_limit = unsafe { sqlite3_limit(self.db, category, limit) };\n            if old_limit >= 0 {\n                Ok(old_limit)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"'category' is out of bounds\".to_owned(),\n                ))\n            }\n        }\n\n        fn sql_limit(self, len: usize, vm: &VirtualMachine) -> PyResult<()> {\n            if len <= unsafe { sqlite3_limit(self.db, SQLITE_LIMIT_SQL_LENGTH, -1) } as usize {\n                Ok(())\n            } else {\n                Err(new_data_error(vm, \"query string is too large\".to_owned()))\n            }\n        }\n\n        fn is_autocommit(self) -> bool {\n            unsafe { sqlite3_get_autocommit(self.db) != 0 }\n        }\n\n        fn changes(self) -> c_int {\n            unsafe { sqlite3_changes(self.db) }\n        }\n\n        fn total_changes(self) -> c_int {\n            unsafe { sqlite3_total_changes(self.db) }\n        }\n\n        fn lastrowid(self) -> c_longlong {\n            unsafe { sqlite3_last_insert_rowid(self.db) }\n        }\n\n        fn implicit_commit(self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.is_autocommit() {\n                Ok(())\n            } else {\n                self._exec(b\"COMMIT\\0\", vm)\n            }\n        }\n\n        fn begin_transaction(\n            self,\n            isolation_level: Option<PyStrRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(isolation_level) = isolation_level else {\n                return Ok(());\n            };\n            let mut s = Vec::with_capacity(16);\n            s.extend(b\"BEGIN \");\n            s.extend(isolation_level.as_str().bytes());\n            s.push(b'\\0');\n            self._exec(&s, vm)\n        }\n\n        fn interrupt(self) {\n            unsafe { sqlite3_interrupt(self.db) }\n        }\n\n        fn busy_timeout(self, timeout: i32) {\n            unsafe { sqlite3_busy_timeout(self.db, timeout) };\n        }\n\n        #[allow(clippy::too_many_arguments)]\n        fn create_function(\n            self,\n            name: *const libc::c_char,\n            narg: c_int,\n            flags: c_int,\n            data: *mut c_void,\n            func: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            step: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            finalize: Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n            destroy: Option<unsafe extern \"C\" fn(arg1: *mut c_void)>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let ret = unsafe {\n                sqlite3_create_function_v2(\n                    self.db, name, narg, flags, data, func, step, finalize, destroy,\n                )\n            };\n            self.check(ret, vm)\n                .map_err(|_| new_operational_error(vm, \"Error creating function\".to_owned()))\n        }\n    }\n\n    struct SqliteStatement {\n        raw: SqliteStatementRaw,\n    }\n\n    impl From<SqliteStatementRaw> for SqliteStatement {\n        fn from(raw: SqliteStatementRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for SqliteStatement {\n        fn drop(&mut self) {\n            unsafe {\n                sqlite3_finalize(self.raw.st);\n            }\n        }\n    }\n\n    impl Deref for SqliteStatement {\n        type Target = SqliteStatementRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteStatementRaw {\n        st: *mut sqlite3_stmt,\n    }\n\n    impl From<*mut sqlite3_stmt> for SqliteStatementRaw {\n        fn from(st: *mut sqlite3_stmt) -> Self {\n            SqliteStatementRaw { st }\n        }\n    }\n\n    impl SqliteStatementRaw {\n        fn step(self) -> c_int {\n            unsafe { sqlite3_step(self.st) }\n        }\n\n        fn step_row_else_done(self, vm: &VirtualMachine) -> PyResult<bool> {\n            let ret = self.step();\n\n            if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                Err(exc)\n            } else if ret == SQLITE_ROW {\n                Ok(true)\n            } else if ret == SQLITE_DONE {\n                Ok(false)\n            } else {\n                Err(SqliteRaw::from(self).error_extended(vm))\n            }\n        }\n\n        fn reset(self) {\n            unsafe { sqlite3_reset(self.st) };\n        }\n\n        fn data_count(self) -> c_int {\n            unsafe { sqlite3_data_count(self.st) }\n        }\n\n        fn bind_parameter(\n            self,\n            pos: c_int,\n            parameter: &PyObject,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let adapted;\n            let obj = if need_adapt(parameter, vm) {\n                adapted = _adapt(\n                    parameter,\n                    PrepareProtocol::class(&vm.ctx).to_owned(),\n                    |x| Ok(x.to_owned()),\n                    vm,\n                )?;\n                &adapted\n            } else {\n                parameter\n            };\n\n            let ret = if vm.is_none(obj) {\n                unsafe { sqlite3_bind_null(self.st, pos) }\n            } else if let Some(val) = obj.downcast_ref::<PyInt>() {\n                let val = val.try_to_primitive::<i64>(vm).map_err(|_| {\n                    vm.new_overflow_error(\"Python int too large to convert to SQLite INTEGER\")\n                })?;\n                unsafe { sqlite3_bind_int64(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyFloat>() {\n                let val = val.to_f64();\n                unsafe { sqlite3_bind_double(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyStr>() {\n                let val = val.try_as_utf8(vm)?;\n                let (ptr, len) = str_to_ptr_len(val, vm)?;\n                unsafe { sqlite3_bind_text(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, obj) {\n                let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                unsafe { sqlite3_bind_blob(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Error binding parameter {}: type '{}' is not supported\",\n                        pos,\n                        obj.class()\n                    ),\n                ));\n            };\n\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                let db = SqliteRaw::from(self);\n                db.check(ret, vm)\n            }\n        }\n\n        fn bind_parameters(self, parameters: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            if let Some(dict) = parameters.downcast_ref::<PyDict>() {\n                self.bind_parameters_name(dict, vm)\n            } else if let Ok(seq) = PySequence::try_protocol(parameters, vm) {\n                self.bind_parameters_sequence(seq, vm)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"parameters are of unsupported type\".to_owned(),\n                ))\n            }\n        }\n\n        fn bind_parameters_name(self, dict: &Py<PyDict>, vm: &VirtualMachine) -> PyResult<()> {\n            let num_needed = unsafe { sqlite3_bind_parameter_count(self.st) };\n\n            for i in 1..=num_needed {\n                let name = unsafe { sqlite3_bind_parameter_name(self.st, i) };\n                if name.is_null() {\n                    return Err(new_programming_error(vm, \"Binding {} has no name, but you supplied a dictionary (which has only names).\".to_owned()));\n                }\n                let name = unsafe { name.add(1) };\n                let name = ptr_to_str(name, vm)?;\n\n                let val = match dict.get_item_opt(name, vm)? {\n                    Some(val) => val,\n                    None => {\n                        return Err(new_programming_error(\n                            vm,\n                            format!(\"You did not supply a value for binding parameter :{name}.\",),\n                        ));\n                    }\n                };\n\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn bind_parameter_count(self) -> c_int {\n            unsafe { sqlite3_bind_parameter_count(self.st) }\n        }\n\n        fn bind_parameters_sequence(\n            self,\n            seq: PySequence<'_>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let num_needed = self.bind_parameter_count();\n            let num_supplied = seq.length(vm)?;\n\n            if num_supplied != num_needed as usize {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Incorrect number of bindings supplied. The current statement uses {}, and {} were supplied.\",\n                        num_needed, num_supplied\n                    ),\n                ));\n            }\n\n            for i in 1..=num_needed {\n                let val = seq.get_item(i as isize - 1, vm)?;\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn column_count(self) -> c_int {\n            unsafe { sqlite3_column_count(self.st) }\n        }\n\n        fn column_type(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_type(self.st, pos) }\n        }\n\n        fn column_int(self, pos: c_int) -> i64 {\n            unsafe { sqlite3_column_int64(self.st, pos) }\n        }\n\n        fn column_double(self, pos: c_int) -> f64 {\n            unsafe { sqlite3_column_double(self.st, pos) }\n        }\n\n        fn column_blob(self, pos: c_int) -> *const c_void {\n            unsafe { sqlite3_column_blob(self.st, pos) }\n        }\n\n        fn column_text(self, pos: c_int) -> *const u8 {\n            unsafe { sqlite3_column_text(self.st, pos) }\n        }\n\n        fn column_decltype(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_decltype(self.st, pos) }\n        }\n\n        fn column_bytes(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_bytes(self.st, pos) }\n        }\n\n        fn column_name(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_name(self.st, pos) }\n        }\n\n        fn columns_name(self, detect_types: i32, vm: &VirtualMachine) -> PyResult<Vec<PyStrRef>> {\n            let count = self.column_count();\n            (0..count)\n                .map(|i| {\n                    let name = self.column_name(i);\n                    let name_str = ptr_to_str(name, vm)?;\n\n                    // If PARSE_COLNAMES is enabled, strip everything after the first '[' (and preceding space)\n                    let processed_name = if detect_types & PARSE_COLNAMES != 0\n                        && let Some(bracket_pos) = name_str.find('[')\n                    {\n                        // Check if there's a single space before '[' and remove it (CPython compatibility)\n                        let end_pos = if bracket_pos > 0\n                            && name_str.chars().nth(bracket_pos - 1) == Some(' ')\n                        {\n                            bracket_pos - 1\n                        } else {\n                            bracket_pos\n                        };\n\n                        &name_str[..end_pos]\n                    } else {\n                        name_str\n                    };\n\n                    Ok(vm.ctx.new_str(processed_name))\n                })\n                .collect()\n        }\n\n        fn columns_description(\n            self,\n            detect_types: i32,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<PyTupleRef>> {\n            if self.column_count() == 0 {\n                return Ok(None);\n            }\n            let columns = self\n                .columns_name(detect_types, vm)?\n                .into_iter()\n                .map(|s| {\n                    vm.ctx\n                        .new_tuple(vec![\n                            s.into(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                        ])\n                        .into()\n                })\n                .collect();\n            Ok(Some(vm.ctx.new_tuple(columns)))\n        }\n\n        fn busy(self) -> bool {\n            unsafe { sqlite3_stmt_busy(self.st) != 0 }\n        }\n\n        fn readonly(self) -> bool {\n            unsafe { sqlite3_stmt_readonly(self.st) != 0 }\n        }\n    }\n\n    #[derive(Debug, Copy, Clone)]\n    struct SqliteBlob {\n        blob: *mut sqlite3_blob,\n    }\n\n    impl SqliteBlob {\n        fn bytes(self) -> c_int {\n            unsafe { sqlite3_blob_bytes(self.blob) }\n        }\n\n        fn write(self, buf: *const c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_write(self.blob, buf, length, offset) }\n        }\n\n        fn read(self, buf: *mut c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_read(self.blob, buf, length, offset) }\n        }\n\n        fn read_single(self, byte: &mut u8, offset: c_int) -> c_int {\n            self.read(byte as *mut u8 as *mut _, 1, offset)\n        }\n\n        fn write_single(self, byte: u8, offset: c_int) -> c_int {\n            self.write(&byte as *const u8 as *const _, 1, offset)\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteContext {\n        ctx: *mut sqlite3_context,\n    }\n\n    impl From<*mut sqlite3_context> for SqliteContext {\n        fn from(ctx: *mut sqlite3_context) -> Self {\n            Self { ctx }\n        }\n    }\n\n    impl SqliteContext {\n        fn user_data<T>(self) -> *mut T {\n            unsafe { sqlite3_user_data(self.ctx).cast() }\n        }\n\n        fn aggregate_context<T>(self) -> *mut T {\n            unsafe { sqlite3_aggregate_context(self.ctx, std::mem::size_of::<T>() as c_int).cast() }\n        }\n\n        fn result_exception(self, vm: &VirtualMachine, exc: PyBaseExceptionRef, msg: &str) {\n            if exc.fast_isinstance(vm.ctx.exceptions.memory_error) {\n                unsafe { sqlite3_result_error_nomem(self.ctx) }\n            } else if exc.fast_isinstance(vm.ctx.exceptions.overflow_error) {\n                unsafe { sqlite3_result_error_toobig(self.ctx) }\n            } else {\n                unsafe { sqlite3_result_error(self.ctx, msg.as_ptr().cast(), -1) }\n            }\n            if enable_traceback().load(Ordering::Relaxed) {\n                vm.print_exception(exc);\n            }\n        }\n\n        fn db_handle(self) -> *mut sqlite3 {\n            unsafe { sqlite3_context_db_handle(self.ctx) }\n        }\n\n        fn result_from_object(self, val: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            unsafe {\n                if vm.is_none(val) {\n                    sqlite3_result_null(self.ctx)\n                } else if let Some(val) = val.downcast_ref::<PyInt>() {\n                    sqlite3_result_int64(self.ctx, val.try_to_primitive(vm)?)\n                } else if let Some(val) = val.downcast_ref::<PyFloat>() {\n                    sqlite3_result_double(self.ctx, val.to_f64())\n                } else if let Some(val) = val.downcast_ref::<PyStr>() {\n                    let val = val.try_as_utf8(vm)?;\n                    let (ptr, len) = str_to_ptr_len(val, vm)?;\n                    sqlite3_result_text(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, val) {\n                    let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                    sqlite3_result_blob(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else {\n                    return Err(new_programming_error(\n                        vm,\n                        \"result type not support\".to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n    }\n\n    fn value_to_object(val: *mut sqlite3_value, db: *mut sqlite3, vm: &VirtualMachine) -> PyResult {\n        let obj = unsafe {\n            match sqlite3_value_type(val) {\n                SQLITE_INTEGER => vm.ctx.new_int(sqlite3_value_int64(val)).into(),\n                SQLITE_FLOAT => vm.ctx.new_float(sqlite3_value_double(val)).into(),\n                SQLITE_TEXT => {\n                    let text =\n                        ptr_to_vec(sqlite3_value_text(val), sqlite3_value_bytes(val), db, vm)?;\n                    let text = String::from_utf8(text)\n                        .map_err(|_| vm.new_value_error(\"invalid utf-8 with SQLITE_TEXT\"))?;\n                    vm.ctx.new_str(text).into()\n                }\n                SQLITE_BLOB => {\n                    let blob = ptr_to_vec(\n                        sqlite3_value_blob(val).cast(),\n                        sqlite3_value_bytes(val),\n                        db,\n                        vm,\n                    )?;\n                    vm.ctx.new_bytes(blob).into()\n                }\n                _ => vm.ctx.none(),\n            }\n        };\n        Ok(obj)\n    }\n\n    fn ptr_to_str<'a>(p: *const libc::c_char, vm: &VirtualMachine) -> PyResult<&'a str> {\n        if p.is_null() {\n            return Err(vm.new_memory_error(\"string pointer is null\"));\n        }\n        unsafe { CStr::from_ptr(p).to_str() }\n            .map_err(|_| vm.new_value_error(\"Invalid UIF-8 codepoint\"))\n    }\n\n    fn ptr_to_string(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<String> {\n        let s = ptr_to_vec(p, nbytes, db, vm)?;\n        String::from_utf8(s).map_err(|_| vm.new_value_error(\"invalid utf-8\"))\n    }\n\n    fn ptr_to_vec(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<Vec<u8>> {\n        if p.is_null() {\n            if !db.is_null() && unsafe { sqlite3_errcode(db) } == SQLITE_NOMEM {\n                Err(vm.new_memory_error(\"sqlite out of memory\"))\n            } else {\n                Ok(vec![])\n            }\n        } else if nbytes < 0 {\n            Err(vm.new_system_error(\"negative size with ptr\"))\n        } else {\n            Ok(unsafe { std::slice::from_raw_parts(p.cast(), nbytes as usize) }.to_vec())\n        }\n    }\n\n    fn str_to_ptr_len(s: &PyUtf8Str, vm: &VirtualMachine) -> PyResult<(*const libc::c_char, i32)> {\n        let s_str = s.as_str();\n        let len = c_int::try_from(s_str.len())\n            .map_err(|_| vm.new_overflow_error(\"TEXT longer than INT_MAX bytes\"))?;\n        let ptr = s_str.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn buffer_to_ptr_len(buffer: &PyBuffer, vm: &VirtualMachine) -> PyResult<(*const c_void, i32)> {\n        let bytes = buffer\n            .as_contiguous()\n            .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n        let len = c_int::try_from(bytes.len())\n            .map_err(|_| vm.new_overflow_error(\"BLOB longer than INT_MAX bytes\"))?;\n        let ptr = bytes.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn exception_type_from_errcode(errcode: c_int, vm: &VirtualMachine) -> &'static Py<PyType> {\n        match errcode {\n            SQLITE_INTERNAL | SQLITE_NOTFOUND => internal_error_type(),\n            SQLITE_NOMEM => vm.ctx.exceptions.memory_error,\n            SQLITE_ERROR | SQLITE_PERM | SQLITE_ABORT | SQLITE_BUSY | SQLITE_LOCKED\n            | SQLITE_READONLY | SQLITE_INTERRUPT | SQLITE_IOERR | SQLITE_FULL | SQLITE_CANTOPEN\n            | SQLITE_PROTOCOL | SQLITE_EMPTY | SQLITE_SCHEMA => operational_error_type(),\n            SQLITE_CORRUPT => database_error_type(),\n            SQLITE_TOOBIG => data_error_type(),\n            SQLITE_CONSTRAINT | SQLITE_MISMATCH => integrity_error_type(),\n            SQLITE_MISUSE | SQLITE_RANGE => interface_error_type(),\n            _ => database_error_type(),\n        }\n    }\n\n    fn name_from_errcode(errcode: c_int) -> &'static str {\n        for (name, code) in ERROR_CODES {\n            if *code == errcode {\n                return name;\n            }\n        }\n        \"unknown error code\"\n    }\n\n    fn raise_exception(\n        typ: PyTypeRef,\n        errcode: c_int,\n        msg: String,\n        vm: &VirtualMachine,\n    ) -> PyBaseExceptionRef {\n        let dict = vm.ctx.new_dict();\n        if let Err(e) = dict.set_item(\"sqlite_errorcode\", vm.ctx.new_int(errcode).into(), vm) {\n            return e;\n        }\n        let errname = name_from_errcode(errcode);\n        if let Err(e) = dict.set_item(\"sqlite_errorname\", vm.ctx.new_str(errname).into(), vm) {\n            return e;\n        }\n\n        vm.new_exception_msg_dict(typ, msg, dict)\n    }\n\n    static BEGIN_STATEMENTS: &[&[u8]] = &[\n        b\"BEGIN \",\n        b\"BEGIN DEFERRED\",\n        b\"BEGIN IMMEDIATE\",\n        b\"BEGIN EXCLUSIVE\",\n    ];\n\n    fn begin_statement_ptr_from_isolation_level(\n        s: &PyStr,\n        vm: &VirtualMachine,\n    ) -> PyResult<*const libc::c_char> {\n        BEGIN_STATEMENTS\n            .iter()\n            .find(|&&x| x[6..].eq_ignore_ascii_case(s.as_bytes()))\n            .map(|&x| x.as_ptr().cast())\n            .ok_or_else(|| {\n                vm.new_value_error(\n                    \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or 'EXCLUSIVE'\",\n                )\n            })\n    }\n\n    fn lstrip_sql(sql: &[u8]) -> Option<&[u8]> {\n        let mut pos = 0;\n\n        // This loop is borrowed from the SQLite source code.\n        while let Some(t_char) = sql.get(pos) {\n            match t_char {\n                b' ' | b'\\t' | b'\\x0c' | b'\\n' | b'\\r' => {\n                    // Skip whitespace.\n                    pos += 1;\n                }\n                b'-' => {\n                    // Skip line comments.\n                    if sql.get(pos + 1) == Some(&b'-') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'\\n' {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                b'/' => {\n                    // Skip C style comments.\n                    if sql.get(pos + 1) == Some(&b'*') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'*' && sql.get(pos + 1) == Some(&b'/') {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                        pos += 2;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                _ => {\n                    return Some(&sql[pos..]);\n                }\n            }\n        }\n\n        None\n    }\n}\n"
                }
              ],
              []
            ],
            "kind": "textEditGroup",
            "uri": {
              "$mid": 1,
              "external": "file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "fsPath": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "path": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "scheme": "file"
            }
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "textEditGroup",
          "input": {
            "done": true,
            "edits": [
              [
                {
                  "range": {
                    "endColumn": 1,
                    "endLineNumber": 3391,
                    "startColumn": 1,
                    "startLineNumber": 1
                  },
                  "text": "// spell-checker:ignore libsqlite3 threadsafety PYSQLITE decltypes colnames collseq cantinit dirtywal\n// spell-checker:ignore corruptfs narg setinputsizes setoutputsize lastrowid arraysize executemany\n// spell-checker:ignore blobopen executescript iterdump getlimit setlimit errorcode errorname\n// spell-checker:ignore rowid rowcount fetchone fetchmany fetchall errcode errname vtable pagecount\n// spell-checker:ignore autocommit libversion toobig errmsg nomem threadsafe longlong vdbe reindex\n// spell-checker:ignore savepoint cantopen ioerr nolfs nomem notadb notfound fullpath notempdir vtab\n// spell-checker:ignore checkreservedlock noent fstat rdlock shmlock shmmap shmopen shmsize sharedcache\n// spell-checker:ignore cantlock commithook foreignkey notnull primarykey gettemppath autoindex convpath\n// spell-checker:ignore dbmoved vnode nbytes\n\nuse rustpython_vm::{AsObject, PyRef, VirtualMachine, builtins::PyModule};\n\n// pub(crate) use _sqlite::make_module;\npub(crate) fn make_module(vm: &VirtualMachine) -> PyRef<PyModule> {\n    // TODO: sqlite version check\n    let module = _sqlite::make_module(vm);\n    _sqlite::setup_module(module.as_object(), vm);\n    module\n}\n\n#[pymodule]\nmod _sqlite {\n    use crossbeam_utils::atomic::AtomicCell;\n    use libsqlite3_sys::{\n        SQLITE_BLOB, SQLITE_DETERMINISTIC, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL,\n        SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, SQLITE_OPEN_URI, SQLITE_TEXT, SQLITE_TRACE_STMT,\n        SQLITE_TRANSIENT, SQLITE_UTF8, sqlite3, sqlite3_aggregate_context, sqlite3_backup_finish,\n        sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining,\n        sqlite3_backup_step, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64,\n        sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name,\n        sqlite3_bind_text, sqlite3_blob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open,\n        sqlite3_blob_read, sqlite3_blob_write, sqlite3_busy_timeout, sqlite3_changes,\n        sqlite3_close_v2, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count,\n        sqlite3_column_decltype, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_name,\n        sqlite3_column_text, sqlite3_column_type, sqlite3_complete, sqlite3_context,\n        sqlite3_context_db_handle, sqlite3_create_collation_v2, sqlite3_create_function_v2,\n        sqlite3_create_window_function, sqlite3_data_count, sqlite3_db_handle, sqlite3_errcode,\n        sqlite3_errmsg, sqlite3_exec, sqlite3_expanded_sql, sqlite3_extended_errcode,\n        sqlite3_finalize, sqlite3_get_autocommit, sqlite3_interrupt, sqlite3_last_insert_rowid,\n        sqlite3_libversion, sqlite3_limit, sqlite3_open_v2, sqlite3_prepare_v2,\n        sqlite3_progress_handler, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double,\n        sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_error_toobig,\n        sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_set_authorizer,\n        sqlite3_sleep, sqlite3_step, sqlite3_stmt, sqlite3_stmt_busy, sqlite3_stmt_readonly,\n        sqlite3_threadsafe, sqlite3_total_changes, sqlite3_trace_v2, sqlite3_user_data,\n        sqlite3_value, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double,\n        sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type,\n    };\n    use malachite_bigint::Sign;\n    use rustpython_common::{\n        atomic::{Ordering, PyAtomic, Radium},\n        hash::PyHash,\n        lock::{PyMappedMutexGuard, PyMutex, PyMutexGuard},\n        static_cell,\n    };\n    use rustpython_vm::{\n        __exports::paste,\n        AsObject, Py, PyAtomicRef, PyObject, PyObjectRef, PyPayload, PyRef, PyResult,\n        TryFromBorrowedObject, VirtualMachine, atomic_func,\n        builtins::{\n            PyBaseException, PyBaseExceptionRef, PyByteArray, PyBytes, PyDict, PyDictRef, PyFloat,\n            PyInt, PyIntRef, PySlice, PyStr, PyStrRef, PyTuple, PyTupleRef, PyType, PyTypeRef,\n            PyUtf8Str, PyUtf8StrRef,\n        },\n        convert::IntoObject,\n        function::{\n            ArgCallable, ArgIterable, FsPath, FuncArgs, OptionalArg, PyComparisonValue,\n            PySetterValue,\n        },\n        object::{Traverse, TraverseFn},\n        protocol::{\n            PyBuffer, PyIterReturn, PyMappingMethods, PyNumberMethods, PySequence,\n            PySequenceMethods,\n        },\n        sliceable::{SaturatedSliceIter, SliceableSequenceOp},\n        types::{\n            AsMapping, AsNumber, AsSequence, Callable, Comparable, Constructor, Hashable,\n            Initializer, IterNext, Iterable, PyComparisonOp, SelfIter, Unconstructible,\n        },\n        utils::ToCString,\n    };\n    use std::{\n        ffi::{CStr, c_int, c_longlong, c_uint, c_void},\n        fmt::Debug,\n        ops::Deref,\n        ptr::{NonNull, null, null_mut},\n        thread::ThreadId,\n    };\n\n    macro_rules! exceptions {\n        ($(($x:ident, $base:expr)),*) => {\n            paste::paste! {\n                static_cell! {\n                    $(\n                        static [<$x:snake:upper>]: PyTypeRef;\n                    )*\n                }\n                $(\n                    #[allow(dead_code)]\n                    fn [<new_ $x:snake>](vm: &VirtualMachine, msg: String) -> PyBaseExceptionRef {\n                        vm.new_exception_msg([<$x:snake _type>]().to_owned(), msg)\n                    }\n                    fn [<$x:snake _type>]() -> &'static Py<PyType> {\n                        [<$x:snake:upper>].get().expect(\"exception type not initialize\")\n                    }\n                )*\n                fn setup_module_exceptions(module: &PyObject, vm: &VirtualMachine) {\n                    $(\n                        #[allow(clippy::redundant_closure_call)]\n                        let exception = [<$x:snake:upper>].get_or_init(|| {\n                            let base = $base(vm);\n                            vm.ctx.new_exception_type(\"_sqlite3\", stringify!($x), Some(vec![base.to_owned()]))\n                        });\n                        module.set_attr(stringify!($x), exception.clone().into_object(), vm).unwrap();\n                    )*\n                }\n            }\n        };\n    }\n\n    exceptions!(\n        (Warning, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (Error, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (InterfaceError, |_| error_type()),\n        (DatabaseError, |_| error_type()),\n        (DataError, |_| database_error_type()),\n        (OperationalError, |_| database_error_type()),\n        (IntegrityError, |_| database_error_type()),\n        (InternalError, |_| database_error_type()),\n        (ProgrammingError, |_| database_error_type()),\n        (NotSupportedError, |_| database_error_type())\n    );\n\n    #[pyattr]\n    fn sqlite_version(vm: &VirtualMachine) -> String {\n        let s = unsafe { sqlite3_libversion() };\n        ptr_to_str(s, vm).unwrap().to_owned()\n    }\n\n    #[pyattr]\n    fn threadsafety(_: &VirtualMachine) -> c_int {\n        let mode = unsafe { sqlite3_threadsafe() };\n        match mode {\n            0 => 0,\n            1 => 3,\n            2 => 1,\n            _ => panic!(\"Unable to interpret SQLite threadsafety mode\"),\n        }\n    }\n\n    #[pyattr(name = \"_deprecated_version\")]\n    const PYSQLITE_VERSION: &str = \"2.6.0\";\n\n    #[pyattr]\n    const PARSE_DECLTYPES: c_int = 1;\n    #[pyattr]\n    const PARSE_COLNAMES: c_int = 2;\n\n    #[pyattr]\n    use libsqlite3_sys::{\n        SQLITE_ALTER_TABLE, SQLITE_ANALYZE, SQLITE_ATTACH, SQLITE_CREATE_INDEX,\n        SQLITE_CREATE_TABLE, SQLITE_CREATE_TEMP_INDEX, SQLITE_CREATE_TEMP_TABLE,\n        SQLITE_CREATE_TEMP_TRIGGER, SQLITE_CREATE_TEMP_VIEW, SQLITE_CREATE_TRIGGER,\n        SQLITE_CREATE_VIEW, SQLITE_CREATE_VTABLE, SQLITE_DELETE, SQLITE_DENY, SQLITE_DETACH,\n        SQLITE_DROP_INDEX, SQLITE_DROP_TABLE, SQLITE_DROP_TEMP_INDEX, SQLITE_DROP_TEMP_TABLE,\n        SQLITE_DROP_TEMP_TRIGGER, SQLITE_DROP_TEMP_VIEW, SQLITE_DROP_TRIGGER, SQLITE_DROP_VIEW,\n        SQLITE_DROP_VTABLE, SQLITE_FUNCTION, SQLITE_IGNORE, SQLITE_INSERT, SQLITE_LIMIT_ATTACHED,\n        SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH,\n        SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH,\n        SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER,\n        SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_PRAGMA, SQLITE_READ,\n        SQLITE_RECURSIVE, SQLITE_REINDEX, SQLITE_SAVEPOINT, SQLITE_SELECT, SQLITE_TRANSACTION,\n        SQLITE_UPDATE,\n    };\n\n    macro_rules! error_codes {\n        ($($x:ident),*) => {\n            $(\n                #[allow(unused_imports)]\n                use libsqlite3_sys::$x;\n            )*\n            static ERROR_CODES: &[(&str, c_int)] = &[\n            $(\n                (stringify!($x), libsqlite3_sys::$x),\n            )*\n            ];\n        };\n    }\n\n    error_codes!(\n        SQLITE_ABORT,\n        SQLITE_AUTH,\n        SQLITE_BUSY,\n        SQLITE_CANTOPEN,\n        SQLITE_CONSTRAINT,\n        SQLITE_CORRUPT,\n        SQLITE_DONE,\n        SQLITE_EMPTY,\n        SQLITE_ERROR,\n        SQLITE_FORMAT,\n        SQLITE_FULL,\n        SQLITE_INTERNAL,\n        SQLITE_INTERRUPT,\n        SQLITE_IOERR,\n        SQLITE_LOCKED,\n        SQLITE_MISMATCH,\n        SQLITE_MISUSE,\n        SQLITE_NOLFS,\n        SQLITE_NOMEM,\n        SQLITE_NOTADB,\n        SQLITE_NOTFOUND,\n        SQLITE_OK,\n        SQLITE_PERM,\n        SQLITE_PROTOCOL,\n        SQLITE_RANGE,\n        SQLITE_READONLY,\n        SQLITE_ROW,\n        SQLITE_SCHEMA,\n        SQLITE_TOOBIG,\n        SQLITE_NOTICE,\n        SQLITE_WARNING,\n        SQLITE_ABORT_ROLLBACK,\n        SQLITE_BUSY_RECOVERY,\n        SQLITE_CANTOPEN_FULLPATH,\n        SQLITE_CANTOPEN_ISDIR,\n        SQLITE_CANTOPEN_NOTEMPDIR,\n        SQLITE_CORRUPT_VTAB,\n        SQLITE_IOERR_ACCESS,\n        SQLITE_IOERR_BLOCKED,\n        SQLITE_IOERR_CHECKRESERVEDLOCK,\n        SQLITE_IOERR_CLOSE,\n        SQLITE_IOERR_DELETE,\n        SQLITE_IOERR_DELETE_NOENT,\n        SQLITE_IOERR_DIR_CLOSE,\n        SQLITE_IOERR_DIR_FSYNC,\n        SQLITE_IOERR_FSTAT,\n        SQLITE_IOERR_FSYNC,\n        SQLITE_IOERR_LOCK,\n        SQLITE_IOERR_NOMEM,\n        SQLITE_IOERR_RDLOCK,\n        SQLITE_IOERR_READ,\n        SQLITE_IOERR_SEEK,\n        SQLITE_IOERR_SHMLOCK,\n        SQLITE_IOERR_SHMMAP,\n        SQLITE_IOERR_SHMOPEN,\n        SQLITE_IOERR_SHMSIZE,\n        SQLITE_IOERR_SHORT_READ,\n        SQLITE_IOERR_TRUNCATE,\n        SQLITE_IOERR_UNLOCK,\n        SQLITE_IOERR_WRITE,\n        SQLITE_LOCKED_SHAREDCACHE,\n        SQLITE_READONLY_CANTLOCK,\n        SQLITE_READONLY_RECOVERY,\n        SQLITE_CONSTRAINT_CHECK,\n        SQLITE_CONSTRAINT_COMMITHOOK,\n        SQLITE_CONSTRAINT_FOREIGNKEY,\n        SQLITE_CONSTRAINT_FUNCTION,\n        SQLITE_CONSTRAINT_NOTNULL,\n        SQLITE_CONSTRAINT_PRIMARYKEY,\n        SQLITE_CONSTRAINT_TRIGGER,\n        SQLITE_CONSTRAINT_UNIQUE,\n        SQLITE_CONSTRAINT_VTAB,\n        SQLITE_READONLY_ROLLBACK,\n        SQLITE_IOERR_MMAP,\n        SQLITE_NOTICE_RECOVER_ROLLBACK,\n        SQLITE_NOTICE_RECOVER_WAL,\n        SQLITE_BUSY_SNAPSHOT,\n        SQLITE_IOERR_GETTEMPPATH,\n        SQLITE_WARNING_AUTOINDEX,\n        SQLITE_CANTOPEN_CONVPATH,\n        SQLITE_IOERR_CONVPATH,\n        SQLITE_CONSTRAINT_ROWID,\n        SQLITE_READONLY_DBMOVED,\n        SQLITE_AUTH_USER,\n        SQLITE_OK_LOAD_PERMANENTLY,\n        SQLITE_IOERR_VNODE,\n        SQLITE_IOERR_AUTH,\n        SQLITE_IOERR_BEGIN_ATOMIC,\n        SQLITE_IOERR_COMMIT_ATOMIC,\n        SQLITE_IOERR_ROLLBACK_ATOMIC,\n        SQLITE_ERROR_MISSING_COLLSEQ,\n        SQLITE_ERROR_RETRY,\n        SQLITE_READONLY_CANTINIT,\n        SQLITE_READONLY_DIRECTORY,\n        SQLITE_CORRUPT_SEQUENCE,\n        SQLITE_LOCKED_VTAB,\n        SQLITE_CANTOPEN_DIRTYWAL,\n        SQLITE_ERROR_SNAPSHOT,\n        SQLITE_CANTOPEN_SYMLINK,\n        SQLITE_CONSTRAINT_PINNED,\n        SQLITE_OK_SYMLINK,\n        SQLITE_BUSY_TIMEOUT,\n        SQLITE_CORRUPT_INDEX,\n        SQLITE_IOERR_DATA,\n        SQLITE_IOERR_CORRUPTFS\n    );\n\n    #[derive(FromArgs)]\n    struct ConnectArgs {\n        #[pyarg(any)]\n        database: FsPath,\n        #[pyarg(any, default = 5.0)]\n        timeout: f64,\n        #[pyarg(any, default = 0)]\n        detect_types: c_int,\n        #[pyarg(any, default = Some(vm.ctx.empty_str.to_owned()))]\n        isolation_level: Option<PyStrRef>,\n        #[pyarg(any, default = true)]\n        check_same_thread: bool,\n        #[pyarg(any, default = Connection::class(&vm.ctx).to_owned())]\n        factory: PyTypeRef,\n        // TODO: cache statements\n        #[allow(dead_code)]\n        #[pyarg(any, default = 0)]\n        cached_statements: c_int,\n        #[pyarg(any, default = false)]\n        uri: bool,\n    }\n\n    unsafe impl Traverse for ConnectArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.isolation_level.traverse(tracer_fn);\n            self.factory.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct BackupArgs {\n        #[pyarg(any)]\n        target: PyRef<Connection>,\n        #[pyarg(named, default = -1)]\n        pages: c_int,\n        #[pyarg(named, optional)]\n        progress: Option<ArgCallable>,\n        #[pyarg(named, optional)]\n        name: Option<PyStrRef>,\n        #[pyarg(named, default = 0.250)]\n        sleep: f64,\n    }\n\n    unsafe impl Traverse for BackupArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.progress.traverse(tracer_fn);\n            self.name.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct CreateFunctionArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(any)]\n        narg: c_int,\n        #[pyarg(any)]\n        func: PyObjectRef,\n        #[pyarg(named, default)]\n        deterministic: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct CreateAggregateArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(positional)]\n        narg: c_int,\n        #[pyarg(positional)]\n        aggregate_class: PyObjectRef,\n    }\n\n    #[derive(FromArgs)]\n    struct BlobOpenArgs {\n        #[pyarg(positional)]\n        table: PyStrRef,\n        #[pyarg(positional)]\n        column: PyStrRef,\n        #[pyarg(positional)]\n        row: i64,\n        #[pyarg(named, default)]\n        readonly: bool,\n        #[pyarg(named, default = vm.ctx.new_str(\"main\"))]\n        name: PyStrRef,\n    }\n\n    struct CallbackData {\n        obj: NonNull<PyObject>,\n        vm: *const VirtualMachine,\n    }\n\n    impl CallbackData {\n        fn new(obj: PyObjectRef, vm: &VirtualMachine) -> Option<Self> {\n            (!vm.is_none(&obj)).then_some(Self {\n                obj: obj.into_raw(),\n                vm,\n            })\n        }\n\n        fn retrieve(&self) -> (&PyObject, &VirtualMachine) {\n            unsafe { (self.obj.as_ref(), &*self.vm) }\n        }\n\n        unsafe extern \"C\" fn destructor(data: *mut c_void) {\n            drop(unsafe { Box::from_raw(data.cast::<Self>()) });\n        }\n\n        unsafe extern \"C\" fn func_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (func, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n\n                let val = func.call(args, vm)?;\n\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                context.result_exception(vm, exc, \"user-defined function raised exception\\0\")\n            }\n        }\n\n        unsafe extern \"C\" fn step_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (cls, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            if unsafe { (*instance).is_null() } {\n                match cls.call((), vm) {\n                    Ok(obj) => unsafe { *instance = obj.into_raw().as_ptr() },\n                    Err(exc) => {\n                        return context.result_exception(\n                            vm,\n                            exc,\n                            \"user-defined aggregate's '__init__' method raised error\\0\",\n                        );\n                    }\n                }\n            }\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"step\", args, vm);\n        }\n\n        unsafe extern \"C\" fn finalize_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let Some(instance) = (unsafe { (*instance).as_ref() }) else {\n                return;\n            };\n\n            Self::callback_result_from_method(context, instance, \"finalize\", vm);\n        }\n\n        unsafe extern \"C\" fn collation_callback(\n            data: *mut c_void,\n            a_len: c_int,\n            a_ptr: *const c_void,\n            b_len: c_int,\n            b_ptr: *const c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n\n            let f = || -> PyResult<c_int> {\n                let text1 = ptr_to_string(a_ptr.cast(), a_len, null_mut(), vm)?;\n                let text1 = vm.ctx.new_str(text1);\n                let text2 = ptr_to_string(b_ptr.cast(), b_len, null_mut(), vm)?;\n                let text2 = vm.ctx.new_str(text2);\n\n                let val = callable.call((text1, text2), vm)?;\n                let Some(val) = val.to_number().index(vm) else {\n                    return Ok(0);\n                };\n\n                let val = match val?.as_bigint().sign() {\n                    Sign::Plus => 1,\n                    Sign::Minus => -1,\n                    Sign::NoSign => 0,\n                };\n\n                Ok(val)\n            };\n\n            f().unwrap_or(0)\n        }\n\n        unsafe extern \"C\" fn value_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::callback_result_from_method(context, instance, \"value\", vm);\n        }\n\n        unsafe extern \"C\" fn inverse_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"inverse\", args, vm);\n        }\n\n        unsafe extern \"C\" fn authorizer_callback(\n            data: *mut c_void,\n            action: c_int,\n            arg1: *const libc::c_char,\n            arg2: *const libc::c_char,\n            db_name: *const libc::c_char,\n            access: *const libc::c_char,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let f = || -> PyResult<c_int> {\n                let arg1 = ptr_to_str(arg1, vm)?;\n                let arg2 = ptr_to_str(arg2, vm)?;\n                let db_name = ptr_to_str(db_name, vm)?;\n                let access = ptr_to_str(access, vm)?;\n\n                let val = callable.call((action, arg1, arg2, db_name, access), vm)?;\n                let Some(val) = val.downcast_ref::<PyInt>() else {\n                    return Ok(SQLITE_DENY);\n                };\n                val.try_to_primitive::<c_int>(vm)\n            };\n\n            f().unwrap_or(SQLITE_DENY)\n        }\n\n        unsafe extern \"C\" fn trace_callback(\n            _typ: c_uint,\n            data: *mut c_void,\n            stmt: *mut c_void,\n            sql: *mut c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let expanded = unsafe { sqlite3_expanded_sql(stmt.cast()) };\n            let f = || -> PyResult<()> {\n                let stmt = ptr_to_str(expanded, vm).or_else(|_| ptr_to_str(sql.cast(), vm))?;\n                callable.call((stmt,), vm)?;\n                Ok(())\n            };\n            let _ = f();\n            0\n        }\n\n        unsafe extern \"C\" fn progress_callback(data: *mut c_void) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            if let Ok(val) = callable.call((), vm)\n                && let Ok(val) = val.is_true(vm)\n            {\n                return val as c_int;\n            }\n            -1\n        }\n\n        fn callback_result_from_method(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let val = vm.call_method(instance, name, ())?;\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n\n        fn call_method_with_args(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            args: &[*mut sqlite3_value],\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n                vm.call_method(instance, name, args).map(drop)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n    }\n\n    impl Drop for CallbackData {\n        fn drop(&mut self) {\n            unsafe { PyObjectRef::from_raw(self.obj) };\n        }\n    }\n\n    #[pyfunction]\n    fn connect(args: ConnectArgs, vm: &VirtualMachine) -> PyResult {\n        Connection::py_new(args.factory.clone(), args, vm)\n    }\n\n    #[pyfunction]\n    fn complete_statement(statement: PyStrRef, vm: &VirtualMachine) -> PyResult<bool> {\n        let s = statement.to_cstring(vm)?;\n        let ret = unsafe { sqlite3_complete(s.as_ptr()) };\n        Ok(ret == 1)\n    }\n\n    #[pyfunction]\n    fn enable_callback_tracebacks(flag: bool) {\n        enable_traceback().store(flag, Ordering::Relaxed);\n    }\n\n    #[pyfunction]\n    fn register_adapter(typ: PyTypeRef, adapter: ArgCallable, vm: &VirtualMachine) -> PyResult<()> {\n        if typ.is(PyInt::class(&vm.ctx))\n            || typ.is(PyFloat::class(&vm.ctx))\n            || typ.is(PyStr::class(&vm.ctx))\n            || typ.is(PyByteArray::class(&vm.ctx))\n        {\n            let _ = BASE_TYPE_ADAPTED.set(());\n        }\n        let protocol = PrepareProtocol::class(&vm.ctx).to_owned();\n        let key = vm.ctx.new_tuple(vec![typ.into(), protocol.into()]);\n        adapters().set_item(key.as_object(), adapter.into(), vm)\n    }\n\n    #[pyfunction]\n    fn register_converter(\n        typename: PyStrRef,\n        converter: ArgCallable,\n        vm: &VirtualMachine,\n    ) -> PyResult<()> {\n        let name = typename.as_str().to_uppercase();\n        converters().set_item(&name, converter.into(), vm)\n    }\n\n    fn _adapt<F>(obj: &PyObject, proto: PyTypeRef, alt: F, vm: &VirtualMachine) -> PyResult\n    where\n        F: FnOnce(&PyObject) -> PyResult,\n    {\n        let proto = proto.into_object();\n        let key = vm\n            .ctx\n            .new_tuple(vec![obj.class().to_owned().into(), proto.clone()]);\n\n        if let Some(adapter) = adapters().get_item_opt(key.as_object(), vm)? {\n            return adapter.call((obj,), vm);\n        }\n        if let Ok(adapter) = proto.get_attr(\"__adapt__\", vm) {\n            match adapter.call((obj,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n        if let Ok(adapter) = obj.get_attr(\"__conform__\", vm) {\n            match adapter.call((proto,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n\n        alt(obj)\n    }\n\n    #[pyfunction]\n    fn adapt(\n        obj: PyObjectRef,\n        proto: OptionalArg<Option<PyTypeRef>>,\n        alt: OptionalArg<PyObjectRef>,\n        vm: &VirtualMachine,\n    ) -> PyResult {\n        if matches!(proto, OptionalArg::Present(None)) {\n            return if let OptionalArg::Present(alt) = alt {\n                Ok(alt)\n            } else {\n                Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n            };\n        }\n\n        let proto = proto\n            .flatten()\n            .unwrap_or_else(|| PrepareProtocol::class(&vm.ctx).to_owned());\n\n        _adapt(\n            &obj,\n            proto,\n            |_| {\n                if let OptionalArg::Present(alt) = alt {\n                    Ok(alt)\n                } else {\n                    Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n                }\n            },\n            vm,\n        )\n    }\n\n    fn need_adapt(obj: &PyObject, vm: &VirtualMachine) -> bool {\n        if BASE_TYPE_ADAPTED.get().is_some() {\n            true\n        } else {\n            let cls = obj.class();\n            !(cls.is(vm.ctx.types.int_type)\n                || cls.is(vm.ctx.types.float_type)\n                || cls.is(vm.ctx.types.str_type)\n                || cls.is(vm.ctx.types.bytearray_type))\n        }\n    }\n\n    static_cell! {\n        static CONVERTERS: PyDictRef;\n        static ADAPTERS: PyDictRef;\n        static BASE_TYPE_ADAPTED: ();\n        static USER_FUNCTION_EXCEPTION: PyAtomicRef<Option<PyBaseException>>;\n        static ENABLE_TRACEBACK: PyAtomic<bool>;\n    }\n\n    fn converters() -> &'static Py<PyDict> {\n        CONVERTERS.get().expect(\"converters not initialize\")\n    }\n\n    fn adapters() -> &'static Py<PyDict> {\n        ADAPTERS.get().expect(\"adapters not initialize\")\n    }\n\n    fn user_function_exception() -> &'static PyAtomicRef<Option<PyBaseException>> {\n        USER_FUNCTION_EXCEPTION\n            .get()\n            .expect(\"user function exception not initialize\")\n    }\n\n    fn enable_traceback() -> &'static PyAtomic<bool> {\n        ENABLE_TRACEBACK\n            .get()\n            .expect(\"enable traceback not initialize\")\n    }\n\n    pub(super) fn setup_module(module: &PyObject, vm: &VirtualMachine) {\n        for (name, code) in ERROR_CODES {\n            let name = vm.ctx.intern_str(*name);\n            let code = vm.new_pyobj(*code);\n            module.set_attr(name, code, vm).unwrap();\n        }\n\n        setup_module_exceptions(module, vm);\n\n        let _ = CONVERTERS.set(vm.ctx.new_dict());\n        let _ = ADAPTERS.set(vm.ctx.new_dict());\n        let _ = USER_FUNCTION_EXCEPTION.set(PyAtomicRef::from(None));\n        let _ = ENABLE_TRACEBACK.set(Radium::new(false));\n\n        module\n            .set_attr(\"converters\", converters().to_owned(), vm)\n            .unwrap();\n        module\n            .set_attr(\"adapters\", adapters().to_owned(), vm)\n            .unwrap();\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(PyPayload)]\n    struct Connection {\n        db: PyMutex<Option<Sqlite>>,\n        detect_types: PyAtomic<c_int>,\n        isolation_level: PyAtomicRef<Option<PyStr>>,\n        check_same_thread: PyAtomic<bool>,\n        thread_ident: PyMutex<ThreadId>,\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        text_factory: PyAtomicRef<PyObject>,\n    }\n\n    impl Debug for Connection {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"Sqlite3 Connection\")\n        }\n    }\n\n    impl Constructor for Connection {\n        type Args = ConnectArgs;\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n\n            // For non-subclassed Connection, initialize in __new__\n            // For subclassed Connection, leave db as None and require __init__ to be called\n            let is_base_class = cls.is(Connection::class(&vm.ctx).as_object());\n\n            let db = if is_base_class {\n                // Initialize immediately for base class\n                Some(Connection::initialize_db(&args, vm)?)\n            } else {\n                // For subclasses, require __init__ to be called\n                None\n            };\n\n            let conn = Self {\n                db: PyMutex::new(db),\n                detect_types: Radium::new(args.detect_types),\n                isolation_level: PyAtomicRef::from(args.isolation_level),\n                check_same_thread: Radium::new(args.check_same_thread),\n                thread_ident: PyMutex::new(std::thread::current().id()),\n                row_factory: PyAtomicRef::from(None),\n                text_factory: PyAtomicRef::from(text_factory),\n            };\n\n            Ok(conn.into_ref_with_type(vm, cls)?.into())\n        }\n    }\n\n    impl Callable for Connection {\n        type Args = FuncArgs;\n\n        fn call(zelf: &Py<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let _ = zelf.db_lock(vm)?;\n\n            let (sql,): (PyUtf8StrRef,) = args.bind(vm)?;\n\n            if let Some(stmt) = Statement::new(zelf, sql, vm)? {\n                Ok(stmt.into_ref(&vm.ctx).into())\n            } else {\n                Ok(vm.ctx.none())\n            }\n        }\n    }\n\n    impl Initializer for Connection {\n        type Args = ConnectArgs;\n\n        fn init(zelf: PyRef<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult<()> {\n            {\n                // Always drop the current database handle so __init__ can fully reconfigure it.\n                let mut guard = zelf.db.lock();\n                guard.take();\n            }\n\n            // Reset factories to their defaults, matching CPython's behavior.\n            let default_text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n            let _ = unsafe { zelf.row_factory.swap(None) };\n            let _ = unsafe { zelf.text_factory.swap(default_text_factory) };\n\n            // Attempt to open the new database before mutating other state so failures leave\n            // the connection uninitialized (and subsequent operations raise ProgrammingError).\n            let db = Self::initialize_db(&args, vm)?;\n\n            let ConnectArgs {\n                detect_types,\n                isolation_level,\n                check_same_thread,\n                ..\n            } = args;\n\n            zelf.detect_types.store(detect_types, Ordering::Relaxed);\n            zelf\n                .check_same_thread\n                .store(check_same_thread, Ordering::Relaxed);\n            *zelf.thread_ident.lock() = std::thread::current().id();\n            let _ = unsafe { zelf.isolation_level.swap(isolation_level) };\n\n            let mut guard = zelf.db.lock();\n            *guard = Some(db);\n            Ok(())\n        }\n    }\n\n    #[pyclass(with(Constructor, Callable, Initializer), flags(BASETYPE))]\n    impl Connection {\n        fn initialize_db(args: &ConnectArgs, vm: &VirtualMachine) -> PyResult<Sqlite> {\n            let path = args.database.to_cstring(vm)?;\n            let db = Sqlite::from(SqliteRaw::open(path.as_ptr(), args.uri, vm)?);\n            let timeout = (args.timeout * 1000.0) as c_int;\n            db.busy_timeout(timeout);\n            if let Some(isolation_level) = &args.isolation_level {\n                begin_statement_ptr_from_isolation_level(isolation_level, vm)?;\n            }\n            Ok(db)\n        }\n\n        fn db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            self.check_thread(vm)?;\n            self._db_lock(vm)\n        }\n\n        fn _db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            let guard = self.db.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Connection.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn cursor(\n            zelf: PyRef<Self>,\n            factory: OptionalArg<ArgCallable>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            zelf.db_lock(vm).map(drop)?;\n\n            let cursor = if let OptionalArg::Present(factory) = factory {\n                let cursor = factory.invoke((zelf.clone(),), vm)?;\n                let cursor = cursor.downcast::<Cursor>().map_err(|x| {\n                    vm.new_type_error(format!(\"factory must return a cursor, not {}\", x.class()))\n                })?;\n                let _ = unsafe { cursor.row_factory.swap(zelf.row_factory.to_owned()) };\n                cursor\n            } else {\n                let row_factory = zelf.row_factory.to_owned();\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx)\n            };\n            Ok(cursor)\n        }\n\n        #[pymethod]\n        fn blobopen(\n            zelf: PyRef<Self>,\n            args: BlobOpenArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Blob>> {\n            let table = args.table.to_cstring(vm)?;\n            let column = args.column.to_cstring(vm)?;\n            let name = args.name.to_cstring(vm)?;\n\n            let db = zelf.db_lock(vm)?;\n\n            let mut blob = null_mut();\n            let ret = unsafe {\n                sqlite3_blob_open(\n                    db.db,\n                    name.as_ptr(),\n                    table.as_ptr(),\n                    column.as_ptr(),\n                    args.row,\n                    (!args.readonly) as c_int,\n                    &mut blob,\n                )\n            };\n            db.check(ret, vm)?;\n            drop(db);\n\n            let blob = SqliteBlob { blob };\n            let blob = Blob {\n                connection: zelf,\n                inner: PyMutex::new(Some(BlobInner { blob, offset: 0 })),\n            };\n            Ok(blob.into_ref(&vm.ctx))\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.check_thread(vm)?;\n            self.db.lock().take();\n            Ok(())\n        }\n\n        #[pymethod]\n        fn commit(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.db_lock(vm)?.implicit_commit(vm)\n        }\n\n        #[pymethod]\n        fn rollback(&self, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            if !db.is_autocommit() {\n                db._exec(b\"ROLLBACK\\0\", vm)\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::execute(cursor, sql, parameters, vm)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::executemany(cursor, sql, seq_of_params, vm)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            Cursor::executescript(\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx),\n                script,\n                vm,\n            )\n        }\n\n        // TODO: Make it build without clippy::manual_c_str_literals\n        #[pymethod]\n        #[allow(clippy::manual_c_str_literals)]\n        fn backup(zelf: &Py<Self>, args: BackupArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let BackupArgs {\n                target,\n                pages,\n                progress,\n                name,\n                sleep,\n            } = args;\n            if zelf.is(&target) {\n                return Err(vm.new_value_error(\"target cannot be the same connection instance\"));\n            }\n\n            let pages = if pages == 0 { -1 } else { pages };\n\n            let name_cstring;\n            let name_ptr = if let Some(name) = &name {\n                name_cstring = name.to_cstring(vm)?;\n                name_cstring.as_ptr()\n            } else {\n                b\"main\\0\".as_ptr().cast()\n            };\n\n            let sleep_ms = (sleep * 1000.0) as c_int;\n\n            let db = zelf.db_lock(vm)?;\n            let target_db = target.db_lock(vm)?;\n\n            let handle = unsafe {\n                sqlite3_backup_init(target_db.db, b\"main\\0\".as_ptr().cast(), db.db, name_ptr)\n            };\n\n            if handle.is_null() {\n                return Err(target_db.error_extended(vm));\n            }\n\n            drop(db);\n            drop(target_db);\n\n            loop {\n                let ret = unsafe { sqlite3_backup_step(handle, pages) };\n\n                if let Some(progress) = &progress {\n                    let remaining = unsafe { sqlite3_backup_remaining(handle) };\n                    let pagecount = unsafe { sqlite3_backup_pagecount(handle) };\n                    if let Err(err) = progress.invoke((ret, remaining, pagecount), vm) {\n                        unsafe { sqlite3_backup_finish(handle) };\n                        return Err(err);\n                    }\n                }\n\n                if ret == SQLITE_BUSY || ret == SQLITE_LOCKED {\n                    unsafe { sqlite3_sleep(sleep_ms) };\n                } else if ret != SQLITE_OK {\n                    break;\n                }\n            }\n\n            let ret = unsafe { sqlite3_backup_finish(handle) };\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(target.db_lock(vm)?.error_extended(vm))\n            }\n        }\n\n        #[pymethod]\n        fn create_function(&self, args: CreateFunctionArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let flags = if args.deterministic {\n                SQLITE_UTF8 | SQLITE_DETERMINISTIC\n            } else {\n                SQLITE_UTF8\n            };\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.func, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    flags,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                flags,\n                Box::into_raw(Box::new(data)).cast(),\n                Some(CallbackData::func_callback),\n                None,\n                None,\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_aggregate(&self, args: CreateAggregateArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.aggregate_class, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    SQLITE_UTF8,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                SQLITE_UTF8,\n                Box::into_raw(Box::new(data)).cast(),\n                None,\n                Some(CallbackData::step_callback),\n                Some(CallbackData::finalize_callback),\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_collation(\n            &self,\n            name: PyUtf8StrRef,\n            callable: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable.clone(), vm) else {\n                unsafe {\n                    sqlite3_create_collation_v2(\n                        db.db,\n                        name.as_ptr(),\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                    );\n                }\n                return Ok(());\n            };\n            let data = Box::into_raw(Box::new(data));\n\n            if !callable.is_callable() {\n                return Err(vm.new_type_error(\"parameter must be callable\"));\n            }\n\n            let ret = unsafe {\n                sqlite3_create_collation_v2(\n                    db.db,\n                    name.as_ptr(),\n                    SQLITE_UTF8,\n                    data.cast(),\n                    Some(CallbackData::collation_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n\n            db.check(ret, vm).inspect_err(|_| {\n                // create_collation do not call destructor if error occur\n                let _ = unsafe { Box::from_raw(data) };\n            })\n        }\n\n        #[pymethod]\n        fn create_window_function(\n            &self,\n            name: PyStrRef,\n            narg: c_int,\n            aggregate_class: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(aggregate_class, vm) else {\n                unsafe {\n                    sqlite3_create_window_function(\n                        db.db,\n                        name.as_ptr(),\n                        narg,\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                        None,\n                        None,\n                        None,\n                    )\n                };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_create_window_function(\n                    db.db,\n                    name.as_ptr(),\n                    narg,\n                    SQLITE_UTF8,\n                    Box::into_raw(Box::new(data)).cast(),\n                    Some(CallbackData::step_callback),\n                    Some(CallbackData::finalize_callback),\n                    Some(CallbackData::value_callback),\n                    Some(CallbackData::inverse_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n            db.check(ret, vm)\n                .map_err(|_| new_programming_error(vm, \"Error creating window function\".to_owned()))\n        }\n\n        #[pymethod]\n        fn set_authorizer(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_set_authorizer(db.db, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_set_authorizer(\n                    db.db,\n                    Some(CallbackData::authorizer_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n            db.check(ret, vm).map_err(|_| {\n                new_operational_error(vm, \"Error setting authorizer callback\".to_owned())\n            })\n        }\n\n        #[pymethod]\n        fn set_trace_callback(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_trace_v2(db.db, SQLITE_TRACE_STMT as u32, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_trace_v2(\n                    db.db,\n                    SQLITE_TRACE_STMT as u32,\n                    Some(CallbackData::trace_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            db.check(ret, vm)\n        }\n\n        #[pymethod]\n        fn set_progress_handler(\n            &self,\n            callable: PyObjectRef,\n            n: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_progress_handler(db.db, n, None, null_mut()) };\n                return Ok(());\n            };\n\n            unsafe {\n                sqlite3_progress_handler(\n                    db.db,\n                    n,\n                    Some(CallbackData::progress_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            Ok(())\n        }\n\n        #[pymethod]\n        fn iterdump(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            let module = vm.import(\"sqlite3.dump\", 0)?;\n            let func = module.get_attr(\"_iterdump\", vm)?;\n            func.call((zelf,), vm)\n        }\n\n        #[pymethod]\n        fn interrupt(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // DO NOT check thread safety\n            self._db_lock(vm).map(|x| x.interrupt())\n        }\n\n        #[pymethod]\n        fn getlimit(&self, category: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, -1, vm)\n        }\n\n        #[pymethod]\n        fn setlimit(&self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, limit, vm)\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>) -> PyRef<Self> {\n            zelf\n        }\n\n        #[pymethod]\n        fn __exit__(\n            &self,\n            cls: PyObjectRef,\n            exc: PyObjectRef,\n            tb: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            if vm.is_none(&cls) && vm.is_none(&exc) && vm.is_none(&tb) {\n                self.commit(vm)\n            } else {\n                self.rollback(vm)\n            }\n        }\n\n        #[pygetset]\n        fn isolation_level(&self) -> Option<PyStrRef> {\n            self.isolation_level.deref().map(|x| x.to_owned())\n        }\n        #[pygetset(setter)]\n        fn set_isolation_level(\n            &self,\n            value: PySetterValue<Option<PyStrRef>>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            match value {\n                PySetterValue::Assign(value) => {\n                    if let Some(val_str) = &value {\n                        begin_statement_ptr_from_isolation_level(val_str, vm)?;\n                    }\n\n                    // If setting isolation_level to None (auto-commit mode), commit any pending transaction\n                    if value.is_none() {\n                        let db = self.db_lock(vm)?;\n                        if !db.is_autocommit() {\n                            // Keep the lock and call implicit_commit directly to avoid race conditions\n                            db.implicit_commit(vm)?;\n                        }\n                    }\n                    let _ = unsafe { self.isolation_level.swap(value) };\n                    Ok(())\n                }\n                PySetterValue::Delete => Err(vm.new_attribute_error(\n                    \"'isolation_level' attribute cannot be deleted\".to_owned(),\n                )),\n            }\n        }\n\n        #[pygetset]\n        fn text_factory(&self) -> PyObjectRef {\n            self.text_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_text_factory(&self, val: PyObjectRef) {\n            let _ = unsafe { self.text_factory.swap(val) };\n        }\n\n        #[pygetset]\n        fn row_factory(&self) -> Option<PyObjectRef> {\n            self.row_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_row_factory(&self, val: Option<PyObjectRef>) {\n            let _ = unsafe { self.row_factory.swap(val) };\n        }\n\n        fn check_thread(&self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.check_same_thread.load(Ordering::Relaxed) {\n                let creator_id = *self.thread_ident.lock();\n                if std::thread::current().id() != creator_id {\n                    return Err(new_programming_error(\n                        vm,\n                        \"SQLite objects created in a thread can only be used in that same thread.\"\n                            .to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n\n        #[pygetset]\n        fn in_transaction(&self, vm: &VirtualMachine) -> PyResult<bool> {\n            self._db_lock(vm).map(|x| !x.is_autocommit())\n        }\n\n        #[pygetset]\n        fn total_changes(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self._db_lock(vm).map(|x| x.total_changes())\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Cursor {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        arraysize: PyAtomic<c_int>,\n        #[pytraverse(skip)]\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        inner: PyMutex<Option<CursorInner>>,\n    }\n\n    #[derive(Debug, Traverse)]\n    struct CursorInner {\n        description: Option<PyTupleRef>,\n        row_cast_map: Vec<Option<PyObjectRef>>,\n        #[pytraverse(skip)]\n        lastrowid: i64,\n        #[pytraverse(skip)]\n        rowcount: i64,\n        statement: Option<PyRef<Statement>>,\n        #[pytraverse(skip)]\n        closed: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct FetchManyArgs {\n        #[pyarg(any, name = \"size\", optional)]\n        size: Option<c_int>,\n    }\n\n    #[pyclass(with(Constructor, IterNext, Iterable), flags(BASETYPE))]\n    impl Cursor {\n        fn new(\n            connection: PyRef<Connection>,\n            row_factory: Option<PyObjectRef>,\n            _vm: &VirtualMachine,\n        ) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(row_factory),\n                inner: PyMutex::from(Some(CursorInner {\n                    description: None,\n                    row_cast_map: vec![],\n                    lastrowid: -1,\n                    rowcount: -1,\n                    statement: None,\n                    closed: false,\n                })),\n            }\n        }\n\n        fn new_uninitialized(connection: PyRef<Connection>, _vm: &VirtualMachine) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(None),\n                inner: PyMutex::from(None),\n            }\n        }\n\n        #[pymethod]\n        fn __init__(&self, _connection: PyRef<Connection>, _vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = self.inner.lock();\n            if guard.is_some() {\n                // Already initialized (e.g., from a call to super().__init__)\n                return Ok(());\n            }\n            *guard = Some(CursorInner {\n                description: None,\n                row_cast_map: vec![],\n                lastrowid: -1,\n                rowcount: -1,\n                statement: None,\n                closed: false,\n            });\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, CursorInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                let inner_guard =\n                    PyMutexGuard::map(guard, |x| unsafe { x.as_mut().unwrap_unchecked() });\n                if inner_guard.closed {\n                    return Err(new_programming_error(\n                        vm,\n                        \"Cannot operate on a closed cursor.\".to_owned(),\n                    ));\n                }\n                Ok(inner_guard)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let st = stmt.lock();\n            let params_needed = st.bind_parameter_count();\n\n            if let OptionalArg::Present(parameters) = parameters {\n                st.bind_parameters(&parameters, vm)?;\n            } else if params_needed > 0 {\n                let msg = format!(\n                    \"Incorrect number of bindings supplied. The current statement uses {}, and 0 were supplied.\",\n                    params_needed\n                );\n                return Err(new_programming_error(vm, msg));\n            }\n\n            let ret = st.step();\n\n            if ret != SQLITE_DONE && ret != SQLITE_ROW {\n                if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                    return Err(exc);\n                }\n                return Err(db.error_extended(vm));\n            }\n\n            inner.row_cast_map = zelf.build_row_cast_map(&st, vm)?;\n\n            let detect_types = zelf.connection.detect_types.load(Ordering::Relaxed);\n            inner.description = st.columns_description(detect_types, vm)?;\n\n            if ret == SQLITE_ROW {\n                drop(st);\n                inner.statement = Some(stmt);\n            } else {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount += db.changes() as i64;\n                }\n            }\n\n            inner.lastrowid = db.lastrowid();\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            let st = stmt.lock();\n\n            if st.readonly() {\n                return Err(new_programming_error(\n                    vm,\n                    \"executemany() can only execute DML statements.\".to_owned(),\n                ));\n            }\n\n            let detect_types = zelf.connection.detect_types.load(Ordering::Relaxed);\n            inner.description = st.columns_description(detect_types, vm)?;\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let iter = seq_of_params.iter(vm)?;\n            for params in iter {\n                let params = params?;\n                st.bind_parameters(&params, vm)?;\n\n                if !st.step_row_else_done(vm)? {\n                    if stmt.is_dml {\n                        inner.rowcount += db.changes() as i64;\n                    }\n                    st.reset();\n                }\n\n                // if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                //     return Err(exc);\n                // }\n            }\n\n            if st.busy() {\n                drop(st);\n                inner.statement = Some(stmt);\n            }\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let db = zelf.connection.db_lock(vm)?;\n\n            db.sql_limit(script.byte_len(), vm)?;\n\n            db.implicit_commit(vm)?;\n\n            let script = script.to_cstring(vm)?;\n            let mut ptr = script.as_ptr();\n\n            while let Some(st) = db.prepare(ptr, &mut ptr, vm)? {\n                while st.step_row_else_done(vm)? {}\n            }\n\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn fetchone(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult {\n            Self::next(zelf, vm).map(|x| match x {\n                PyIterReturn::Return(row) => row,\n                PyIterReturn::StopIteration(_) => vm.ctx.none(),\n            })\n        }\n\n        #[pymethod]\n        fn fetchmany(\n            zelf: &Py<Self>,\n            args: FetchManyArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<PyObjectRef>> {\n            let max_rows = args\n                .size\n                .unwrap_or_else(|| zelf.arraysize.load(Ordering::Relaxed));\n\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Cursor::next(zelf, vm)? {\n                list.push(row);\n                if max_rows > 0 && list.len() as c_int >= max_rows {\n                    break;\n                }\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn fetchall(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Self::next(zelf, vm)? {\n                list.push(row);\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // Check if __init__ was called\n            let mut guard = self.inner.lock();\n            if guard.is_none() {\n                return Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ));\n            }\n\n            if let Some(inner) = guard.as_mut() {\n                if let Some(stmt) = &inner.statement {\n                    stmt.lock().reset();\n                }\n                inner.closed = true;\n            }\n            Ok(())\n        }\n\n        #[pymethod]\n        fn setinputsizes(&self, _sizes: PyObjectRef) {}\n        #[pymethod]\n        fn setoutputsize(&self, _size: PyObjectRef, _column: OptionalArg<PyObjectRef>) {}\n\n        #[pygetset]\n        fn connection(&self) -> PyRef<Connection> {\n            self.connection.clone()\n        }\n\n        #[pygetset]\n        fn lastrowid(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.lastrowid)\n        }\n\n        #[pygetset]\n        fn rowcount(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.rowcount)\n        }\n\n        #[pygetset]\n        fn description(&self, vm: &VirtualMachine) -> PyResult<Option<PyTupleRef>> {\n            self.inner(vm).map(|x| x.description.clone())\n        }\n\n        #[pygetset]\n        fn arraysize(&self) -> c_int {\n            self.arraysize.load(Ordering::Relaxed)\n        }\n        #[pygetset(setter)]\n        fn set_arraysize(&self, val: c_int) {\n            self.arraysize.store(val, Ordering::Relaxed);\n        }\n\n        fn build_row_cast_map(\n            &self,\n            st: &SqliteStatementRaw,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<Option<PyObjectRef>>> {\n            if self.connection.detect_types == 0 {\n                return Ok(vec![]);\n            }\n\n            let mut cast_map = vec![];\n            let num_cols = st.column_count();\n\n            for i in 0..num_cols {\n                if self.connection.detect_types & PARSE_COLNAMES != 0 {\n                    let col_name = st.column_name(i);\n                    let col_name = ptr_to_str(col_name, vm)?;\n                    let col_name = col_name\n                        .chars()\n                        .skip_while(|&x| x != '[')\n                        .skip(1)\n                        .take_while(|&x| x != ']')\n                        .flat_map(|x| x.to_uppercase())\n                        .collect::<String>();\n                    if let Some(converter) = converters().get_item_opt(&col_name, vm)? {\n                        cast_map.push(Some(converter.clone()));\n                        continue;\n                    }\n                }\n                if self.connection.detect_types & PARSE_DECLTYPES != 0 {\n                    let decltype = st.column_decltype(i);\n                    let decltype = ptr_to_str(decltype, vm)?;\n                    if let Some(decltype) = decltype.split_terminator(&[' ', '(']).next() {\n                        let decltype = decltype.to_uppercase();\n                        if let Some(converter) = converters().get_item_opt(&decltype, vm)? {\n                            cast_map.push(Some(converter.clone()));\n                            continue;\n                        }\n                    }\n                }\n                cast_map.push(None);\n            }\n\n            Ok(cast_map)\n        }\n    }\n\n    impl Constructor for Cursor {\n        type Args = (PyRef<Connection>,);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            Self::new_uninitialized(args.0, vm)\n                .into_ref_with_type(vm, cls)\n                .map(Into::into)\n        }\n    }\n\n    impl SelfIter for Cursor {}\n    impl IterNext for Cursor {\n        fn next(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyIterReturn> {\n            let mut inner = zelf.inner(vm)?;\n            let Some(stmt) = &inner.statement else {\n                return Ok(PyIterReturn::StopIteration(None));\n            };\n            let st = stmt.lock();\n            let db = zelf.connection.db_lock(vm)?;\n            // fetch_one_row\n\n            let num_cols = st.data_count();\n\n            let mut row = Vec::with_capacity(num_cols as usize);\n\n            for i in 0..num_cols {\n                let val = if let Some(converter) =\n                    inner.row_cast_map.get(i as usize).cloned().flatten()\n                {\n                    let blob = st.column_blob(i);\n                    if blob.is_null() {\n                        vm.ctx.none()\n                    } else {\n                        let nbytes = st.column_bytes(i);\n                        let blob = unsafe {\n                            std::slice::from_raw_parts(blob.cast::<u8>(), nbytes as usize)\n                        };\n                        let blob = vm.ctx.new_bytes(blob.to_vec());\n                        converter.call((blob,), vm)?\n                    }\n                } else {\n                    let col_type = st.column_type(i);\n                    match col_type {\n                        SQLITE_NULL => vm.ctx.none(),\n                        SQLITE_INTEGER => vm.ctx.new_int(st.column_int(i)).into(),\n                        SQLITE_FLOAT => vm.ctx.new_float(st.column_double(i)).into(),\n                        SQLITE_TEXT => {\n                            let text =\n                                ptr_to_vec(st.column_text(i), st.column_bytes(i), db.db, vm)?;\n\n                            let text_factory = zelf.connection.text_factory.to_owned();\n\n                            if text_factory.is(PyStr::class(&vm.ctx)) {\n                                let text = String::from_utf8(text).map_err(|err| {\n                                    let col_name = st.column_name(i);\n                                    let col_name_str = ptr_to_str(col_name, vm).unwrap_or(\"?\");\n                                    let valid_up_to = err.utf8_error().valid_up_to();\n                                    let text_prefix = String::from_utf8_lossy(&err.as_bytes()[..valid_up_to]);\n                                    let msg = format!(\n                                        \"Could not decode to UTF-8 column '{col_name_str}' with text '{text_prefix}'\"\n                                    );\n                                    new_operational_error(vm, msg)\n                                })?;\n                                vm.ctx.new_str(text).into()\n                            } else if text_factory.is(PyBytes::class(&vm.ctx)) {\n                                vm.ctx.new_bytes(text).into()\n                            } else if text_factory.is(PyByteArray::class(&vm.ctx)) {\n                                PyByteArray::from(text).into_ref(&vm.ctx).into()\n                            } else {\n                                let bytes = vm.ctx.new_bytes(text);\n                                text_factory.call((bytes,), vm)?\n                            }\n                        }\n                        SQLITE_BLOB => {\n                            let blob = ptr_to_vec(\n                                st.column_blob(i).cast(),\n                                st.column_bytes(i),\n                                db.db,\n                                vm,\n                            )?;\n\n                            vm.ctx.new_bytes(blob).into()\n                        }\n                        _ => {\n                            return Err(vm.new_not_implemented_error(format!(\n                                \"unknown column type: {col_type}\"\n                            )));\n                        }\n                    }\n                };\n\n                row.push(val);\n            }\n\n            if !st.step_row_else_done(vm)? {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount = db.changes() as i64;\n                }\n                inner.statement = None;\n            } else {\n                drop(st);\n            }\n\n            drop(db);\n            drop(inner);\n\n            let row = vm.ctx.new_tuple(row);\n\n            if let Some(row_factory) = zelf.row_factory.to_owned() {\n                row_factory\n                    .call((zelf.to_owned(), row), vm)\n                    .map(PyIterReturn::Return)\n            } else {\n                Ok(PyIterReturn::Return(row.into()))\n            }\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Row {\n        data: PyTupleRef,\n        description: PyTupleRef,\n    }\n\n    #[pyclass(\n        with(Constructor, Hashable, Comparable, Iterable, AsMapping, AsSequence),\n        flags(BASETYPE)\n    )]\n    impl Row {\n        #[pymethod]\n        fn keys(&self, _vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            Ok(self\n                .description\n                .iter()\n                .map(|x| x.downcast_ref::<PyTuple>().unwrap().as_slice()[0].clone())\n                .collect())\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            if let Some(i) = needle.downcast_ref::<PyInt>() {\n                let i = i.try_to_primitive::<isize>(vm)?;\n                self.data.getitem_by_index(vm, i)\n            } else if let Some(name) = needle.downcast_ref::<PyStr>() {\n                for (obj, i) in self.description.iter().zip(0..) {\n                    let obj = &obj.downcast_ref::<PyTuple>().unwrap().as_slice()[0];\n                    let Some(obj) = obj.downcast_ref::<PyStr>() else {\n                        break;\n                    };\n                    let a_iter = name.as_str().chars().flat_map(|x| x.to_uppercase());\n                    let b_iter = obj.as_str().chars().flat_map(|x| x.to_uppercase());\n\n                    if a_iter.eq(b_iter) {\n                        return self.data.getitem_by_index(vm, i);\n                    }\n                }\n                Err(vm.new_index_error(\"No item with that key\"))\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let list = self.data.getitem_by_slice(vm, slice.to_saturated(vm)?)?;\n                Ok(vm.ctx.new_tuple(list).into())\n            } else {\n                Err(vm.new_index_error(\"Index must be int or string\"))\n            }\n        }\n    }\n\n    impl Constructor for Row {\n        type Args = (PyRef<Cursor>, PyTupleRef);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let description = args\n                .0\n                .inner(vm)?\n                .description\n                .clone()\n                .ok_or_else(|| vm.new_value_error(\"no description in Cursor\"))?;\n\n            Self {\n                data: args.1,\n                description,\n            }\n            .into_ref_with_type(vm, cls)\n            .map(Into::into)\n        }\n    }\n\n    impl Hashable for Row {\n        fn hash(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyHash> {\n            Ok(zelf.description.as_object().hash(vm)? | zelf.data.as_object().hash(vm)?)\n        }\n    }\n\n    impl Comparable for Row {\n        fn cmp(\n            zelf: &Py<Self>,\n            other: &PyObject,\n            op: PyComparisonOp,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyComparisonValue> {\n            op.eq_only(|| {\n                if let Some(other) = other.downcast_ref::<Self>() {\n                    let eq = vm\n                        .bool_eq(zelf.description.as_object(), other.description.as_object())?\n                        && vm.bool_eq(zelf.data.as_object(), other.data.as_object())?;\n                    Ok(eq.into())\n                } else {\n                    Ok(PyComparisonValue::NotImplemented)\n                }\n            })\n        }\n    }\n\n    impl Iterable for Row {\n        fn iter(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            Iterable::iter(zelf.data.clone(), vm)\n        }\n    }\n\n    impl AsMapping for Row {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: std::sync::LazyLock<PyMappingMethods> =\n                std::sync::LazyLock::new(|| PyMappingMethods {\n                    length: atomic_func!(|mapping, _vm| Ok(Row::mapping_downcast(mapping)\n                        .data\n                        .len())),\n                    subscript: atomic_func!(|mapping, needle, vm| {\n                        Row::mapping_downcast(mapping).subscript(needle, vm)\n                    }),\n                    ..PyMappingMethods::NOT_IMPLEMENTED\n                });\n            &AS_MAPPING\n        }\n    }\n\n    impl AsSequence for Row {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: std::sync::LazyLock<PySequenceMethods> =\n                std::sync::LazyLock::new(|| PySequenceMethods {\n                    length: atomic_func!(|seq, _vm| Ok(Row::sequence_downcast(seq).data.len())),\n                    item: atomic_func!(|seq, i, vm| Row::sequence_downcast(seq)\n                        .data\n                        .getitem_by_index(vm, i)),\n                    ..PySequenceMethods::NOT_IMPLEMENTED\n                });\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Blob\", traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Blob {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        inner: PyMutex<Option<BlobInner>>,\n    }\n\n    impl Unconstructible for Blob {}\n\n    #[derive(Debug)]\n    struct BlobInner {\n        blob: SqliteBlob,\n        offset: c_int,\n    }\n\n    impl Drop for BlobInner {\n        fn drop(&mut self) {\n            unsafe { sqlite3_blob_close(self.blob.blob) };\n        }\n    }\n\n    #[pyclass(with(AsMapping, Unconstructible, AsNumber, AsSequence))]\n    impl Blob {\n        #[pymethod]\n        fn close(&self) {\n            self.inner.lock().take();\n        }\n\n        #[pymethod]\n        fn read(\n            &self,\n            length: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<PyBytes>> {\n            let mut length = length.unwrap_or(-1);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let max_read = blob_len - inner.offset;\n\n            if length < 0 || length > max_read {\n                length = max_read;\n            }\n\n            if length == 0 {\n                Ok(vm.ctx.empty_bytes.clone())\n            } else {\n                let mut buf = Vec::<u8>::with_capacity(length as usize);\n                let ret = inner\n                    .blob\n                    .read(buf.as_mut_ptr().cast(), length, inner.offset);\n                self.check(ret, vm)?;\n                unsafe { buf.set_len(length as usize) };\n                inner.offset += length;\n                Ok(vm.ctx.new_bytes(buf))\n            }\n        }\n\n        #[pymethod]\n        fn write(&self, data: PyBuffer, vm: &VirtualMachine) -> PyResult<()> {\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let length = Self::expect_write(blob_len, data.desc.len, inner.offset, vm)?;\n\n            let ret = data.contiguous_or_collect(|buf| {\n                inner.blob.write(buf.as_ptr().cast(), length, inner.offset)\n            });\n\n            self.check(ret, vm)?;\n            inner.offset += length;\n            Ok(())\n        }\n\n        #[pymethod]\n        fn tell(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.inner(vm).map(|x| x.offset)\n        }\n\n        #[pymethod]\n        fn seek(\n            &self,\n            mut offset: c_int,\n            origin: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let origin = origin.unwrap_or(libc::SEEK_SET);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n\n            let overflow_err = || vm.new_overflow_error(\"seek offset results in overflow\");\n\n            match origin {\n                libc::SEEK_SET => {}\n                libc::SEEK_CUR => {\n                    offset = offset.checked_add(inner.offset).ok_or_else(overflow_err)?\n                }\n                libc::SEEK_END => offset = offset.checked_add(blob_len).ok_or_else(overflow_err)?,\n                _ => {\n                    return Err(vm.new_value_error(\n                        \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\",\n                    ));\n                }\n            }\n\n            if offset < 0 || offset > blob_len {\n                Err(vm.new_value_error(\"offset out of blob range\"))\n            } else {\n                inner.offset = offset;\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult<PyRef<Self>> {\n            let _ = zelf.inner(vm)?;\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn __exit__(&self, _args: FuncArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let _ = self.inner(vm)?;\n            self.close();\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, BlobInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Cannot operate on a closed blob.\".to_owned(),\n                ))\n            }\n        }\n\n        fn wrapped_index(index: PyIntRef, length: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let mut index = index.try_to_primitive::<c_int>(vm)?;\n            if index < 0 {\n                index += length;\n            }\n            if index < 0 || index >= length {\n                Err(vm.new_index_error(\"Blob index out of range\"))\n            } else {\n                Ok(index)\n            }\n        }\n\n        fn expect_write(\n            blob_len: c_int,\n            length: usize,\n            offset: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<c_int> {\n            let max_write = blob_len - offset;\n            if length <= max_write as usize {\n                Ok(length as c_int)\n            } else {\n                Err(vm.new_value_error(\"data longer than blob length\"))\n            }\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            let inner = self.inner(vm)?;\n            if let Some(index) = needle.try_index_opt(vm) {\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                let mut byte: u8 = 0;\n                let ret = inner.blob.read_single(&mut byte, index);\n                self.check(ret, vm).map(|_| vm.ctx.new_int(byte).into())\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, length) = slice.adjust_indices(blob_len as usize);\n                let mut buf = Vec::<u8>::with_capacity(length);\n\n                if step == 1 {\n                    let ret = inner.blob.read(\n                        buf.as_mut_ptr().cast(),\n                        length as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n                    unsafe { buf.set_len(length) };\n                } else {\n                    let iter = SaturatedSliceIter::from_adjust_indices(range, step, length);\n                    let mut byte: u8 = 0;\n                    for index in iter {\n                        let ret = inner.blob.read_single(&mut byte, index as c_int);\n                        self.check(ret, vm)?;\n                        buf.push(byte);\n                    }\n                }\n                Ok(vm.ctx.new_bytes(buf).into())\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn ass_subscript(\n            &self,\n            needle: &PyObject,\n            value: Option<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(value) = value else {\n                return Err(vm.new_type_error(\"Blob doesn't support slice deletion\"));\n            };\n            let inner = self.inner(vm)?;\n\n            if let Some(index) = needle.try_index_opt(vm) {\n                // Handle single item assignment: blob[i] = b\n                let Some(value) = value.downcast_ref::<PyInt>() else {\n                    return Err(vm.new_type_error(format!(\n                        \"'{}' object cannot be interpreted as an integer\",\n                        value.class()\n                    )));\n                };\n                let value = value.try_to_primitive::<u8>(vm)?;\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                Self::expect_write(blob_len, 1, index, vm)?;\n                let ret = inner.blob.write_single(value, index);\n                self.check(ret, vm)\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                // Handle slice assignment: blob[a:b:c] = b\"...\"\n                let value_buf = PyBuffer::try_from_borrowed_object(vm, &value)?;\n\n                let buf = value_buf\n                    .as_contiguous()\n                    .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, slice_len) = slice.adjust_indices(blob_len as usize);\n\n                if step == 0 {\n                    return Err(vm.new_value_error(\"slice step cannot be zero\"));\n                }\n\n                if buf.len() != slice_len {\n                    return Err(vm.new_index_error(\"Blob slice assignment is wrong size\"));\n                }\n\n                if slice_len == 0 {\n                    return Ok(());\n                }\n\n                if step == 1 {\n                    let ret = inner.blob.write(\n                        buf.as_ptr().cast(),\n                        buf.len() as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                } else {\n                    let span_len = range.end - range.start;\n                    let mut temp_buf = vec![0u8; span_len];\n\n                    let ret = inner.blob.read(\n                        temp_buf.as_mut_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n\n                    let mut i_in_temp: usize = 0;\n                    for i_in_src in 0..slice_len {\n                        temp_buf[i_in_temp] = buf[i_in_src];\n                        i_in_temp += step as usize;\n                    }\n\n                    let ret = inner.blob.write(\n                        temp_buf.as_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                }\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn check(&self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.connection.db_lock(vm)?.error_extended(vm))\n            }\n        }\n    }\n\n    impl AsMapping for Blob {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: PyMappingMethods = PyMappingMethods {\n                length: atomic_func!(|mapping, vm| Blob::mapping_downcast(mapping)\n                    .inner(vm)\n                    .map(|x| x.blob.bytes() as usize)),\n                subscript: atomic_func!(|mapping, needle, vm| {\n                    Blob::mapping_downcast(mapping).subscript(needle, vm)\n                }),\n                ass_subscript: atomic_func!(|mapping, needle, value, vm| {\n                    Blob::mapping_downcast(mapping).ass_subscript(needle, value, vm)\n                }),\n            };\n            &AS_MAPPING\n        }\n    }\n\n    impl AsNumber for Blob {\n        fn as_number() -> &'static PyNumberMethods {\n            static AS_NUMBER: PyNumberMethods = PyNumberMethods {\n                add: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for +: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                multiply: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for *: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                ..PyNumberMethods::NOT_IMPLEMENTED\n            };\n            &AS_NUMBER\n        }\n    }\n\n    impl AsSequence for Blob {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: PySequenceMethods = PySequenceMethods {\n                length: AtomicCell::new(None),\n                concat: AtomicCell::new(None),\n                repeat: AtomicCell::new(None),\n                item: AtomicCell::new(None),\n                ass_item: AtomicCell::new(None),\n                contains: atomic_func!(|seq, _needle, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"argument of type '{}' is not iterable\",\n                        seq.obj.class().name(),\n                    )))\n                }),\n                inplace_concat: AtomicCell::new(None),\n                inplace_repeat: AtomicCell::new(None),\n            };\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(Debug, PyPayload)]\n    struct PrepareProtocol {}\n\n    #[pyclass()]\n    impl PrepareProtocol {}\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Statement\")]\n    #[derive(PyPayload)]\n    struct Statement {\n        st: PyMutex<SqliteStatement>,\n        pub is_dml: bool,\n    }\n\n    impl Debug for Statement {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(\n                f,\n                \"{} Statement\",\n                if self.is_dml { \"DML\" } else { \"Non-DML\" }\n            )\n        }\n    }\n\n    impl Unconstructible for Statement {}\n\n    #[pyclass(with(Unconstructible))]\n    impl Statement {\n        fn new(\n            connection: &Connection,\n            sql: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<Self>> {\n            if sql.as_str().contains('\\0') {\n                return Err(new_programming_error(\n                    vm,\n                    \"statement contains a null character.\".to_owned(),\n                ));\n            }\n            let sql_cstr = sql.to_cstring(vm)?;\n\n            let db = connection.db_lock(vm)?;\n\n            db.sql_limit(sql.byte_len(), vm)?;\n\n            let mut tail = null();\n            let st = db.prepare(sql_cstr.as_ptr(), &mut tail, vm)?;\n\n            let Some(st) = st else {\n                return Ok(None);\n            };\n\n            let tail = unsafe { CStr::from_ptr(tail) };\n            let tail = tail.to_bytes();\n            if lstrip_sql(tail).is_some() {\n                return Err(new_programming_error(\n                    vm,\n                    \"You can only execute one statement at a time.\".to_owned(),\n                ));\n            }\n\n            let is_dml = if let Some(head) = lstrip_sql(sql_cstr.as_bytes()) {\n                head.len() >= 6\n                    && (head[..6].eq_ignore_ascii_case(b\"insert\")\n                        || head[..6].eq_ignore_ascii_case(b\"update\")\n                        || head[..6].eq_ignore_ascii_case(b\"delete\")\n                        || (head.len() >= 7 && head[..7].eq_ignore_ascii_case(b\"replace\")))\n            } else {\n                false\n            };\n\n            Ok(Some(Self {\n                st: PyMutex::from(st),\n                is_dml,\n            }))\n        }\n\n        fn lock(&self) -> PyMutexGuard<'_, SqliteStatement> {\n            self.st.lock()\n        }\n    }\n\n    struct Sqlite {\n        raw: SqliteRaw,\n    }\n\n    impl From<SqliteRaw> for Sqlite {\n        fn from(raw: SqliteRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for Sqlite {\n        fn drop(&mut self) {\n            unsafe { sqlite3_close_v2(self.raw.db) };\n        }\n    }\n\n    impl Deref for Sqlite {\n        type Target = SqliteRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteRaw {\n        db: *mut sqlite3,\n    }\n\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"threading\")] {\n            unsafe impl Send for SqliteStatement {}\n            // unsafe impl Sync for SqliteStatement {}\n            unsafe impl Send for Sqlite {}\n            // unsafe impl Sync for Sqlite {}\n            unsafe impl Send for SqliteBlob {}\n        }\n    }\n\n    impl From<SqliteStatementRaw> for SqliteRaw {\n        fn from(stmt: SqliteStatementRaw) -> Self {\n            unsafe {\n                Self {\n                    db: sqlite3_db_handle(stmt.st),\n                }\n            }\n        }\n    }\n\n    impl SqliteRaw {\n        fn check(self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.error_extended(vm))\n            }\n        }\n\n        fn error_extended(self, vm: &VirtualMachine) -> PyBaseExceptionRef {\n            let errcode = unsafe { sqlite3_errcode(self.db) };\n            let typ = exception_type_from_errcode(errcode, vm);\n            let extended_errcode = unsafe { sqlite3_extended_errcode(self.db) };\n            let errmsg = unsafe { sqlite3_errmsg(self.db) };\n            let errmsg = unsafe { CStr::from_ptr(errmsg) };\n            let errmsg = errmsg.to_str().unwrap().to_owned();\n\n            raise_exception(typ.to_owned(), extended_errcode, errmsg, vm)\n        }\n\n        fn open(path: *const libc::c_char, uri: bool, vm: &VirtualMachine) -> PyResult<Self> {\n            let mut db = null_mut();\n            let ret = unsafe {\n                sqlite3_open_v2(\n                    path,\n                    &raw mut db,\n                    SQLITE_OPEN_READWRITE\n                        | SQLITE_OPEN_CREATE\n                        | if uri { SQLITE_OPEN_URI } else { 0 },\n                    null(),\n                )\n            };\n            let zelf = Self { db };\n            zelf.check(ret, vm).map(|_| zelf)\n        }\n\n        fn _exec(self, sql: &[u8], vm: &VirtualMachine) -> PyResult<()> {\n            let ret =\n                unsafe { sqlite3_exec(self.db, sql.as_ptr().cast(), None, null_mut(), null_mut()) };\n            self.check(ret, vm)\n        }\n\n        fn prepare(\n            self,\n            sql: *const libc::c_char,\n            tail: *mut *const libc::c_char,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<SqliteStatement>> {\n            let mut st = null_mut();\n            let ret = unsafe { sqlite3_prepare_v2(self.db, sql, -1, &mut st, tail) };\n            self.check(ret, vm)?;\n            if st.is_null() {\n                Ok(None)\n            } else {\n                Ok(Some(SqliteStatement::from(SqliteStatementRaw::from(st))))\n            }\n        }\n\n        fn limit(self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let old_limit = unsafe { sqlite3_limit(self.db, category, limit) };\n            if old_limit >= 0 {\n                Ok(old_limit)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"'category' is out of bounds\".to_owned(),\n                ))\n            }\n        }\n\n        fn sql_limit(self, len: usize, vm: &VirtualMachine) -> PyResult<()> {\n            if len <= unsafe { sqlite3_limit(self.db, SQLITE_LIMIT_SQL_LENGTH, -1) } as usize {\n                Ok(())\n            } else {\n                Err(new_data_error(vm, \"query string is too large\".to_owned()))\n            }\n        }\n\n        fn is_autocommit(self) -> bool {\n            unsafe { sqlite3_get_autocommit(self.db) != 0 }\n        }\n\n        fn changes(self) -> c_int {\n            unsafe { sqlite3_changes(self.db) }\n        }\n\n        fn total_changes(self) -> c_int {\n            unsafe { sqlite3_total_changes(self.db) }\n        }\n\n        fn lastrowid(self) -> c_longlong {\n            unsafe { sqlite3_last_insert_rowid(self.db) }\n        }\n\n        fn implicit_commit(self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.is_autocommit() {\n                Ok(())\n            } else {\n                self._exec(b\"COMMIT\\0\", vm)\n            }\n        }\n\n        fn begin_transaction(\n            self,\n            isolation_level: Option<PyStrRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(isolation_level) = isolation_level else {\n                return Ok(());\n            };\n            let mut s = Vec::with_capacity(16);\n            s.extend(b\"BEGIN \");\n            s.extend(isolation_level.as_str().bytes());\n            s.push(b'\\0');\n            self._exec(&s, vm)\n        }\n\n        fn interrupt(self) {\n            unsafe { sqlite3_interrupt(self.db) }\n        }\n\n        fn busy_timeout(self, timeout: i32) {\n            unsafe { sqlite3_busy_timeout(self.db, timeout) };\n        }\n\n        #[allow(clippy::too_many_arguments)]\n        fn create_function(\n            self,\n            name: *const libc::c_char,\n            narg: c_int,\n            flags: c_int,\n            data: *mut c_void,\n            func: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            step: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            finalize: Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n            destroy: Option<unsafe extern \"C\" fn(arg1: *mut c_void)>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let ret = unsafe {\n                sqlite3_create_function_v2(\n                    self.db, name, narg, flags, data, func, step, finalize, destroy,\n                )\n            };\n            self.check(ret, vm)\n                .map_err(|_| new_operational_error(vm, \"Error creating function\".to_owned()))\n        }\n    }\n\n    struct SqliteStatement {\n        raw: SqliteStatementRaw,\n    }\n\n    impl From<SqliteStatementRaw> for SqliteStatement {\n        fn from(raw: SqliteStatementRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for SqliteStatement {\n        fn drop(&mut self) {\n            unsafe {\n                sqlite3_finalize(self.raw.st);\n            }\n        }\n    }\n\n    impl Deref for SqliteStatement {\n        type Target = SqliteStatementRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteStatementRaw {\n        st: *mut sqlite3_stmt,\n    }\n\n    impl From<*mut sqlite3_stmt> for SqliteStatementRaw {\n        fn from(st: *mut sqlite3_stmt) -> Self {\n            SqliteStatementRaw { st }\n        }\n    }\n\n    impl SqliteStatementRaw {\n        fn step(self) -> c_int {\n            unsafe { sqlite3_step(self.st) }\n        }\n\n        fn step_row_else_done(self, vm: &VirtualMachine) -> PyResult<bool> {\n            let ret = self.step();\n\n            if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                Err(exc)\n            } else if ret == SQLITE_ROW {\n                Ok(true)\n            } else if ret == SQLITE_DONE {\n                Ok(false)\n            } else {\n                Err(SqliteRaw::from(self).error_extended(vm))\n            }\n        }\n\n        fn reset(self) {\n            unsafe { sqlite3_reset(self.st) };\n        }\n\n        fn data_count(self) -> c_int {\n            unsafe { sqlite3_data_count(self.st) }\n        }\n\n        fn bind_parameter(\n            self,\n            pos: c_int,\n            parameter: &PyObject,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let adapted;\n            let obj = if need_adapt(parameter, vm) {\n                adapted = _adapt(\n                    parameter,\n                    PrepareProtocol::class(&vm.ctx).to_owned(),\n                    |x| Ok(x.to_owned()),\n                    vm,\n                )?;\n                &adapted\n            } else {\n                parameter\n            };\n\n            let ret = if vm.is_none(obj) {\n                unsafe { sqlite3_bind_null(self.st, pos) }\n            } else if let Some(val) = obj.downcast_ref::<PyInt>() {\n                let val = val.try_to_primitive::<i64>(vm).map_err(|_| {\n                    vm.new_overflow_error(\"Python int too large to convert to SQLite INTEGER\")\n                })?;\n                unsafe { sqlite3_bind_int64(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyFloat>() {\n                let val = val.to_f64();\n                unsafe { sqlite3_bind_double(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyStr>() {\n                let val = val.try_as_utf8(vm)?;\n                let (ptr, len) = str_to_ptr_len(val, vm)?;\n                unsafe { sqlite3_bind_text(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, obj) {\n                let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                unsafe { sqlite3_bind_blob(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Error binding parameter {}: type '{}' is not supported\",\n                        pos,\n                        obj.class()\n                    ),\n                ));\n            };\n\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                let db = SqliteRaw::from(self);\n                db.check(ret, vm)\n            }\n        }\n\n        fn bind_parameters(self, parameters: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            if let Some(dict) = parameters.downcast_ref::<PyDict>() {\n                self.bind_parameters_name(dict, vm)\n            } else if let Ok(seq) = PySequence::try_protocol(parameters, vm) {\n                self.bind_parameters_sequence(seq, vm)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"parameters are of unsupported type\".to_owned(),\n                ))\n            }\n        }\n\n        fn bind_parameters_name(self, dict: &Py<PyDict>, vm: &VirtualMachine) -> PyResult<()> {\n            let num_needed = unsafe { sqlite3_bind_parameter_count(self.st) };\n\n            for i in 1..=num_needed {\n                let name = unsafe { sqlite3_bind_parameter_name(self.st, i) };\n                if name.is_null() {\n                    return Err(new_programming_error(vm, \"Binding {} has no name, but you supplied a dictionary (which has only names).\".to_owned()));\n                }\n                let name = unsafe { name.add(1) };\n                let name = ptr_to_str(name, vm)?;\n\n                let val = match dict.get_item_opt(name, vm)? {\n                    Some(val) => val,\n                    None => {\n                        return Err(new_programming_error(\n                            vm,\n                            format!(\"You did not supply a value for binding parameter :{name}.\",),\n                        ));\n                    }\n                };\n\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn bind_parameter_count(self) -> c_int {\n            unsafe { sqlite3_bind_parameter_count(self.st) }\n        }\n\n        fn bind_parameters_sequence(\n            self,\n            seq: PySequence<'_>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let num_needed = self.bind_parameter_count();\n            let num_supplied = seq.length(vm)?;\n\n            if num_supplied != num_needed as usize {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Incorrect number of bindings supplied. The current statement uses {}, and {} were supplied.\",\n                        num_needed, num_supplied\n                    ),\n                ));\n            }\n\n            for i in 1..=num_needed {\n                let val = seq.get_item(i as isize - 1, vm)?;\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn column_count(self) -> c_int {\n            unsafe { sqlite3_column_count(self.st) }\n        }\n\n        fn column_type(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_type(self.st, pos) }\n        }\n\n        fn column_int(self, pos: c_int) -> i64 {\n            unsafe { sqlite3_column_int64(self.st, pos) }\n        }\n\n        fn column_double(self, pos: c_int) -> f64 {\n            unsafe { sqlite3_column_double(self.st, pos) }\n        }\n\n        fn column_blob(self, pos: c_int) -> *const c_void {\n            unsafe { sqlite3_column_blob(self.st, pos) }\n        }\n\n        fn column_text(self, pos: c_int) -> *const u8 {\n            unsafe { sqlite3_column_text(self.st, pos) }\n        }\n\n        fn column_decltype(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_decltype(self.st, pos) }\n        }\n\n        fn column_bytes(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_bytes(self.st, pos) }\n        }\n\n        fn column_name(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_name(self.st, pos) }\n        }\n\n        fn columns_name(self, detect_types: i32, vm: &VirtualMachine) -> PyResult<Vec<PyStrRef>> {\n            let count = self.column_count();\n            (0..count)\n                .map(|i| {\n                    let name = self.column_name(i);\n                    let name_str = ptr_to_str(name, vm)?;\n\n                    // If PARSE_COLNAMES is enabled, strip everything after the first '[' (and preceding space)\n                    let processed_name = if detect_types & PARSE_COLNAMES != 0\n                        && let Some(bracket_pos) = name_str.find('[')\n                    {\n                        // Check if there's a single space before '[' and remove it (CPython compatibility)\n                        let end_pos = if bracket_pos > 0\n                            && name_str.chars().nth(bracket_pos - 1) == Some(' ')\n                        {\n                            bracket_pos - 1\n                        } else {\n                            bracket_pos\n                        };\n\n                        &name_str[..end_pos]\n                    } else {\n                        name_str\n                    };\n\n                    Ok(vm.ctx.new_str(processed_name))\n                })\n                .collect()\n        }\n\n        fn columns_description(\n            self,\n            detect_types: i32,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<PyTupleRef>> {\n            if self.column_count() == 0 {\n                return Ok(None);\n            }\n            let columns = self\n                .columns_name(detect_types, vm)?\n                .into_iter()\n                .map(|s| {\n                    vm.ctx\n                        .new_tuple(vec![\n                            s.into(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                        ])\n                        .into()\n                })\n                .collect();\n            Ok(Some(vm.ctx.new_tuple(columns)))\n        }\n\n        fn busy(self) -> bool {\n            unsafe { sqlite3_stmt_busy(self.st) != 0 }\n        }\n\n        fn readonly(self) -> bool {\n            unsafe { sqlite3_stmt_readonly(self.st) != 0 }\n        }\n    }\n\n    #[derive(Debug, Copy, Clone)]\n    struct SqliteBlob {\n        blob: *mut sqlite3_blob,\n    }\n\n    impl SqliteBlob {\n        fn bytes(self) -> c_int {\n            unsafe { sqlite3_blob_bytes(self.blob) }\n        }\n\n        fn write(self, buf: *const c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_write(self.blob, buf, length, offset) }\n        }\n\n        fn read(self, buf: *mut c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_read(self.blob, buf, length, offset) }\n        }\n\n        fn read_single(self, byte: &mut u8, offset: c_int) -> c_int {\n            self.read(byte as *mut u8 as *mut _, 1, offset)\n        }\n\n        fn write_single(self, byte: u8, offset: c_int) -> c_int {\n            self.write(&byte as *const u8 as *const _, 1, offset)\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteContext {\n        ctx: *mut sqlite3_context,\n    }\n\n    impl From<*mut sqlite3_context> for SqliteContext {\n        fn from(ctx: *mut sqlite3_context) -> Self {\n            Self { ctx }\n        }\n    }\n\n    impl SqliteContext {\n        fn user_data<T>(self) -> *mut T {\n            unsafe { sqlite3_user_data(self.ctx).cast() }\n        }\n\n        fn aggregate_context<T>(self) -> *mut T {\n            unsafe { sqlite3_aggregate_context(self.ctx, std::mem::size_of::<T>() as c_int).cast() }\n        }\n\n        fn result_exception(self, vm: &VirtualMachine, exc: PyBaseExceptionRef, msg: &str) {\n            if exc.fast_isinstance(vm.ctx.exceptions.memory_error) {\n                unsafe { sqlite3_result_error_nomem(self.ctx) }\n            } else if exc.fast_isinstance(vm.ctx.exceptions.overflow_error) {\n                unsafe { sqlite3_result_error_toobig(self.ctx) }\n            } else {\n                unsafe { sqlite3_result_error(self.ctx, msg.as_ptr().cast(), -1) }\n            }\n            if enable_traceback().load(Ordering::Relaxed) {\n                vm.print_exception(exc);\n            }\n        }\n\n        fn db_handle(self) -> *mut sqlite3 {\n            unsafe { sqlite3_context_db_handle(self.ctx) }\n        }\n\n        fn result_from_object(self, val: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            unsafe {\n                if vm.is_none(val) {\n                    sqlite3_result_null(self.ctx)\n                } else if let Some(val) = val.downcast_ref::<PyInt>() {\n                    sqlite3_result_int64(self.ctx, val.try_to_primitive(vm)?)\n                } else if let Some(val) = val.downcast_ref::<PyFloat>() {\n                    sqlite3_result_double(self.ctx, val.to_f64())\n                } else if let Some(val) = val.downcast_ref::<PyStr>() {\n                    let val = val.try_as_utf8(vm)?;\n                    let (ptr, len) = str_to_ptr_len(val, vm)?;\n                    sqlite3_result_text(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, val) {\n                    let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                    sqlite3_result_blob(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else {\n                    return Err(new_programming_error(\n                        vm,\n                        \"result type not support\".to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n    }\n\n    fn value_to_object(val: *mut sqlite3_value, db: *mut sqlite3, vm: &VirtualMachine) -> PyResult {\n        let obj = unsafe {\n            match sqlite3_value_type(val) {\n                SQLITE_INTEGER => vm.ctx.new_int(sqlite3_value_int64(val)).into(),\n                SQLITE_FLOAT => vm.ctx.new_float(sqlite3_value_double(val)).into(),\n                SQLITE_TEXT => {\n                    let text =\n                        ptr_to_vec(sqlite3_value_text(val), sqlite3_value_bytes(val), db, vm)?;\n                    let text = String::from_utf8(text)\n                        .map_err(|_| vm.new_value_error(\"invalid utf-8 with SQLITE_TEXT\"))?;\n                    vm.ctx.new_str(text).into()\n                }\n                SQLITE_BLOB => {\n                    let blob = ptr_to_vec(\n                        sqlite3_value_blob(val).cast(),\n                        sqlite3_value_bytes(val),\n                        db,\n                        vm,\n                    )?;\n                    vm.ctx.new_bytes(blob).into()\n                }\n                _ => vm.ctx.none(),\n            }\n        };\n        Ok(obj)\n    }\n\n    fn ptr_to_str<'a>(p: *const libc::c_char, vm: &VirtualMachine) -> PyResult<&'a str> {\n        if p.is_null() {\n            return Err(vm.new_memory_error(\"string pointer is null\"));\n        }\n        unsafe { CStr::from_ptr(p).to_str() }\n            .map_err(|_| vm.new_value_error(\"Invalid UIF-8 codepoint\"))\n    }\n\n    fn ptr_to_string(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<String> {\n        let s = ptr_to_vec(p, nbytes, db, vm)?;\n        String::from_utf8(s).map_err(|_| vm.new_value_error(\"invalid utf-8\"))\n    }\n\n    fn ptr_to_vec(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<Vec<u8>> {\n        if p.is_null() {\n            if !db.is_null() && unsafe { sqlite3_errcode(db) } == SQLITE_NOMEM {\n                Err(vm.new_memory_error(\"sqlite out of memory\"))\n            } else {\n                Ok(vec![])\n            }\n        } else if nbytes < 0 {\n            Err(vm.new_system_error(\"negative size with ptr\"))\n        } else {\n            Ok(unsafe { std::slice::from_raw_parts(p.cast(), nbytes as usize) }.to_vec())\n        }\n    }\n\n    fn str_to_ptr_len(s: &PyUtf8Str, vm: &VirtualMachine) -> PyResult<(*const libc::c_char, i32)> {\n        let s_str = s.as_str();\n        let len = c_int::try_from(s_str.len())\n            .map_err(|_| vm.new_overflow_error(\"TEXT longer than INT_MAX bytes\"))?;\n        let ptr = s_str.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn buffer_to_ptr_len(buffer: &PyBuffer, vm: &VirtualMachine) -> PyResult<(*const c_void, i32)> {\n        let bytes = buffer\n            .as_contiguous()\n            .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n        let len = c_int::try_from(bytes.len())\n            .map_err(|_| vm.new_overflow_error(\"BLOB longer than INT_MAX bytes\"))?;\n        let ptr = bytes.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn exception_type_from_errcode(errcode: c_int, vm: &VirtualMachine) -> &'static Py<PyType> {\n        match errcode {\n            SQLITE_INTERNAL | SQLITE_NOTFOUND => internal_error_type(),\n            SQLITE_NOMEM => vm.ctx.exceptions.memory_error,\n            SQLITE_ERROR | SQLITE_PERM | SQLITE_ABORT | SQLITE_BUSY | SQLITE_LOCKED\n            | SQLITE_READONLY | SQLITE_INTERRUPT | SQLITE_IOERR | SQLITE_FULL | SQLITE_CANTOPEN\n            | SQLITE_PROTOCOL | SQLITE_EMPTY | SQLITE_SCHEMA => operational_error_type(),\n            SQLITE_CORRUPT => database_error_type(),\n            SQLITE_TOOBIG => data_error_type(),\n            SQLITE_CONSTRAINT | SQLITE_MISMATCH => integrity_error_type(),\n            SQLITE_MISUSE | SQLITE_RANGE => interface_error_type(),\n            _ => database_error_type(),\n        }\n    }\n\n    fn name_from_errcode(errcode: c_int) -> &'static str {\n        for (name, code) in ERROR_CODES {\n            if *code == errcode {\n                return name;\n            }\n        }\n        \"unknown error code\"\n    }\n\n    fn raise_exception(\n        typ: PyTypeRef,\n        errcode: c_int,\n        msg: String,\n        vm: &VirtualMachine,\n    ) -> PyBaseExceptionRef {\n        let dict = vm.ctx.new_dict();\n        if let Err(e) = dict.set_item(\"sqlite_errorcode\", vm.ctx.new_int(errcode).into(), vm) {\n            return e;\n        }\n        let errname = name_from_errcode(errcode);\n        if let Err(e) = dict.set_item(\"sqlite_errorname\", vm.ctx.new_str(errname).into(), vm) {\n            return e;\n        }\n\n        vm.new_exception_msg_dict(typ, msg, dict)\n    }\n\n    static BEGIN_STATEMENTS: &[&[u8]] = &[\n        b\"BEGIN \",\n        b\"BEGIN DEFERRED\",\n        b\"BEGIN IMMEDIATE\",\n        b\"BEGIN EXCLUSIVE\",\n    ];\n\n    fn begin_statement_ptr_from_isolation_level(\n        s: &PyStr,\n        vm: &VirtualMachine,\n    ) -> PyResult<*const libc::c_char> {\n        BEGIN_STATEMENTS\n            .iter()\n            .find(|&&x| x[6..].eq_ignore_ascii_case(s.as_bytes()))\n            .map(|&x| x.as_ptr().cast())\n            .ok_or_else(|| {\n                vm.new_value_error(\n                    \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or 'EXCLUSIVE'\",\n                )\n            })\n    }\n\n    fn lstrip_sql(sql: &[u8]) -> Option<&[u8]> {\n        let mut pos = 0;\n\n        // This loop is borrowed from the SQLite source code.\n        while let Some(t_char) = sql.get(pos) {\n            match t_char {\n                b' ' | b'\\t' | b'\\x0c' | b'\\n' | b'\\r' => {\n                    // Skip whitespace.\n                    pos += 1;\n                }\n                b'-' => {\n                    // Skip line comments.\n                    if sql.get(pos + 1) == Some(&b'-') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'\\n' {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                b'/' => {\n                    // Skip C style comments.\n                    if sql.get(pos + 1) == Some(&b'*') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'*' && sql.get(pos + 1) == Some(&b'/') {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                        pos += 2;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                _ => {\n                    return Some(&sql[pos..]);\n                }\n            }\n        }\n\n        None\n    }\n}\n"
                }
              ],
              []
            ],
            "kind": "textEditGroup",
            "uri": {
              "$mid": 1,
              "external": "file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "fsPath": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "path": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "scheme": "file"
            }
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#1820-1820), 1820 줄에서 1910 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "textEditGroup",
          "input": {
            "done": true,
            "edits": [
              [
                {
                  "range": {
                    "endColumn": 1,
                    "endLineNumber": 3392,
                    "startColumn": 1,
                    "startLineNumber": 1
                  },
                  "text": "// spell-checker:ignore libsqlite3 threadsafety PYSQLITE decltypes colnames collseq cantinit dirtywal\n// spell-checker:ignore corruptfs narg setinputsizes setoutputsize lastrowid arraysize executemany\n// spell-checker:ignore blobopen executescript iterdump getlimit setlimit errorcode errorname\n// spell-checker:ignore rowid rowcount fetchone fetchmany fetchall errcode errname vtable pagecount\n// spell-checker:ignore autocommit libversion toobig errmsg nomem threadsafe longlong vdbe reindex\n// spell-checker:ignore savepoint cantopen ioerr nolfs nomem notadb notfound fullpath notempdir vtab\n// spell-checker:ignore checkreservedlock noent fstat rdlock shmlock shmmap shmopen shmsize sharedcache\n// spell-checker:ignore cantlock commithook foreignkey notnull primarykey gettemppath autoindex convpath\n// spell-checker:ignore dbmoved vnode nbytes\n\nuse rustpython_vm::{AsObject, PyRef, VirtualMachine, builtins::PyModule};\n\n// pub(crate) use _sqlite::make_module;\npub(crate) fn make_module(vm: &VirtualMachine) -> PyRef<PyModule> {\n    // TODO: sqlite version check\n    let module = _sqlite::make_module(vm);\n    _sqlite::setup_module(module.as_object(), vm);\n    module\n}\n\n#[pymodule]\nmod _sqlite {\n    use crossbeam_utils::atomic::AtomicCell;\n    use libsqlite3_sys::{\n        SQLITE_BLOB, SQLITE_DETERMINISTIC, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL,\n        SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, SQLITE_OPEN_URI, SQLITE_TEXT, SQLITE_TRACE_STMT,\n        SQLITE_TRANSIENT, SQLITE_UTF8, sqlite3, sqlite3_aggregate_context, sqlite3_backup_finish,\n        sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining,\n        sqlite3_backup_step, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64,\n        sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name,\n        sqlite3_bind_text, sqlite3_blob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open,\n        sqlite3_blob_read, sqlite3_blob_write, sqlite3_busy_timeout, sqlite3_changes,\n        sqlite3_close_v2, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count,\n        sqlite3_column_decltype, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_name,\n        sqlite3_column_text, sqlite3_column_type, sqlite3_complete, sqlite3_context,\n        sqlite3_context_db_handle, sqlite3_create_collation_v2, sqlite3_create_function_v2,\n        sqlite3_create_window_function, sqlite3_data_count, sqlite3_db_handle, sqlite3_errcode,\n        sqlite3_errmsg, sqlite3_exec, sqlite3_expanded_sql, sqlite3_extended_errcode,\n        sqlite3_finalize, sqlite3_get_autocommit, sqlite3_interrupt, sqlite3_last_insert_rowid,\n        sqlite3_libversion, sqlite3_limit, sqlite3_open_v2, sqlite3_prepare_v2,\n        sqlite3_progress_handler, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double,\n        sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_error_toobig,\n        sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_set_authorizer,\n        sqlite3_sleep, sqlite3_step, sqlite3_stmt, sqlite3_stmt_busy, sqlite3_stmt_readonly,\n        sqlite3_threadsafe, sqlite3_total_changes, sqlite3_trace_v2, sqlite3_user_data,\n        sqlite3_value, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double,\n        sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type,\n    };\n    use malachite_bigint::Sign;\n    use rustpython_common::{\n        atomic::{Ordering, PyAtomic, Radium},\n        hash::PyHash,\n        lock::{PyMappedMutexGuard, PyMutex, PyMutexGuard},\n        static_cell,\n    };\n    use rustpython_vm::{\n        __exports::paste,\n        AsObject, Py, PyAtomicRef, PyObject, PyObjectRef, PyPayload, PyRef, PyResult,\n        TryFromBorrowedObject, VirtualMachine, atomic_func,\n        builtins::{\n            PyBaseException, PyBaseExceptionRef, PyByteArray, PyBytes, PyDict, PyDictRef, PyFloat,\n            PyInt, PyIntRef, PySlice, PyStr, PyStrRef, PyTuple, PyTupleRef, PyType, PyTypeRef,\n            PyUtf8Str, PyUtf8StrRef,\n        },\n        convert::IntoObject,\n        function::{\n            ArgCallable, ArgIterable, FsPath, FuncArgs, OptionalArg, PyComparisonValue,\n            PySetterValue,\n        },\n        object::{Traverse, TraverseFn},\n        protocol::{\n            PyBuffer, PyIterReturn, PyMappingMethods, PyNumberMethods, PySequence,\n            PySequenceMethods,\n        },\n        sliceable::{SaturatedSliceIter, SliceableSequenceOp},\n        types::{\n            AsMapping, AsNumber, AsSequence, Callable, Comparable, Constructor, Hashable,\n            Initializer, IterNext, Iterable, PyComparisonOp, SelfIter, Unconstructible,\n        },\n        utils::ToCString,\n    };\n    use std::{\n        ffi::{CStr, c_int, c_longlong, c_uint, c_void},\n        fmt::Debug,\n        ops::Deref,\n        ptr::{NonNull, null, null_mut},\n        thread::ThreadId,\n    };\n\n    macro_rules! exceptions {\n        ($(($x:ident, $base:expr)),*) => {\n            paste::paste! {\n                static_cell! {\n                    $(\n                        static [<$x:snake:upper>]: PyTypeRef;\n                    )*\n                }\n                $(\n                    #[allow(dead_code)]\n                    fn [<new_ $x:snake>](vm: &VirtualMachine, msg: String) -> PyBaseExceptionRef {\n                        vm.new_exception_msg([<$x:snake _type>]().to_owned(), msg)\n                    }\n                    fn [<$x:snake _type>]() -> &'static Py<PyType> {\n                        [<$x:snake:upper>].get().expect(\"exception type not initialize\")\n                    }\n                )*\n                fn setup_module_exceptions(module: &PyObject, vm: &VirtualMachine) {\n                    $(\n                        #[allow(clippy::redundant_closure_call)]\n                        let exception = [<$x:snake:upper>].get_or_init(|| {\n                            let base = $base(vm);\n                            vm.ctx.new_exception_type(\"_sqlite3\", stringify!($x), Some(vec![base.to_owned()]))\n                        });\n                        module.set_attr(stringify!($x), exception.clone().into_object(), vm).unwrap();\n                    )*\n                }\n            }\n        };\n    }\n\n    exceptions!(\n        (Warning, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (Error, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (InterfaceError, |_| error_type()),\n        (DatabaseError, |_| error_type()),\n        (DataError, |_| database_error_type()),\n        (OperationalError, |_| database_error_type()),\n        (IntegrityError, |_| database_error_type()),\n        (InternalError, |_| database_error_type()),\n        (ProgrammingError, |_| database_error_type()),\n        (NotSupportedError, |_| database_error_type())\n    );\n\n    #[pyattr]\n    fn sqlite_version(vm: &VirtualMachine) -> String {\n        let s = unsafe { sqlite3_libversion() };\n        ptr_to_str(s, vm).unwrap().to_owned()\n    }\n\n    #[pyattr]\n    fn threadsafety(_: &VirtualMachine) -> c_int {\n        let mode = unsafe { sqlite3_threadsafe() };\n        match mode {\n            0 => 0,\n            1 => 3,\n            2 => 1,\n            _ => panic!(\"Unable to interpret SQLite threadsafety mode\"),\n        }\n    }\n\n    #[pyattr(name = \"_deprecated_version\")]\n    const PYSQLITE_VERSION: &str = \"2.6.0\";\n\n    #[pyattr]\n    const PARSE_DECLTYPES: c_int = 1;\n    #[pyattr]\n    const PARSE_COLNAMES: c_int = 2;\n\n    #[pyattr]\n    use libsqlite3_sys::{\n        SQLITE_ALTER_TABLE, SQLITE_ANALYZE, SQLITE_ATTACH, SQLITE_CREATE_INDEX,\n        SQLITE_CREATE_TABLE, SQLITE_CREATE_TEMP_INDEX, SQLITE_CREATE_TEMP_TABLE,\n        SQLITE_CREATE_TEMP_TRIGGER, SQLITE_CREATE_TEMP_VIEW, SQLITE_CREATE_TRIGGER,\n        SQLITE_CREATE_VIEW, SQLITE_CREATE_VTABLE, SQLITE_DELETE, SQLITE_DENY, SQLITE_DETACH,\n        SQLITE_DROP_INDEX, SQLITE_DROP_TABLE, SQLITE_DROP_TEMP_INDEX, SQLITE_DROP_TEMP_TABLE,\n        SQLITE_DROP_TEMP_TRIGGER, SQLITE_DROP_TEMP_VIEW, SQLITE_DROP_TRIGGER, SQLITE_DROP_VIEW,\n        SQLITE_DROP_VTABLE, SQLITE_FUNCTION, SQLITE_IGNORE, SQLITE_INSERT, SQLITE_LIMIT_ATTACHED,\n        SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH,\n        SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH,\n        SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER,\n        SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_PRAGMA, SQLITE_READ,\n        SQLITE_RECURSIVE, SQLITE_REINDEX, SQLITE_SAVEPOINT, SQLITE_SELECT, SQLITE_TRANSACTION,\n        SQLITE_UPDATE,\n    };\n\n    macro_rules! error_codes {\n        ($($x:ident),*) => {\n            $(\n                #[allow(unused_imports)]\n                use libsqlite3_sys::$x;\n            )*\n            static ERROR_CODES: &[(&str, c_int)] = &[\n            $(\n                (stringify!($x), libsqlite3_sys::$x),\n            )*\n            ];\n        };\n    }\n\n    error_codes!(\n        SQLITE_ABORT,\n        SQLITE_AUTH,\n        SQLITE_BUSY,\n        SQLITE_CANTOPEN,\n        SQLITE_CONSTRAINT,\n        SQLITE_CORRUPT,\n        SQLITE_DONE,\n        SQLITE_EMPTY,\n        SQLITE_ERROR,\n        SQLITE_FORMAT,\n        SQLITE_FULL,\n        SQLITE_INTERNAL,\n        SQLITE_INTERRUPT,\n        SQLITE_IOERR,\n        SQLITE_LOCKED,\n        SQLITE_MISMATCH,\n        SQLITE_MISUSE,\n        SQLITE_NOLFS,\n        SQLITE_NOMEM,\n        SQLITE_NOTADB,\n        SQLITE_NOTFOUND,\n        SQLITE_OK,\n        SQLITE_PERM,\n        SQLITE_PROTOCOL,\n        SQLITE_RANGE,\n        SQLITE_READONLY,\n        SQLITE_ROW,\n        SQLITE_SCHEMA,\n        SQLITE_TOOBIG,\n        SQLITE_NOTICE,\n        SQLITE_WARNING,\n        SQLITE_ABORT_ROLLBACK,\n        SQLITE_BUSY_RECOVERY,\n        SQLITE_CANTOPEN_FULLPATH,\n        SQLITE_CANTOPEN_ISDIR,\n        SQLITE_CANTOPEN_NOTEMPDIR,\n        SQLITE_CORRUPT_VTAB,\n        SQLITE_IOERR_ACCESS,\n        SQLITE_IOERR_BLOCKED,\n        SQLITE_IOERR_CHECKRESERVEDLOCK,\n        SQLITE_IOERR_CLOSE,\n        SQLITE_IOERR_DELETE,\n        SQLITE_IOERR_DELETE_NOENT,\n        SQLITE_IOERR_DIR_CLOSE,\n        SQLITE_IOERR_DIR_FSYNC,\n        SQLITE_IOERR_FSTAT,\n        SQLITE_IOERR_FSYNC,\n        SQLITE_IOERR_LOCK,\n        SQLITE_IOERR_NOMEM,\n        SQLITE_IOERR_RDLOCK,\n        SQLITE_IOERR_READ,\n        SQLITE_IOERR_SEEK,\n        SQLITE_IOERR_SHMLOCK,\n        SQLITE_IOERR_SHMMAP,\n        SQLITE_IOERR_SHMOPEN,\n        SQLITE_IOERR_SHMSIZE,\n        SQLITE_IOERR_SHORT_READ,\n        SQLITE_IOERR_TRUNCATE,\n        SQLITE_IOERR_UNLOCK,\n        SQLITE_IOERR_WRITE,\n        SQLITE_LOCKED_SHAREDCACHE,\n        SQLITE_READONLY_CANTLOCK,\n        SQLITE_READONLY_RECOVERY,\n        SQLITE_CONSTRAINT_CHECK,\n        SQLITE_CONSTRAINT_COMMITHOOK,\n        SQLITE_CONSTRAINT_FOREIGNKEY,\n        SQLITE_CONSTRAINT_FUNCTION,\n        SQLITE_CONSTRAINT_NOTNULL,\n        SQLITE_CONSTRAINT_PRIMARYKEY,\n        SQLITE_CONSTRAINT_TRIGGER,\n        SQLITE_CONSTRAINT_UNIQUE,\n        SQLITE_CONSTRAINT_VTAB,\n        SQLITE_READONLY_ROLLBACK,\n        SQLITE_IOERR_MMAP,\n        SQLITE_NOTICE_RECOVER_ROLLBACK,\n        SQLITE_NOTICE_RECOVER_WAL,\n        SQLITE_BUSY_SNAPSHOT,\n        SQLITE_IOERR_GETTEMPPATH,\n        SQLITE_WARNING_AUTOINDEX,\n        SQLITE_CANTOPEN_CONVPATH,\n        SQLITE_IOERR_CONVPATH,\n        SQLITE_CONSTRAINT_ROWID,\n        SQLITE_READONLY_DBMOVED,\n        SQLITE_AUTH_USER,\n        SQLITE_OK_LOAD_PERMANENTLY,\n        SQLITE_IOERR_VNODE,\n        SQLITE_IOERR_AUTH,\n        SQLITE_IOERR_BEGIN_ATOMIC,\n        SQLITE_IOERR_COMMIT_ATOMIC,\n        SQLITE_IOERR_ROLLBACK_ATOMIC,\n        SQLITE_ERROR_MISSING_COLLSEQ,\n        SQLITE_ERROR_RETRY,\n        SQLITE_READONLY_CANTINIT,\n        SQLITE_READONLY_DIRECTORY,\n        SQLITE_CORRUPT_SEQUENCE,\n        SQLITE_LOCKED_VTAB,\n        SQLITE_CANTOPEN_DIRTYWAL,\n        SQLITE_ERROR_SNAPSHOT,\n        SQLITE_CANTOPEN_SYMLINK,\n        SQLITE_CONSTRAINT_PINNED,\n        SQLITE_OK_SYMLINK,\n        SQLITE_BUSY_TIMEOUT,\n        SQLITE_CORRUPT_INDEX,\n        SQLITE_IOERR_DATA,\n        SQLITE_IOERR_CORRUPTFS\n    );\n\n    #[derive(FromArgs)]\n    struct ConnectArgs {\n        #[pyarg(any)]\n        database: FsPath,\n        #[pyarg(any, default = 5.0)]\n        timeout: f64,\n        #[pyarg(any, default = 0)]\n        detect_types: c_int,\n        #[pyarg(any, default = Some(vm.ctx.empty_str.to_owned()))]\n        isolation_level: Option<PyStrRef>,\n        #[pyarg(any, default = true)]\n        check_same_thread: bool,\n        #[pyarg(any, default = Connection::class(&vm.ctx).to_owned())]\n        factory: PyTypeRef,\n        // TODO: cache statements\n        #[allow(dead_code)]\n        #[pyarg(any, default = 0)]\n        cached_statements: c_int,\n        #[pyarg(any, default = false)]\n        uri: bool,\n    }\n\n    unsafe impl Traverse for ConnectArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.isolation_level.traverse(tracer_fn);\n            self.factory.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct BackupArgs {\n        #[pyarg(any)]\n        target: PyRef<Connection>,\n        #[pyarg(named, default = -1)]\n        pages: c_int,\n        #[pyarg(named, optional)]\n        progress: Option<ArgCallable>,\n        #[pyarg(named, optional)]\n        name: Option<PyStrRef>,\n        #[pyarg(named, default = 0.250)]\n        sleep: f64,\n    }\n\n    unsafe impl Traverse for BackupArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.progress.traverse(tracer_fn);\n            self.name.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct CreateFunctionArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(any)]\n        narg: c_int,\n        #[pyarg(any)]\n        func: PyObjectRef,\n        #[pyarg(named, default)]\n        deterministic: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct CreateAggregateArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(positional)]\n        narg: c_int,\n        #[pyarg(positional)]\n        aggregate_class: PyObjectRef,\n    }\n\n    #[derive(FromArgs)]\n    struct BlobOpenArgs {\n        #[pyarg(positional)]\n        table: PyStrRef,\n        #[pyarg(positional)]\n        column: PyStrRef,\n        #[pyarg(positional)]\n        row: i64,\n        #[pyarg(named, default)]\n        readonly: bool,\n        #[pyarg(named, default = vm.ctx.new_str(\"main\"))]\n        name: PyStrRef,\n    }\n\n    struct CallbackData {\n        obj: NonNull<PyObject>,\n        vm: *const VirtualMachine,\n    }\n\n    impl CallbackData {\n        fn new(obj: PyObjectRef, vm: &VirtualMachine) -> Option<Self> {\n            (!vm.is_none(&obj)).then_some(Self {\n                obj: obj.into_raw(),\n                vm,\n            })\n        }\n\n        fn retrieve(&self) -> (&PyObject, &VirtualMachine) {\n            unsafe { (self.obj.as_ref(), &*self.vm) }\n        }\n\n        unsafe extern \"C\" fn destructor(data: *mut c_void) {\n            drop(unsafe { Box::from_raw(data.cast::<Self>()) });\n        }\n\n        unsafe extern \"C\" fn func_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (func, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n\n                let val = func.call(args, vm)?;\n\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                context.result_exception(vm, exc, \"user-defined function raised exception\\0\")\n            }\n        }\n\n        unsafe extern \"C\" fn step_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (cls, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            if unsafe { (*instance).is_null() } {\n                match cls.call((), vm) {\n                    Ok(obj) => unsafe { *instance = obj.into_raw().as_ptr() },\n                    Err(exc) => {\n                        return context.result_exception(\n                            vm,\n                            exc,\n                            \"user-defined aggregate's '__init__' method raised error\\0\",\n                        );\n                    }\n                }\n            }\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"step\", args, vm);\n        }\n\n        unsafe extern \"C\" fn finalize_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let Some(instance) = (unsafe { (*instance).as_ref() }) else {\n                return;\n            };\n\n            Self::callback_result_from_method(context, instance, \"finalize\", vm);\n        }\n\n        unsafe extern \"C\" fn collation_callback(\n            data: *mut c_void,\n            a_len: c_int,\n            a_ptr: *const c_void,\n            b_len: c_int,\n            b_ptr: *const c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n\n            let f = || -> PyResult<c_int> {\n                let text1 = ptr_to_string(a_ptr.cast(), a_len, null_mut(), vm)?;\n                let text1 = vm.ctx.new_str(text1);\n                let text2 = ptr_to_string(b_ptr.cast(), b_len, null_mut(), vm)?;\n                let text2 = vm.ctx.new_str(text2);\n\n                let val = callable.call((text1, text2), vm)?;\n                let Some(val) = val.to_number().index(vm) else {\n                    return Ok(0);\n                };\n\n                let val = match val?.as_bigint().sign() {\n                    Sign::Plus => 1,\n                    Sign::Minus => -1,\n                    Sign::NoSign => 0,\n                };\n\n                Ok(val)\n            };\n\n            f().unwrap_or(0)\n        }\n\n        unsafe extern \"C\" fn value_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::callback_result_from_method(context, instance, \"value\", vm);\n        }\n\n        unsafe extern \"C\" fn inverse_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"inverse\", args, vm);\n        }\n\n        unsafe extern \"C\" fn authorizer_callback(\n            data: *mut c_void,\n            action: c_int,\n            arg1: *const libc::c_char,\n            arg2: *const libc::c_char,\n            db_name: *const libc::c_char,\n            access: *const libc::c_char,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let f = || -> PyResult<c_int> {\n                let arg1 = ptr_to_str(arg1, vm)?;\n                let arg2 = ptr_to_str(arg2, vm)?;\n                let db_name = ptr_to_str(db_name, vm)?;\n                let access = ptr_to_str(access, vm)?;\n\n                let val = callable.call((action, arg1, arg2, db_name, access), vm)?;\n                let Some(val) = val.downcast_ref::<PyInt>() else {\n                    return Ok(SQLITE_DENY);\n                };\n                val.try_to_primitive::<c_int>(vm)\n            };\n\n            f().unwrap_or(SQLITE_DENY)\n        }\n\n        unsafe extern \"C\" fn trace_callback(\n            _typ: c_uint,\n            data: *mut c_void,\n            stmt: *mut c_void,\n            sql: *mut c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let expanded = unsafe { sqlite3_expanded_sql(stmt.cast()) };\n            let f = || -> PyResult<()> {\n                let stmt = ptr_to_str(expanded, vm).or_else(|_| ptr_to_str(sql.cast(), vm))?;\n                callable.call((stmt,), vm)?;\n                Ok(())\n            };\n            let _ = f();\n            0\n        }\n\n        unsafe extern \"C\" fn progress_callback(data: *mut c_void) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            if let Ok(val) = callable.call((), vm)\n                && let Ok(val) = val.is_true(vm)\n            {\n                return val as c_int;\n            }\n            -1\n        }\n\n        fn callback_result_from_method(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let val = vm.call_method(instance, name, ())?;\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n\n        fn call_method_with_args(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            args: &[*mut sqlite3_value],\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n                vm.call_method(instance, name, args).map(drop)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n    }\n\n    impl Drop for CallbackData {\n        fn drop(&mut self) {\n            unsafe { PyObjectRef::from_raw(self.obj) };\n        }\n    }\n\n    #[pyfunction]\n    fn connect(args: ConnectArgs, vm: &VirtualMachine) -> PyResult {\n        Connection::py_new(args.factory.clone(), args, vm)\n    }\n\n    #[pyfunction]\n    fn complete_statement(statement: PyStrRef, vm: &VirtualMachine) -> PyResult<bool> {\n        let s = statement.to_cstring(vm)?;\n        let ret = unsafe { sqlite3_complete(s.as_ptr()) };\n        Ok(ret == 1)\n    }\n\n    #[pyfunction]\n    fn enable_callback_tracebacks(flag: bool) {\n        enable_traceback().store(flag, Ordering::Relaxed);\n    }\n\n    #[pyfunction]\n    fn register_adapter(typ: PyTypeRef, adapter: ArgCallable, vm: &VirtualMachine) -> PyResult<()> {\n        if typ.is(PyInt::class(&vm.ctx))\n            || typ.is(PyFloat::class(&vm.ctx))\n            || typ.is(PyStr::class(&vm.ctx))\n            || typ.is(PyByteArray::class(&vm.ctx))\n        {\n            let _ = BASE_TYPE_ADAPTED.set(());\n        }\n        let protocol = PrepareProtocol::class(&vm.ctx).to_owned();\n        let key = vm.ctx.new_tuple(vec![typ.into(), protocol.into()]);\n        adapters().set_item(key.as_object(), adapter.into(), vm)\n    }\n\n    #[pyfunction]\n    fn register_converter(\n        typename: PyStrRef,\n        converter: ArgCallable,\n        vm: &VirtualMachine,\n    ) -> PyResult<()> {\n        let name = typename.as_str().to_uppercase();\n        converters().set_item(&name, converter.into(), vm)\n    }\n\n    fn _adapt<F>(obj: &PyObject, proto: PyTypeRef, alt: F, vm: &VirtualMachine) -> PyResult\n    where\n        F: FnOnce(&PyObject) -> PyResult,\n    {\n        let proto = proto.into_object();\n        let key = vm\n            .ctx\n            .new_tuple(vec![obj.class().to_owned().into(), proto.clone()]);\n\n        if let Some(adapter) = adapters().get_item_opt(key.as_object(), vm)? {\n            return adapter.call((obj,), vm);\n        }\n        if let Ok(adapter) = proto.get_attr(\"__adapt__\", vm) {\n            match adapter.call((obj,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n        if let Ok(adapter) = obj.get_attr(\"__conform__\", vm) {\n            match adapter.call((proto,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n\n        alt(obj)\n    }\n\n    #[pyfunction]\n    fn adapt(\n        obj: PyObjectRef,\n        proto: OptionalArg<Option<PyTypeRef>>,\n        alt: OptionalArg<PyObjectRef>,\n        vm: &VirtualMachine,\n    ) -> PyResult {\n        if matches!(proto, OptionalArg::Present(None)) {\n            return if let OptionalArg::Present(alt) = alt {\n                Ok(alt)\n            } else {\n                Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n            };\n        }\n\n        let proto = proto\n            .flatten()\n            .unwrap_or_else(|| PrepareProtocol::class(&vm.ctx).to_owned());\n\n        _adapt(\n            &obj,\n            proto,\n            |_| {\n                if let OptionalArg::Present(alt) = alt {\n                    Ok(alt)\n                } else {\n                    Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n                }\n            },\n            vm,\n        )\n    }\n\n    fn need_adapt(obj: &PyObject, vm: &VirtualMachine) -> bool {\n        if BASE_TYPE_ADAPTED.get().is_some() {\n            true\n        } else {\n            let cls = obj.class();\n            !(cls.is(vm.ctx.types.int_type)\n                || cls.is(vm.ctx.types.float_type)\n                || cls.is(vm.ctx.types.str_type)\n                || cls.is(vm.ctx.types.bytearray_type))\n        }\n    }\n\n    static_cell! {\n        static CONVERTERS: PyDictRef;\n        static ADAPTERS: PyDictRef;\n        static BASE_TYPE_ADAPTED: ();\n        static USER_FUNCTION_EXCEPTION: PyAtomicRef<Option<PyBaseException>>;\n        static ENABLE_TRACEBACK: PyAtomic<bool>;\n    }\n\n    fn converters() -> &'static Py<PyDict> {\n        CONVERTERS.get().expect(\"converters not initialize\")\n    }\n\n    fn adapters() -> &'static Py<PyDict> {\n        ADAPTERS.get().expect(\"adapters not initialize\")\n    }\n\n    fn user_function_exception() -> &'static PyAtomicRef<Option<PyBaseException>> {\n        USER_FUNCTION_EXCEPTION\n            .get()\n            .expect(\"user function exception not initialize\")\n    }\n\n    fn enable_traceback() -> &'static PyAtomic<bool> {\n        ENABLE_TRACEBACK\n            .get()\n            .expect(\"enable traceback not initialize\")\n    }\n\n    pub(super) fn setup_module(module: &PyObject, vm: &VirtualMachine) {\n        for (name, code) in ERROR_CODES {\n            let name = vm.ctx.intern_str(*name);\n            let code = vm.new_pyobj(*code);\n            module.set_attr(name, code, vm).unwrap();\n        }\n\n        setup_module_exceptions(module, vm);\n\n        let _ = CONVERTERS.set(vm.ctx.new_dict());\n        let _ = ADAPTERS.set(vm.ctx.new_dict());\n        let _ = USER_FUNCTION_EXCEPTION.set(PyAtomicRef::from(None));\n        let _ = ENABLE_TRACEBACK.set(Radium::new(false));\n\n        module\n            .set_attr(\"converters\", converters().to_owned(), vm)\n            .unwrap();\n        module\n            .set_attr(\"adapters\", adapters().to_owned(), vm)\n            .unwrap();\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(PyPayload)]\n    struct Connection {\n        db: PyMutex<Option<Sqlite>>,\n        detect_types: PyAtomic<c_int>,\n        isolation_level: PyAtomicRef<Option<PyStr>>,\n        check_same_thread: PyAtomic<bool>,\n        thread_ident: PyMutex<ThreadId>,\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        text_factory: PyAtomicRef<PyObject>,\n    }\n\n    impl Debug for Connection {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"Sqlite3 Connection\")\n        }\n    }\n\n    impl Constructor for Connection {\n        type Args = ConnectArgs;\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n\n            // For non-subclassed Connection, initialize in __new__\n            // For subclassed Connection, leave db as None and require __init__ to be called\n            let is_base_class = cls.is(Connection::class(&vm.ctx).as_object());\n\n            let db = if is_base_class {\n                // Initialize immediately for base class\n                Some(Connection::initialize_db(&args, vm)?)\n            } else {\n                // For subclasses, require __init__ to be called\n                None\n            };\n\n            let conn = Self {\n                db: PyMutex::new(db),\n                detect_types: Radium::new(args.detect_types),\n                isolation_level: PyAtomicRef::from(args.isolation_level),\n                check_same_thread: Radium::new(args.check_same_thread),\n                thread_ident: PyMutex::new(std::thread::current().id()),\n                row_factory: PyAtomicRef::from(None),\n                text_factory: PyAtomicRef::from(text_factory),\n            };\n\n            Ok(conn.into_ref_with_type(vm, cls)?.into())\n        }\n    }\n\n    impl Callable for Connection {\n        type Args = FuncArgs;\n\n        fn call(zelf: &Py<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let _ = zelf.db_lock(vm)?;\n\n            let (sql,): (PyUtf8StrRef,) = args.bind(vm)?;\n\n            if let Some(stmt) = Statement::new(zelf, sql, vm)? {\n                Ok(stmt.into_ref(&vm.ctx).into())\n            } else {\n                Ok(vm.ctx.none())\n            }\n        }\n    }\n\n    impl Initializer for Connection {\n        type Args = ConnectArgs;\n\n        fn init(zelf: PyRef<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult<()> {\n            {\n                // Always drop the current database handle so __init__ can fully reconfigure it.\n                let mut guard = zelf.db.lock();\n                guard.take();\n            }\n\n            // Reset factories to their defaults, matching CPython's behavior.\n            let default_text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n            let _ = unsafe { zelf.row_factory.swap(None) };\n            let _ = unsafe { zelf.text_factory.swap(default_text_factory) };\n\n            // Attempt to open the new database before mutating other state so failures leave\n            // the connection uninitialized (and subsequent operations raise ProgrammingError).\n            let db = Self::initialize_db(&args, vm)?;\n\n            let ConnectArgs {\n                detect_types,\n                isolation_level,\n                check_same_thread,\n                ..\n            } = args;\n\n            zelf.detect_types.store(detect_types, Ordering::Relaxed);\n            zelf\n                .check_same_thread\n                .store(check_same_thread, Ordering::Relaxed);\n            *zelf.thread_ident.lock() = std::thread::current().id();\n            let _ = unsafe { zelf.isolation_level.swap(isolation_level) };\n\n            let mut guard = zelf.db.lock();\n            *guard = Some(db);\n            Ok(())\n        }\n    }\n\n    #[pyclass(with(Constructor, Callable, Initializer), flags(BASETYPE))]\n    impl Connection {\n        fn initialize_db(args: &ConnectArgs, vm: &VirtualMachine) -> PyResult<Sqlite> {\n            let path = args.database.to_cstring(vm)?;\n            let db = Sqlite::from(SqliteRaw::open(path.as_ptr(), args.uri, vm)?);\n            let timeout = (args.timeout * 1000.0) as c_int;\n            db.busy_timeout(timeout);\n            if let Some(isolation_level) = &args.isolation_level {\n                begin_statement_ptr_from_isolation_level(isolation_level, vm)?;\n            }\n            Ok(db)\n        }\n\n        fn db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            self.check_thread(vm)?;\n            self._db_lock(vm)\n        }\n\n        fn _db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            let guard = self.db.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Connection.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn cursor(\n            zelf: PyRef<Self>,\n            factory: OptionalArg<ArgCallable>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            zelf.db_lock(vm).map(drop)?;\n\n            let cursor = if let OptionalArg::Present(factory) = factory {\n                let cursor = factory.invoke((zelf.clone(),), vm)?;\n                let cursor = cursor.downcast::<Cursor>().map_err(|x| {\n                    vm.new_type_error(format!(\"factory must return a cursor, not {}\", x.class()))\n                })?;\n                let _ = unsafe { cursor.row_factory.swap(zelf.row_factory.to_owned()) };\n                cursor\n            } else {\n                let row_factory = zelf.row_factory.to_owned();\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx)\n            };\n            Ok(cursor)\n        }\n\n        #[pymethod]\n        fn blobopen(\n            zelf: PyRef<Self>,\n            args: BlobOpenArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Blob>> {\n            let table = args.table.to_cstring(vm)?;\n            let column = args.column.to_cstring(vm)?;\n            let name = args.name.to_cstring(vm)?;\n\n            let db = zelf.db_lock(vm)?;\n\n            let mut blob = null_mut();\n            let ret = unsafe {\n                sqlite3_blob_open(\n                    db.db,\n                    name.as_ptr(),\n                    table.as_ptr(),\n                    column.as_ptr(),\n                    args.row,\n                    (!args.readonly) as c_int,\n                    &mut blob,\n                )\n            };\n            db.check(ret, vm)?;\n            drop(db);\n\n            let blob = SqliteBlob { blob };\n            let blob = Blob {\n                connection: zelf,\n                inner: PyMutex::new(Some(BlobInner { blob, offset: 0 })),\n            };\n            Ok(blob.into_ref(&vm.ctx))\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.check_thread(vm)?;\n            self.db.lock().take();\n            Ok(())\n        }\n\n        #[pymethod]\n        fn commit(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.db_lock(vm)?.implicit_commit(vm)\n        }\n\n        #[pymethod]\n        fn rollback(&self, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            if !db.is_autocommit() {\n                db._exec(b\"ROLLBACK\\0\", vm)\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::execute(cursor, sql, parameters, vm)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::executemany(cursor, sql, seq_of_params, vm)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            Cursor::executescript(\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx),\n                script,\n                vm,\n            )\n        }\n\n        // TODO: Make it build without clippy::manual_c_str_literals\n        #[pymethod]\n        #[allow(clippy::manual_c_str_literals)]\n        fn backup(zelf: &Py<Self>, args: BackupArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let BackupArgs {\n                target,\n                pages,\n                progress,\n                name,\n                sleep,\n            } = args;\n            if zelf.is(&target) {\n                return Err(vm.new_value_error(\"target cannot be the same connection instance\"));\n            }\n\n            let pages = if pages == 0 { -1 } else { pages };\n\n            let name_cstring;\n            let name_ptr = if let Some(name) = &name {\n                name_cstring = name.to_cstring(vm)?;\n                name_cstring.as_ptr()\n            } else {\n                b\"main\\0\".as_ptr().cast()\n            };\n\n            let sleep_ms = (sleep * 1000.0) as c_int;\n\n            let db = zelf.db_lock(vm)?;\n            let target_db = target.db_lock(vm)?;\n\n            let handle = unsafe {\n                sqlite3_backup_init(target_db.db, b\"main\\0\".as_ptr().cast(), db.db, name_ptr)\n            };\n\n            if handle.is_null() {\n                return Err(target_db.error_extended(vm));\n            }\n\n            drop(db);\n            drop(target_db);\n\n            loop {\n                let ret = unsafe { sqlite3_backup_step(handle, pages) };\n\n                if let Some(progress) = &progress {\n                    let remaining = unsafe { sqlite3_backup_remaining(handle) };\n                    let pagecount = unsafe { sqlite3_backup_pagecount(handle) };\n                    if let Err(err) = progress.invoke((ret, remaining, pagecount), vm) {\n                        unsafe { sqlite3_backup_finish(handle) };\n                        return Err(err);\n                    }\n                }\n\n                if ret == SQLITE_BUSY || ret == SQLITE_LOCKED {\n                    unsafe { sqlite3_sleep(sleep_ms) };\n                } else if ret != SQLITE_OK {\n                    break;\n                }\n            }\n\n            let ret = unsafe { sqlite3_backup_finish(handle) };\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(target.db_lock(vm)?.error_extended(vm))\n            }\n        }\n\n        #[pymethod]\n        fn create_function(&self, args: CreateFunctionArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let flags = if args.deterministic {\n                SQLITE_UTF8 | SQLITE_DETERMINISTIC\n            } else {\n                SQLITE_UTF8\n            };\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.func, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    flags,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                flags,\n                Box::into_raw(Box::new(data)).cast(),\n                Some(CallbackData::func_callback),\n                None,\n                None,\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_aggregate(&self, args: CreateAggregateArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.aggregate_class, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    SQLITE_UTF8,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                SQLITE_UTF8,\n                Box::into_raw(Box::new(data)).cast(),\n                None,\n                Some(CallbackData::step_callback),\n                Some(CallbackData::finalize_callback),\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_collation(\n            &self,\n            name: PyUtf8StrRef,\n            callable: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable.clone(), vm) else {\n                unsafe {\n                    sqlite3_create_collation_v2(\n                        db.db,\n                        name.as_ptr(),\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                    );\n                }\n                return Ok(());\n            };\n            let data = Box::into_raw(Box::new(data));\n\n            if !callable.is_callable() {\n                return Err(vm.new_type_error(\"parameter must be callable\"));\n            }\n\n            let ret = unsafe {\n                sqlite3_create_collation_v2(\n                    db.db,\n                    name.as_ptr(),\n                    SQLITE_UTF8,\n                    data.cast(),\n                    Some(CallbackData::collation_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n\n            db.check(ret, vm).inspect_err(|_| {\n                // create_collation do not call destructor if error occur\n                let _ = unsafe { Box::from_raw(data) };\n            })\n        }\n\n        #[pymethod]\n        fn create_window_function(\n            &self,\n            name: PyStrRef,\n            narg: c_int,\n            aggregate_class: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(aggregate_class, vm) else {\n                unsafe {\n                    sqlite3_create_window_function(\n                        db.db,\n                        name.as_ptr(),\n                        narg,\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                        None,\n                        None,\n                        None,\n                    )\n                };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_create_window_function(\n                    db.db,\n                    name.as_ptr(),\n                    narg,\n                    SQLITE_UTF8,\n                    Box::into_raw(Box::new(data)).cast(),\n                    Some(CallbackData::step_callback),\n                    Some(CallbackData::finalize_callback),\n                    Some(CallbackData::value_callback),\n                    Some(CallbackData::inverse_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n            db.check(ret, vm)\n                .map_err(|_| new_programming_error(vm, \"Error creating window function\".to_owned()))\n        }\n\n        #[pymethod]\n        fn set_authorizer(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_set_authorizer(db.db, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_set_authorizer(\n                    db.db,\n                    Some(CallbackData::authorizer_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n            db.check(ret, vm).map_err(|_| {\n                new_operational_error(vm, \"Error setting authorizer callback\".to_owned())\n            })\n        }\n\n        #[pymethod]\n        fn set_trace_callback(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_trace_v2(db.db, SQLITE_TRACE_STMT as u32, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_trace_v2(\n                    db.db,\n                    SQLITE_TRACE_STMT as u32,\n                    Some(CallbackData::trace_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            db.check(ret, vm)\n        }\n\n        #[pymethod]\n        fn set_progress_handler(\n            &self,\n            callable: PyObjectRef,\n            n: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_progress_handler(db.db, n, None, null_mut()) };\n                return Ok(());\n            };\n\n            unsafe {\n                sqlite3_progress_handler(\n                    db.db,\n                    n,\n                    Some(CallbackData::progress_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            Ok(())\n        }\n\n        #[pymethod]\n        fn iterdump(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            let module = vm.import(\"sqlite3.dump\", 0)?;\n            let func = module.get_attr(\"_iterdump\", vm)?;\n            func.call((zelf,), vm)\n        }\n\n        #[pymethod]\n        fn interrupt(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // DO NOT check thread safety\n            self._db_lock(vm).map(|x| x.interrupt())\n        }\n\n        #[pymethod]\n        fn getlimit(&self, category: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, -1, vm)\n        }\n\n        #[pymethod]\n        fn setlimit(&self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, limit, vm)\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>) -> PyRef<Self> {\n            zelf\n        }\n\n        #[pymethod]\n        fn __exit__(\n            &self,\n            cls: PyObjectRef,\n            exc: PyObjectRef,\n            tb: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            if vm.is_none(&cls) && vm.is_none(&exc) && vm.is_none(&tb) {\n                self.commit(vm)\n            } else {\n                self.rollback(vm)\n            }\n        }\n\n        #[pygetset]\n        fn isolation_level(&self) -> Option<PyStrRef> {\n            self.isolation_level.deref().map(|x| x.to_owned())\n        }\n        #[pygetset(setter)]\n        fn set_isolation_level(\n            &self,\n            value: PySetterValue<Option<PyStrRef>>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            match value {\n                PySetterValue::Assign(value) => {\n                    if let Some(val_str) = &value {\n                        begin_statement_ptr_from_isolation_level(val_str, vm)?;\n                    }\n\n                    // If setting isolation_level to None (auto-commit mode), commit any pending transaction\n                    if value.is_none() {\n                        let db = self.db_lock(vm)?;\n                        if !db.is_autocommit() {\n                            // Keep the lock and call implicit_commit directly to avoid race conditions\n                            db.implicit_commit(vm)?;\n                        }\n                    }\n                    let _ = unsafe { self.isolation_level.swap(value) };\n                    Ok(())\n                }\n                PySetterValue::Delete => Err(vm.new_attribute_error(\n                    \"'isolation_level' attribute cannot be deleted\".to_owned(),\n                )),\n            }\n        }\n\n        #[pygetset]\n        fn text_factory(&self) -> PyObjectRef {\n            self.text_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_text_factory(&self, val: PyObjectRef) {\n            let _ = unsafe { self.text_factory.swap(val) };\n        }\n\n        #[pygetset]\n        fn row_factory(&self) -> Option<PyObjectRef> {\n            self.row_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_row_factory(&self, val: Option<PyObjectRef>) {\n            let _ = unsafe { self.row_factory.swap(val) };\n        }\n\n        fn check_thread(&self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.check_same_thread.load(Ordering::Relaxed) {\n                let creator_id = *self.thread_ident.lock();\n                if std::thread::current().id() != creator_id {\n                    return Err(new_programming_error(\n                        vm,\n                        \"SQLite objects created in a thread can only be used in that same thread.\"\n                            .to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n\n        #[pygetset]\n        fn in_transaction(&self, vm: &VirtualMachine) -> PyResult<bool> {\n            self._db_lock(vm).map(|x| !x.is_autocommit())\n        }\n\n        #[pygetset]\n        fn total_changes(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self._db_lock(vm).map(|x| x.total_changes())\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Cursor {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        arraysize: PyAtomic<c_int>,\n        #[pytraverse(skip)]\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        inner: PyMutex<Option<CursorInner>>,\n    }\n\n    #[derive(Debug, Traverse)]\n    struct CursorInner {\n        description: Option<PyTupleRef>,\n        row_cast_map: Vec<Option<PyObjectRef>>,\n        #[pytraverse(skip)]\n        lastrowid: i64,\n        #[pytraverse(skip)]\n        rowcount: i64,\n        statement: Option<PyRef<Statement>>,\n        #[pytraverse(skip)]\n        closed: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct FetchManyArgs {\n        #[pyarg(any, name = \"size\", optional)]\n        size: Option<c_int>,\n    }\n\n    #[pyclass(with(Constructor, IterNext, Iterable), flags(BASETYPE))]\n    impl Cursor {\n        fn new(\n            connection: PyRef<Connection>,\n            row_factory: Option<PyObjectRef>,\n            _vm: &VirtualMachine,\n        ) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(row_factory),\n                inner: PyMutex::from(Some(CursorInner {\n                    description: None,\n                    row_cast_map: vec![],\n                    lastrowid: -1,\n                    rowcount: -1,\n                    statement: None,\n                    closed: false,\n                })),\n            }\n        }\n\n        fn new_uninitialized(connection: PyRef<Connection>, _vm: &VirtualMachine) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(None),\n                inner: PyMutex::from(None),\n            }\n        }\n\n        #[pymethod]\n        fn __init__(&self, _connection: PyRef<Connection>, _vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = self.inner.lock();\n            if guard.is_some() {\n                // Already initialized (e.g., from a call to super().__init__)\n                return Ok(());\n            }\n            *guard = Some(CursorInner {\n                description: None,\n                row_cast_map: vec![],\n                lastrowid: -1,\n                rowcount: -1,\n                statement: None,\n                closed: false,\n            });\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, CursorInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                let inner_guard =\n                    PyMutexGuard::map(guard, |x| unsafe { x.as_mut().unwrap_unchecked() });\n                if inner_guard.closed {\n                    return Err(new_programming_error(\n                        vm,\n                        \"Cannot operate on a closed cursor.\".to_owned(),\n                    ));\n                }\n                Ok(inner_guard)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let st = stmt.lock();\n            let params_needed = st.bind_parameter_count();\n\n            if let OptionalArg::Present(parameters) = parameters {\n                st.bind_parameters(&parameters, vm)?;\n            } else if params_needed > 0 {\n                let msg = format!(\n                    \"Incorrect number of bindings supplied. The current statement uses {}, and 0 were supplied.\",\n                    params_needed\n                );\n                return Err(new_programming_error(vm, msg));\n            }\n\n            let ret = st.step();\n\n            if ret != SQLITE_DONE && ret != SQLITE_ROW {\n                if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                    return Err(exc);\n                }\n                return Err(db.error_extended(vm));\n            }\n\n            inner.row_cast_map = zelf.build_row_cast_map(&st, vm)?;\n\n            let detect_types = zelf.connection.detect_types.load(Ordering::Relaxed);\n            inner.description = st.columns_description(detect_types, vm)?;\n\n            if ret == SQLITE_ROW {\n                drop(st);\n                inner.statement = Some(stmt);\n            } else {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount += db.changes() as i64;\n                }\n            }\n\n            inner.lastrowid = db.lastrowid();\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            let st = stmt.lock();\n\n            if st.readonly() {\n                return Err(new_programming_error(\n                    vm,\n                    \"executemany() can only execute DML statements.\".to_owned(),\n                ));\n            }\n\n            let detect_types = zelf.connection.detect_types.load(Ordering::Relaxed);\n            inner.description = st.columns_description(detect_types, vm)?;\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let iter = seq_of_params.iter(vm)?;\n            for params in iter {\n                let params = params?;\n                st.bind_parameters(&params, vm)?;\n\n                if !st.step_row_else_done(vm)? {\n                    if stmt.is_dml {\n                        inner.rowcount += db.changes() as i64;\n                    }\n                    st.reset();\n                }\n\n                // if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                //     return Err(exc);\n                // }\n            }\n\n            if st.busy() {\n                drop(st);\n                inner.statement = Some(stmt);\n            }\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let db = zelf.connection.db_lock(vm)?;\n\n            db.sql_limit(script.byte_len(), vm)?;\n\n            db.implicit_commit(vm)?;\n\n            let script = script.to_cstring(vm)?;\n            let mut ptr = script.as_ptr();\n\n            while let Some(st) = db.prepare(ptr, &mut ptr, vm)? {\n                while st.step_row_else_done(vm)? {}\n            }\n\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn fetchone(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult {\n            Self::next(zelf, vm).map(|x| match x {\n                PyIterReturn::Return(row) => row,\n                PyIterReturn::StopIteration(_) => vm.ctx.none(),\n            })\n        }\n\n        #[pymethod]\n        fn fetchmany(\n            zelf: &Py<Self>,\n            args: FetchManyArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<PyObjectRef>> {\n            let max_rows = args\n                .size\n                .unwrap_or_else(|| zelf.arraysize.load(Ordering::Relaxed));\n\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Cursor::next(zelf, vm)? {\n                list.push(row);\n                if max_rows > 0 && list.len() as c_int >= max_rows {\n                    break;\n                }\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn fetchall(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Self::next(zelf, vm)? {\n                list.push(row);\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // Check if __init__ was called\n            let mut guard = self.inner.lock();\n            if guard.is_none() {\n                return Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ));\n            }\n\n            if let Some(inner) = guard.as_mut() {\n                if let Some(stmt) = &inner.statement {\n                    stmt.lock().reset();\n                }\n                inner.closed = true;\n            }\n            Ok(())\n        }\n\n        #[pymethod]\n        fn setinputsizes(&self, _sizes: PyObjectRef) {}\n        #[pymethod]\n        fn setoutputsize(&self, _size: PyObjectRef, _column: OptionalArg<PyObjectRef>) {}\n\n        #[pygetset]\n        fn connection(&self) -> PyRef<Connection> {\n            self.connection.clone()\n        }\n\n        #[pygetset]\n        fn lastrowid(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.lastrowid)\n        }\n\n        #[pygetset]\n        fn rowcount(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.rowcount)\n        }\n\n        #[pygetset]\n        fn description(&self, vm: &VirtualMachine) -> PyResult<Option<PyTupleRef>> {\n            self.inner(vm).map(|x| x.description.clone())\n        }\n\n        #[pygetset]\n        fn arraysize(&self) -> c_int {\n            self.arraysize.load(Ordering::Relaxed)\n        }\n        #[pygetset(setter)]\n        fn set_arraysize(&self, val: c_int) {\n            self.arraysize.store(val, Ordering::Relaxed);\n        }\n\n        fn build_row_cast_map(\n            &self,\n            st: &SqliteStatementRaw,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<Option<PyObjectRef>>> {\n            let detect_types = self.connection.detect_types.load(Ordering::Relaxed);\n            if detect_types == 0 {\n                return Ok(vec![]);\n            }\n\n            let mut cast_map = vec![];\n            let num_cols = st.column_count();\n\n            for i in 0..num_cols {\n                if detect_types & PARSE_COLNAMES != 0 {\n                    let col_name = st.column_name(i);\n                    let col_name = ptr_to_str(col_name, vm)?;\n                    let col_name = col_name\n                        .chars()\n                        .skip_while(|&x| x != '[')\n                        .skip(1)\n                        .take_while(|&x| x != ']')\n                        .flat_map(|x| x.to_uppercase())\n                        .collect::<String>();\n                    if let Some(converter) = converters().get_item_opt(&col_name, vm)? {\n                        cast_map.push(Some(converter.clone()));\n                        continue;\n                    }\n                }\n                if detect_types & PARSE_DECLTYPES != 0 {\n                    let decltype = st.column_decltype(i);\n                    let decltype = ptr_to_str(decltype, vm)?;\n                    if let Some(decltype) = decltype.split_terminator(&[' ', '(']).next() {\n                        let decltype = decltype.to_uppercase();\n                        if let Some(converter) = converters().get_item_opt(&decltype, vm)? {\n                            cast_map.push(Some(converter.clone()));\n                            continue;\n                        }\n                    }\n                }\n                cast_map.push(None);\n            }\n\n            Ok(cast_map)\n        }\n    }\n\n    impl Constructor for Cursor {\n        type Args = (PyRef<Connection>,);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            Self::new_uninitialized(args.0, vm)\n                .into_ref_with_type(vm, cls)\n                .map(Into::into)\n        }\n    }\n\n    impl SelfIter for Cursor {}\n    impl IterNext for Cursor {\n        fn next(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyIterReturn> {\n            let mut inner = zelf.inner(vm)?;\n            let Some(stmt) = &inner.statement else {\n                return Ok(PyIterReturn::StopIteration(None));\n            };\n            let st = stmt.lock();\n            let db = zelf.connection.db_lock(vm)?;\n            // fetch_one_row\n\n            let num_cols = st.data_count();\n\n            let mut row = Vec::with_capacity(num_cols as usize);\n\n            for i in 0..num_cols {\n                let val = if let Some(converter) =\n                    inner.row_cast_map.get(i as usize).cloned().flatten()\n                {\n                    let blob = st.column_blob(i);\n                    if blob.is_null() {\n                        vm.ctx.none()\n                    } else {\n                        let nbytes = st.column_bytes(i);\n                        let blob = unsafe {\n                            std::slice::from_raw_parts(blob.cast::<u8>(), nbytes as usize)\n                        };\n                        let blob = vm.ctx.new_bytes(blob.to_vec());\n                        converter.call((blob,), vm)?\n                    }\n                } else {\n                    let col_type = st.column_type(i);\n                    match col_type {\n                        SQLITE_NULL => vm.ctx.none(),\n                        SQLITE_INTEGER => vm.ctx.new_int(st.column_int(i)).into(),\n                        SQLITE_FLOAT => vm.ctx.new_float(st.column_double(i)).into(),\n                        SQLITE_TEXT => {\n                            let text =\n                                ptr_to_vec(st.column_text(i), st.column_bytes(i), db.db, vm)?;\n\n                            let text_factory = zelf.connection.text_factory.to_owned();\n\n                            if text_factory.is(PyStr::class(&vm.ctx)) {\n                                let text = String::from_utf8(text).map_err(|err| {\n                                    let col_name = st.column_name(i);\n                                    let col_name_str = ptr_to_str(col_name, vm).unwrap_or(\"?\");\n                                    let valid_up_to = err.utf8_error().valid_up_to();\n                                    let text_prefix = String::from_utf8_lossy(&err.as_bytes()[..valid_up_to]);\n                                    let msg = format!(\n                                        \"Could not decode to UTF-8 column '{col_name_str}' with text '{text_prefix}'\"\n                                    );\n                                    new_operational_error(vm, msg)\n                                })?;\n                                vm.ctx.new_str(text).into()\n                            } else if text_factory.is(PyBytes::class(&vm.ctx)) {\n                                vm.ctx.new_bytes(text).into()\n                            } else if text_factory.is(PyByteArray::class(&vm.ctx)) {\n                                PyByteArray::from(text).into_ref(&vm.ctx).into()\n                            } else {\n                                let bytes = vm.ctx.new_bytes(text);\n                                text_factory.call((bytes,), vm)?\n                            }\n                        }\n                        SQLITE_BLOB => {\n                            let blob = ptr_to_vec(\n                                st.column_blob(i).cast(),\n                                st.column_bytes(i),\n                                db.db,\n                                vm,\n                            )?;\n\n                            vm.ctx.new_bytes(blob).into()\n                        }\n                        _ => {\n                            return Err(vm.new_not_implemented_error(format!(\n                                \"unknown column type: {col_type}\"\n                            )));\n                        }\n                    }\n                };\n\n                row.push(val);\n            }\n\n            if !st.step_row_else_done(vm)? {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount = db.changes() as i64;\n                }\n                inner.statement = None;\n            } else {\n                drop(st);\n            }\n\n            drop(db);\n            drop(inner);\n\n            let row = vm.ctx.new_tuple(row);\n\n            if let Some(row_factory) = zelf.row_factory.to_owned() {\n                row_factory\n                    .call((zelf.to_owned(), row), vm)\n                    .map(PyIterReturn::Return)\n            } else {\n                Ok(PyIterReturn::Return(row.into()))\n            }\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Row {\n        data: PyTupleRef,\n        description: PyTupleRef,\n    }\n\n    #[pyclass(\n        with(Constructor, Hashable, Comparable, Iterable, AsMapping, AsSequence),\n        flags(BASETYPE)\n    )]\n    impl Row {\n        #[pymethod]\n        fn keys(&self, _vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            Ok(self\n                .description\n                .iter()\n                .map(|x| x.downcast_ref::<PyTuple>().unwrap().as_slice()[0].clone())\n                .collect())\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            if let Some(i) = needle.downcast_ref::<PyInt>() {\n                let i = i.try_to_primitive::<isize>(vm)?;\n                self.data.getitem_by_index(vm, i)\n            } else if let Some(name) = needle.downcast_ref::<PyStr>() {\n                for (obj, i) in self.description.iter().zip(0..) {\n                    let obj = &obj.downcast_ref::<PyTuple>().unwrap().as_slice()[0];\n                    let Some(obj) = obj.downcast_ref::<PyStr>() else {\n                        break;\n                    };\n                    let a_iter = name.as_str().chars().flat_map(|x| x.to_uppercase());\n                    let b_iter = obj.as_str().chars().flat_map(|x| x.to_uppercase());\n\n                    if a_iter.eq(b_iter) {\n                        return self.data.getitem_by_index(vm, i);\n                    }\n                }\n                Err(vm.new_index_error(\"No item with that key\"))\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let list = self.data.getitem_by_slice(vm, slice.to_saturated(vm)?)?;\n                Ok(vm.ctx.new_tuple(list).into())\n            } else {\n                Err(vm.new_index_error(\"Index must be int or string\"))\n            }\n        }\n    }\n\n    impl Constructor for Row {\n        type Args = (PyRef<Cursor>, PyTupleRef);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let description = args\n                .0\n                .inner(vm)?\n                .description\n                .clone()\n                .ok_or_else(|| vm.new_value_error(\"no description in Cursor\"))?;\n\n            Self {\n                data: args.1,\n                description,\n            }\n            .into_ref_with_type(vm, cls)\n            .map(Into::into)\n        }\n    }\n\n    impl Hashable for Row {\n        fn hash(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyHash> {\n            Ok(zelf.description.as_object().hash(vm)? | zelf.data.as_object().hash(vm)?)\n        }\n    }\n\n    impl Comparable for Row {\n        fn cmp(\n            zelf: &Py<Self>,\n            other: &PyObject,\n            op: PyComparisonOp,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyComparisonValue> {\n            op.eq_only(|| {\n                if let Some(other) = other.downcast_ref::<Self>() {\n                    let eq = vm\n                        .bool_eq(zelf.description.as_object(), other.description.as_object())?\n                        && vm.bool_eq(zelf.data.as_object(), other.data.as_object())?;\n                    Ok(eq.into())\n                } else {\n                    Ok(PyComparisonValue::NotImplemented)\n                }\n            })\n        }\n    }\n\n    impl Iterable for Row {\n        fn iter(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            Iterable::iter(zelf.data.clone(), vm)\n        }\n    }\n\n    impl AsMapping for Row {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: std::sync::LazyLock<PyMappingMethods> =\n                std::sync::LazyLock::new(|| PyMappingMethods {\n                    length: atomic_func!(|mapping, _vm| Ok(Row::mapping_downcast(mapping)\n                        .data\n                        .len())),\n                    subscript: atomic_func!(|mapping, needle, vm| {\n                        Row::mapping_downcast(mapping).subscript(needle, vm)\n                    }),\n                    ..PyMappingMethods::NOT_IMPLEMENTED\n                });\n            &AS_MAPPING\n        }\n    }\n\n    impl AsSequence for Row {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: std::sync::LazyLock<PySequenceMethods> =\n                std::sync::LazyLock::new(|| PySequenceMethods {\n                    length: atomic_func!(|seq, _vm| Ok(Row::sequence_downcast(seq).data.len())),\n                    item: atomic_func!(|seq, i, vm| Row::sequence_downcast(seq)\n                        .data\n                        .getitem_by_index(vm, i)),\n                    ..PySequenceMethods::NOT_IMPLEMENTED\n                });\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Blob\", traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Blob {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        inner: PyMutex<Option<BlobInner>>,\n    }\n\n    impl Unconstructible for Blob {}\n\n    #[derive(Debug)]\n    struct BlobInner {\n        blob: SqliteBlob,\n        offset: c_int,\n    }\n\n    impl Drop for BlobInner {\n        fn drop(&mut self) {\n            unsafe { sqlite3_blob_close(self.blob.blob) };\n        }\n    }\n\n    #[pyclass(with(AsMapping, Unconstructible, AsNumber, AsSequence))]\n    impl Blob {\n        #[pymethod]\n        fn close(&self) {\n            self.inner.lock().take();\n        }\n\n        #[pymethod]\n        fn read(\n            &self,\n            length: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<PyBytes>> {\n            let mut length = length.unwrap_or(-1);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let max_read = blob_len - inner.offset;\n\n            if length < 0 || length > max_read {\n                length = max_read;\n            }\n\n            if length == 0 {\n                Ok(vm.ctx.empty_bytes.clone())\n            } else {\n                let mut buf = Vec::<u8>::with_capacity(length as usize);\n                let ret = inner\n                    .blob\n                    .read(buf.as_mut_ptr().cast(), length, inner.offset);\n                self.check(ret, vm)?;\n                unsafe { buf.set_len(length as usize) };\n                inner.offset += length;\n                Ok(vm.ctx.new_bytes(buf))\n            }\n        }\n\n        #[pymethod]\n        fn write(&self, data: PyBuffer, vm: &VirtualMachine) -> PyResult<()> {\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let length = Self::expect_write(blob_len, data.desc.len, inner.offset, vm)?;\n\n            let ret = data.contiguous_or_collect(|buf| {\n                inner.blob.write(buf.as_ptr().cast(), length, inner.offset)\n            });\n\n            self.check(ret, vm)?;\n            inner.offset += length;\n            Ok(())\n        }\n\n        #[pymethod]\n        fn tell(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.inner(vm).map(|x| x.offset)\n        }\n\n        #[pymethod]\n        fn seek(\n            &self,\n            mut offset: c_int,\n            origin: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let origin = origin.unwrap_or(libc::SEEK_SET);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n\n            let overflow_err = || vm.new_overflow_error(\"seek offset results in overflow\");\n\n            match origin {\n                libc::SEEK_SET => {}\n                libc::SEEK_CUR => {\n                    offset = offset.checked_add(inner.offset).ok_or_else(overflow_err)?\n                }\n                libc::SEEK_END => offset = offset.checked_add(blob_len).ok_or_else(overflow_err)?,\n                _ => {\n                    return Err(vm.new_value_error(\n                        \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\",\n                    ));\n                }\n            }\n\n            if offset < 0 || offset > blob_len {\n                Err(vm.new_value_error(\"offset out of blob range\"))\n            } else {\n                inner.offset = offset;\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult<PyRef<Self>> {\n            let _ = zelf.inner(vm)?;\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn __exit__(&self, _args: FuncArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let _ = self.inner(vm)?;\n            self.close();\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, BlobInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Cannot operate on a closed blob.\".to_owned(),\n                ))\n            }\n        }\n\n        fn wrapped_index(index: PyIntRef, length: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let mut index = index.try_to_primitive::<c_int>(vm)?;\n            if index < 0 {\n                index += length;\n            }\n            if index < 0 || index >= length {\n                Err(vm.new_index_error(\"Blob index out of range\"))\n            } else {\n                Ok(index)\n            }\n        }\n\n        fn expect_write(\n            blob_len: c_int,\n            length: usize,\n            offset: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<c_int> {\n            let max_write = blob_len - offset;\n            if length <= max_write as usize {\n                Ok(length as c_int)\n            } else {\n                Err(vm.new_value_error(\"data longer than blob length\"))\n            }\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            let inner = self.inner(vm)?;\n            if let Some(index) = needle.try_index_opt(vm) {\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                let mut byte: u8 = 0;\n                let ret = inner.blob.read_single(&mut byte, index);\n                self.check(ret, vm).map(|_| vm.ctx.new_int(byte).into())\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, length) = slice.adjust_indices(blob_len as usize);\n                let mut buf = Vec::<u8>::with_capacity(length);\n\n                if step == 1 {\n                    let ret = inner.blob.read(\n                        buf.as_mut_ptr().cast(),\n                        length as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n                    unsafe { buf.set_len(length) };\n                } else {\n                    let iter = SaturatedSliceIter::from_adjust_indices(range, step, length);\n                    let mut byte: u8 = 0;\n                    for index in iter {\n                        let ret = inner.blob.read_single(&mut byte, index as c_int);\n                        self.check(ret, vm)?;\n                        buf.push(byte);\n                    }\n                }\n                Ok(vm.ctx.new_bytes(buf).into())\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn ass_subscript(\n            &self,\n            needle: &PyObject,\n            value: Option<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(value) = value else {\n                return Err(vm.new_type_error(\"Blob doesn't support slice deletion\"));\n            };\n            let inner = self.inner(vm)?;\n\n            if let Some(index) = needle.try_index_opt(vm) {\n                // Handle single item assignment: blob[i] = b\n                let Some(value) = value.downcast_ref::<PyInt>() else {\n                    return Err(vm.new_type_error(format!(\n                        \"'{}' object cannot be interpreted as an integer\",\n                        value.class()\n                    )));\n                };\n                let value = value.try_to_primitive::<u8>(vm)?;\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                Self::expect_write(blob_len, 1, index, vm)?;\n                let ret = inner.blob.write_single(value, index);\n                self.check(ret, vm)\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                // Handle slice assignment: blob[a:b:c] = b\"...\"\n                let value_buf = PyBuffer::try_from_borrowed_object(vm, &value)?;\n\n                let buf = value_buf\n                    .as_contiguous()\n                    .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, slice_len) = slice.adjust_indices(blob_len as usize);\n\n                if step == 0 {\n                    return Err(vm.new_value_error(\"slice step cannot be zero\"));\n                }\n\n                if buf.len() != slice_len {\n                    return Err(vm.new_index_error(\"Blob slice assignment is wrong size\"));\n                }\n\n                if slice_len == 0 {\n                    return Ok(());\n                }\n\n                if step == 1 {\n                    let ret = inner.blob.write(\n                        buf.as_ptr().cast(),\n                        buf.len() as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                } else {\n                    let span_len = range.end - range.start;\n                    let mut temp_buf = vec![0u8; span_len];\n\n                    let ret = inner.blob.read(\n                        temp_buf.as_mut_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n\n                    let mut i_in_temp: usize = 0;\n                    for i_in_src in 0..slice_len {\n                        temp_buf[i_in_temp] = buf[i_in_src];\n                        i_in_temp += step as usize;\n                    }\n\n                    let ret = inner.blob.write(\n                        temp_buf.as_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                }\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn check(&self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.connection.db_lock(vm)?.error_extended(vm))\n            }\n        }\n    }\n\n    impl AsMapping for Blob {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: PyMappingMethods = PyMappingMethods {\n                length: atomic_func!(|mapping, vm| Blob::mapping_downcast(mapping)\n                    .inner(vm)\n                    .map(|x| x.blob.bytes() as usize)),\n                subscript: atomic_func!(|mapping, needle, vm| {\n                    Blob::mapping_downcast(mapping).subscript(needle, vm)\n                }),\n                ass_subscript: atomic_func!(|mapping, needle, value, vm| {\n                    Blob::mapping_downcast(mapping).ass_subscript(needle, value, vm)\n                }),\n            };\n            &AS_MAPPING\n        }\n    }\n\n    impl AsNumber for Blob {\n        fn as_number() -> &'static PyNumberMethods {\n            static AS_NUMBER: PyNumberMethods = PyNumberMethods {\n                add: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for +: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                multiply: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for *: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                ..PyNumberMethods::NOT_IMPLEMENTED\n            };\n            &AS_NUMBER\n        }\n    }\n\n    impl AsSequence for Blob {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: PySequenceMethods = PySequenceMethods {\n                length: AtomicCell::new(None),\n                concat: AtomicCell::new(None),\n                repeat: AtomicCell::new(None),\n                item: AtomicCell::new(None),\n                ass_item: AtomicCell::new(None),\n                contains: atomic_func!(|seq, _needle, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"argument of type '{}' is not iterable\",\n                        seq.obj.class().name(),\n                    )))\n                }),\n                inplace_concat: AtomicCell::new(None),\n                inplace_repeat: AtomicCell::new(None),\n            };\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(Debug, PyPayload)]\n    struct PrepareProtocol {}\n\n    #[pyclass()]\n    impl PrepareProtocol {}\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Statement\")]\n    #[derive(PyPayload)]\n    struct Statement {\n        st: PyMutex<SqliteStatement>,\n        pub is_dml: bool,\n    }\n\n    impl Debug for Statement {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(\n                f,\n                \"{} Statement\",\n                if self.is_dml { \"DML\" } else { \"Non-DML\" }\n            )\n        }\n    }\n\n    impl Unconstructible for Statement {}\n\n    #[pyclass(with(Unconstructible))]\n    impl Statement {\n        fn new(\n            connection: &Connection,\n            sql: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<Self>> {\n            if sql.as_str().contains('\\0') {\n                return Err(new_programming_error(\n                    vm,\n                    \"statement contains a null character.\".to_owned(),\n                ));\n            }\n            let sql_cstr = sql.to_cstring(vm)?;\n\n            let db = connection.db_lock(vm)?;\n\n            db.sql_limit(sql.byte_len(), vm)?;\n\n            let mut tail = null();\n            let st = db.prepare(sql_cstr.as_ptr(), &mut tail, vm)?;\n\n            let Some(st) = st else {\n                return Ok(None);\n            };\n\n            let tail = unsafe { CStr::from_ptr(tail) };\n            let tail = tail.to_bytes();\n            if lstrip_sql(tail).is_some() {\n                return Err(new_programming_error(\n                    vm,\n                    \"You can only execute one statement at a time.\".to_owned(),\n                ));\n            }\n\n            let is_dml = if let Some(head) = lstrip_sql(sql_cstr.as_bytes()) {\n                head.len() >= 6\n                    && (head[..6].eq_ignore_ascii_case(b\"insert\")\n                        || head[..6].eq_ignore_ascii_case(b\"update\")\n                        || head[..6].eq_ignore_ascii_case(b\"delete\")\n                        || (head.len() >= 7 && head[..7].eq_ignore_ascii_case(b\"replace\")))\n            } else {\n                false\n            };\n\n            Ok(Some(Self {\n                st: PyMutex::from(st),\n                is_dml,\n            }))\n        }\n\n        fn lock(&self) -> PyMutexGuard<'_, SqliteStatement> {\n            self.st.lock()\n        }\n    }\n\n    struct Sqlite {\n        raw: SqliteRaw,\n    }\n\n    impl From<SqliteRaw> for Sqlite {\n        fn from(raw: SqliteRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for Sqlite {\n        fn drop(&mut self) {\n            unsafe { sqlite3_close_v2(self.raw.db) };\n        }\n    }\n\n    impl Deref for Sqlite {\n        type Target = SqliteRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteRaw {\n        db: *mut sqlite3,\n    }\n\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"threading\")] {\n            unsafe impl Send for SqliteStatement {}\n            // unsafe impl Sync for SqliteStatement {}\n            unsafe impl Send for Sqlite {}\n            // unsafe impl Sync for Sqlite {}\n            unsafe impl Send for SqliteBlob {}\n        }\n    }\n\n    impl From<SqliteStatementRaw> for SqliteRaw {\n        fn from(stmt: SqliteStatementRaw) -> Self {\n            unsafe {\n                Self {\n                    db: sqlite3_db_handle(stmt.st),\n                }\n            }\n        }\n    }\n\n    impl SqliteRaw {\n        fn check(self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.error_extended(vm))\n            }\n        }\n\n        fn error_extended(self, vm: &VirtualMachine) -> PyBaseExceptionRef {\n            let errcode = unsafe { sqlite3_errcode(self.db) };\n            let typ = exception_type_from_errcode(errcode, vm);\n            let extended_errcode = unsafe { sqlite3_extended_errcode(self.db) };\n            let errmsg = unsafe { sqlite3_errmsg(self.db) };\n            let errmsg = unsafe { CStr::from_ptr(errmsg) };\n            let errmsg = errmsg.to_str().unwrap().to_owned();\n\n            raise_exception(typ.to_owned(), extended_errcode, errmsg, vm)\n        }\n\n        fn open(path: *const libc::c_char, uri: bool, vm: &VirtualMachine) -> PyResult<Self> {\n            let mut db = null_mut();\n            let ret = unsafe {\n                sqlite3_open_v2(\n                    path,\n                    &raw mut db,\n                    SQLITE_OPEN_READWRITE\n                        | SQLITE_OPEN_CREATE\n                        | if uri { SQLITE_OPEN_URI } else { 0 },\n                    null(),\n                )\n            };\n            let zelf = Self { db };\n            zelf.check(ret, vm).map(|_| zelf)\n        }\n\n        fn _exec(self, sql: &[u8], vm: &VirtualMachine) -> PyResult<()> {\n            let ret =\n                unsafe { sqlite3_exec(self.db, sql.as_ptr().cast(), None, null_mut(), null_mut()) };\n            self.check(ret, vm)\n        }\n\n        fn prepare(\n            self,\n            sql: *const libc::c_char,\n            tail: *mut *const libc::c_char,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<SqliteStatement>> {\n            let mut st = null_mut();\n            let ret = unsafe { sqlite3_prepare_v2(self.db, sql, -1, &mut st, tail) };\n            self.check(ret, vm)?;\n            if st.is_null() {\n                Ok(None)\n            } else {\n                Ok(Some(SqliteStatement::from(SqliteStatementRaw::from(st))))\n            }\n        }\n\n        fn limit(self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let old_limit = unsafe { sqlite3_limit(self.db, category, limit) };\n            if old_limit >= 0 {\n                Ok(old_limit)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"'category' is out of bounds\".to_owned(),\n                ))\n            }\n        }\n\n        fn sql_limit(self, len: usize, vm: &VirtualMachine) -> PyResult<()> {\n            if len <= unsafe { sqlite3_limit(self.db, SQLITE_LIMIT_SQL_LENGTH, -1) } as usize {\n                Ok(())\n            } else {\n                Err(new_data_error(vm, \"query string is too large\".to_owned()))\n            }\n        }\n\n        fn is_autocommit(self) -> bool {\n            unsafe { sqlite3_get_autocommit(self.db) != 0 }\n        }\n\n        fn changes(self) -> c_int {\n            unsafe { sqlite3_changes(self.db) }\n        }\n\n        fn total_changes(self) -> c_int {\n            unsafe { sqlite3_total_changes(self.db) }\n        }\n\n        fn lastrowid(self) -> c_longlong {\n            unsafe { sqlite3_last_insert_rowid(self.db) }\n        }\n\n        fn implicit_commit(self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.is_autocommit() {\n                Ok(())\n            } else {\n                self._exec(b\"COMMIT\\0\", vm)\n            }\n        }\n\n        fn begin_transaction(\n            self,\n            isolation_level: Option<PyStrRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(isolation_level) = isolation_level else {\n                return Ok(());\n            };\n            let mut s = Vec::with_capacity(16);\n            s.extend(b\"BEGIN \");\n            s.extend(isolation_level.as_str().bytes());\n            s.push(b'\\0');\n            self._exec(&s, vm)\n        }\n\n        fn interrupt(self) {\n            unsafe { sqlite3_interrupt(self.db) }\n        }\n\n        fn busy_timeout(self, timeout: i32) {\n            unsafe { sqlite3_busy_timeout(self.db, timeout) };\n        }\n\n        #[allow(clippy::too_many_arguments)]\n        fn create_function(\n            self,\n            name: *const libc::c_char,\n            narg: c_int,\n            flags: c_int,\n            data: *mut c_void,\n            func: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            step: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            finalize: Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n            destroy: Option<unsafe extern \"C\" fn(arg1: *mut c_void)>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let ret = unsafe {\n                sqlite3_create_function_v2(\n                    self.db, name, narg, flags, data, func, step, finalize, destroy,\n                )\n            };\n            self.check(ret, vm)\n                .map_err(|_| new_operational_error(vm, \"Error creating function\".to_owned()))\n        }\n    }\n\n    struct SqliteStatement {\n        raw: SqliteStatementRaw,\n    }\n\n    impl From<SqliteStatementRaw> for SqliteStatement {\n        fn from(raw: SqliteStatementRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for SqliteStatement {\n        fn drop(&mut self) {\n            unsafe {\n                sqlite3_finalize(self.raw.st);\n            }\n        }\n    }\n\n    impl Deref for SqliteStatement {\n        type Target = SqliteStatementRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteStatementRaw {\n        st: *mut sqlite3_stmt,\n    }\n\n    impl From<*mut sqlite3_stmt> for SqliteStatementRaw {\n        fn from(st: *mut sqlite3_stmt) -> Self {\n            SqliteStatementRaw { st }\n        }\n    }\n\n    impl SqliteStatementRaw {\n        fn step(self) -> c_int {\n            unsafe { sqlite3_step(self.st) }\n        }\n\n        fn step_row_else_done(self, vm: &VirtualMachine) -> PyResult<bool> {\n            let ret = self.step();\n\n            if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                Err(exc)\n            } else if ret == SQLITE_ROW {\n                Ok(true)\n            } else if ret == SQLITE_DONE {\n                Ok(false)\n            } else {\n                Err(SqliteRaw::from(self).error_extended(vm))\n            }\n        }\n\n        fn reset(self) {\n            unsafe { sqlite3_reset(self.st) };\n        }\n\n        fn data_count(self) -> c_int {\n            unsafe { sqlite3_data_count(self.st) }\n        }\n\n        fn bind_parameter(\n            self,\n            pos: c_int,\n            parameter: &PyObject,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let adapted;\n            let obj = if need_adapt(parameter, vm) {\n                adapted = _adapt(\n                    parameter,\n                    PrepareProtocol::class(&vm.ctx).to_owned(),\n                    |x| Ok(x.to_owned()),\n                    vm,\n                )?;\n                &adapted\n            } else {\n                parameter\n            };\n\n            let ret = if vm.is_none(obj) {\n                unsafe { sqlite3_bind_null(self.st, pos) }\n            } else if let Some(val) = obj.downcast_ref::<PyInt>() {\n                let val = val.try_to_primitive::<i64>(vm).map_err(|_| {\n                    vm.new_overflow_error(\"Python int too large to convert to SQLite INTEGER\")\n                })?;\n                unsafe { sqlite3_bind_int64(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyFloat>() {\n                let val = val.to_f64();\n                unsafe { sqlite3_bind_double(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyStr>() {\n                let val = val.try_as_utf8(vm)?;\n                let (ptr, len) = str_to_ptr_len(val, vm)?;\n                unsafe { sqlite3_bind_text(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, obj) {\n                let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                unsafe { sqlite3_bind_blob(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Error binding parameter {}: type '{}' is not supported\",\n                        pos,\n                        obj.class()\n                    ),\n                ));\n            };\n\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                let db = SqliteRaw::from(self);\n                db.check(ret, vm)\n            }\n        }\n\n        fn bind_parameters(self, parameters: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            if let Some(dict) = parameters.downcast_ref::<PyDict>() {\n                self.bind_parameters_name(dict, vm)\n            } else if let Ok(seq) = PySequence::try_protocol(parameters, vm) {\n                self.bind_parameters_sequence(seq, vm)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"parameters are of unsupported type\".to_owned(),\n                ))\n            }\n        }\n\n        fn bind_parameters_name(self, dict: &Py<PyDict>, vm: &VirtualMachine) -> PyResult<()> {\n            let num_needed = unsafe { sqlite3_bind_parameter_count(self.st) };\n\n            for i in 1..=num_needed {\n                let name = unsafe { sqlite3_bind_parameter_name(self.st, i) };\n                if name.is_null() {\n                    return Err(new_programming_error(vm, \"Binding {} has no name, but you supplied a dictionary (which has only names).\".to_owned()));\n                }\n                let name = unsafe { name.add(1) };\n                let name = ptr_to_str(name, vm)?;\n\n                let val = match dict.get_item_opt(name, vm)? {\n                    Some(val) => val,\n                    None => {\n                        return Err(new_programming_error(\n                            vm,\n                            format!(\"You did not supply a value for binding parameter :{name}.\",),\n                        ));\n                    }\n                };\n\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn bind_parameter_count(self) -> c_int {\n            unsafe { sqlite3_bind_parameter_count(self.st) }\n        }\n\n        fn bind_parameters_sequence(\n            self,\n            seq: PySequence<'_>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let num_needed = self.bind_parameter_count();\n            let num_supplied = seq.length(vm)?;\n\n            if num_supplied != num_needed as usize {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Incorrect number of bindings supplied. The current statement uses {}, and {} were supplied.\",\n                        num_needed, num_supplied\n                    ),\n                ));\n            }\n\n            for i in 1..=num_needed {\n                let val = seq.get_item(i as isize - 1, vm)?;\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn column_count(self) -> c_int {\n            unsafe { sqlite3_column_count(self.st) }\n        }\n\n        fn column_type(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_type(self.st, pos) }\n        }\n\n        fn column_int(self, pos: c_int) -> i64 {\n            unsafe { sqlite3_column_int64(self.st, pos) }\n        }\n\n        fn column_double(self, pos: c_int) -> f64 {\n            unsafe { sqlite3_column_double(self.st, pos) }\n        }\n\n        fn column_blob(self, pos: c_int) -> *const c_void {\n            unsafe { sqlite3_column_blob(self.st, pos) }\n        }\n\n        fn column_text(self, pos: c_int) -> *const u8 {\n            unsafe { sqlite3_column_text(self.st, pos) }\n        }\n\n        fn column_decltype(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_decltype(self.st, pos) }\n        }\n\n        fn column_bytes(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_bytes(self.st, pos) }\n        }\n\n        fn column_name(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_name(self.st, pos) }\n        }\n\n        fn columns_name(self, detect_types: i32, vm: &VirtualMachine) -> PyResult<Vec<PyStrRef>> {\n            let count = self.column_count();\n            (0..count)\n                .map(|i| {\n                    let name = self.column_name(i);\n                    let name_str = ptr_to_str(name, vm)?;\n\n                    // If PARSE_COLNAMES is enabled, strip everything after the first '[' (and preceding space)\n                    let processed_name = if detect_types & PARSE_COLNAMES != 0\n                        && let Some(bracket_pos) = name_str.find('[')\n                    {\n                        // Check if there's a single space before '[' and remove it (CPython compatibility)\n                        let end_pos = if bracket_pos > 0\n                            && name_str.chars().nth(bracket_pos - 1) == Some(' ')\n                        {\n                            bracket_pos - 1\n                        } else {\n                            bracket_pos\n                        };\n\n                        &name_str[..end_pos]\n                    } else {\n                        name_str\n                    };\n\n                    Ok(vm.ctx.new_str(processed_name))\n                })\n                .collect()\n        }\n\n        fn columns_description(\n            self,\n            detect_types: i32,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<PyTupleRef>> {\n            if self.column_count() == 0 {\n                return Ok(None);\n            }\n            let columns = self\n                .columns_name(detect_types, vm)?\n                .into_iter()\n                .map(|s| {\n                    vm.ctx\n                        .new_tuple(vec![\n                            s.into(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                        ])\n                        .into()\n                })\n                .collect();\n            Ok(Some(vm.ctx.new_tuple(columns)))\n        }\n\n        fn busy(self) -> bool {\n            unsafe { sqlite3_stmt_busy(self.st) != 0 }\n        }\n\n        fn readonly(self) -> bool {\n            unsafe { sqlite3_stmt_readonly(self.st) != 0 }\n        }\n    }\n\n    #[derive(Debug, Copy, Clone)]\n    struct SqliteBlob {\n        blob: *mut sqlite3_blob,\n    }\n\n    impl SqliteBlob {\n        fn bytes(self) -> c_int {\n            unsafe { sqlite3_blob_bytes(self.blob) }\n        }\n\n        fn write(self, buf: *const c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_write(self.blob, buf, length, offset) }\n        }\n\n        fn read(self, buf: *mut c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_read(self.blob, buf, length, offset) }\n        }\n\n        fn read_single(self, byte: &mut u8, offset: c_int) -> c_int {\n            self.read(byte as *mut u8 as *mut _, 1, offset)\n        }\n\n        fn write_single(self, byte: u8, offset: c_int) -> c_int {\n            self.write(&byte as *const u8 as *const _, 1, offset)\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteContext {\n        ctx: *mut sqlite3_context,\n    }\n\n    impl From<*mut sqlite3_context> for SqliteContext {\n        fn from(ctx: *mut sqlite3_context) -> Self {\n            Self { ctx }\n        }\n    }\n\n    impl SqliteContext {\n        fn user_data<T>(self) -> *mut T {\n            unsafe { sqlite3_user_data(self.ctx).cast() }\n        }\n\n        fn aggregate_context<T>(self) -> *mut T {\n            unsafe { sqlite3_aggregate_context(self.ctx, std::mem::size_of::<T>() as c_int).cast() }\n        }\n\n        fn result_exception(self, vm: &VirtualMachine, exc: PyBaseExceptionRef, msg: &str) {\n            if exc.fast_isinstance(vm.ctx.exceptions.memory_error) {\n                unsafe { sqlite3_result_error_nomem(self.ctx) }\n            } else if exc.fast_isinstance(vm.ctx.exceptions.overflow_error) {\n                unsafe { sqlite3_result_error_toobig(self.ctx) }\n            } else {\n                unsafe { sqlite3_result_error(self.ctx, msg.as_ptr().cast(), -1) }\n            }\n            if enable_traceback().load(Ordering::Relaxed) {\n                vm.print_exception(exc);\n            }\n        }\n\n        fn db_handle(self) -> *mut sqlite3 {\n            unsafe { sqlite3_context_db_handle(self.ctx) }\n        }\n\n        fn result_from_object(self, val: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            unsafe {\n                if vm.is_none(val) {\n                    sqlite3_result_null(self.ctx)\n                } else if let Some(val) = val.downcast_ref::<PyInt>() {\n                    sqlite3_result_int64(self.ctx, val.try_to_primitive(vm)?)\n                } else if let Some(val) = val.downcast_ref::<PyFloat>() {\n                    sqlite3_result_double(self.ctx, val.to_f64())\n                } else if let Some(val) = val.downcast_ref::<PyStr>() {\n                    let val = val.try_as_utf8(vm)?;\n                    let (ptr, len) = str_to_ptr_len(val, vm)?;\n                    sqlite3_result_text(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, val) {\n                    let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                    sqlite3_result_blob(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else {\n                    return Err(new_programming_error(\n                        vm,\n                        \"result type not support\".to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n    }\n\n    fn value_to_object(val: *mut sqlite3_value, db: *mut sqlite3, vm: &VirtualMachine) -> PyResult {\n        let obj = unsafe {\n            match sqlite3_value_type(val) {\n                SQLITE_INTEGER => vm.ctx.new_int(sqlite3_value_int64(val)).into(),\n                SQLITE_FLOAT => vm.ctx.new_float(sqlite3_value_double(val)).into(),\n                SQLITE_TEXT => {\n                    let text =\n                        ptr_to_vec(sqlite3_value_text(val), sqlite3_value_bytes(val), db, vm)?;\n                    let text = String::from_utf8(text)\n                        .map_err(|_| vm.new_value_error(\"invalid utf-8 with SQLITE_TEXT\"))?;\n                    vm.ctx.new_str(text).into()\n                }\n                SQLITE_BLOB => {\n                    let blob = ptr_to_vec(\n                        sqlite3_value_blob(val).cast(),\n                        sqlite3_value_bytes(val),\n                        db,\n                        vm,\n                    )?;\n                    vm.ctx.new_bytes(blob).into()\n                }\n                _ => vm.ctx.none(),\n            }\n        };\n        Ok(obj)\n    }\n\n    fn ptr_to_str<'a>(p: *const libc::c_char, vm: &VirtualMachine) -> PyResult<&'a str> {\n        if p.is_null() {\n            return Err(vm.new_memory_error(\"string pointer is null\"));\n        }\n        unsafe { CStr::from_ptr(p).to_str() }\n            .map_err(|_| vm.new_value_error(\"Invalid UIF-8 codepoint\"))\n    }\n\n    fn ptr_to_string(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<String> {\n        let s = ptr_to_vec(p, nbytes, db, vm)?;\n        String::from_utf8(s).map_err(|_| vm.new_value_error(\"invalid utf-8\"))\n    }\n\n    fn ptr_to_vec(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<Vec<u8>> {\n        if p.is_null() {\n            if !db.is_null() && unsafe { sqlite3_errcode(db) } == SQLITE_NOMEM {\n                Err(vm.new_memory_error(\"sqlite out of memory\"))\n            } else {\n                Ok(vec![])\n            }\n        } else if nbytes < 0 {\n            Err(vm.new_system_error(\"negative size with ptr\"))\n        } else {\n            Ok(unsafe { std::slice::from_raw_parts(p.cast(), nbytes as usize) }.to_vec())\n        }\n    }\n\n    fn str_to_ptr_len(s: &PyUtf8Str, vm: &VirtualMachine) -> PyResult<(*const libc::c_char, i32)> {\n        let s_str = s.as_str();\n        let len = c_int::try_from(s_str.len())\n            .map_err(|_| vm.new_overflow_error(\"TEXT longer than INT_MAX bytes\"))?;\n        let ptr = s_str.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn buffer_to_ptr_len(buffer: &PyBuffer, vm: &VirtualMachine) -> PyResult<(*const c_void, i32)> {\n        let bytes = buffer\n            .as_contiguous()\n            .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n        let len = c_int::try_from(bytes.len())\n            .map_err(|_| vm.new_overflow_error(\"BLOB longer than INT_MAX bytes\"))?;\n        let ptr = bytes.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn exception_type_from_errcode(errcode: c_int, vm: &VirtualMachine) -> &'static Py<PyType> {\n        match errcode {\n            SQLITE_INTERNAL | SQLITE_NOTFOUND => internal_error_type(),\n            SQLITE_NOMEM => vm.ctx.exceptions.memory_error,\n            SQLITE_ERROR | SQLITE_PERM | SQLITE_ABORT | SQLITE_BUSY | SQLITE_LOCKED\n            | SQLITE_READONLY | SQLITE_INTERRUPT | SQLITE_IOERR | SQLITE_FULL | SQLITE_CANTOPEN\n            | SQLITE_PROTOCOL | SQLITE_EMPTY | SQLITE_SCHEMA => operational_error_type(),\n            SQLITE_CORRUPT => database_error_type(),\n            SQLITE_TOOBIG => data_error_type(),\n            SQLITE_CONSTRAINT | SQLITE_MISMATCH => integrity_error_type(),\n            SQLITE_MISUSE | SQLITE_RANGE => interface_error_type(),\n            _ => database_error_type(),\n        }\n    }\n\n    fn name_from_errcode(errcode: c_int) -> &'static str {\n        for (name, code) in ERROR_CODES {\n            if *code == errcode {\n                return name;\n            }\n        }\n        \"unknown error code\"\n    }\n\n    fn raise_exception(\n        typ: PyTypeRef,\n        errcode: c_int,\n        msg: String,\n        vm: &VirtualMachine,\n    ) -> PyBaseExceptionRef {\n        let dict = vm.ctx.new_dict();\n        if let Err(e) = dict.set_item(\"sqlite_errorcode\", vm.ctx.new_int(errcode).into(), vm) {\n            return e;\n        }\n        let errname = name_from_errcode(errcode);\n        if let Err(e) = dict.set_item(\"sqlite_errorname\", vm.ctx.new_str(errname).into(), vm) {\n            return e;\n        }\n\n        vm.new_exception_msg_dict(typ, msg, dict)\n    }\n\n    static BEGIN_STATEMENTS: &[&[u8]] = &[\n        b\"BEGIN \",\n        b\"BEGIN DEFERRED\",\n        b\"BEGIN IMMEDIATE\",\n        b\"BEGIN EXCLUSIVE\",\n    ];\n\n    fn begin_statement_ptr_from_isolation_level(\n        s: &PyStr,\n        vm: &VirtualMachine,\n    ) -> PyResult<*const libc::c_char> {\n        BEGIN_STATEMENTS\n            .iter()\n            .find(|&&x| x[6..].eq_ignore_ascii_case(s.as_bytes()))\n            .map(|&x| x.as_ptr().cast())\n            .ok_or_else(|| {\n                vm.new_value_error(\n                    \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or 'EXCLUSIVE'\",\n                )\n            })\n    }\n\n    fn lstrip_sql(sql: &[u8]) -> Option<&[u8]> {\n        let mut pos = 0;\n\n        // This loop is borrowed from the SQLite source code.\n        while let Some(t_char) = sql.get(pos) {\n            match t_char {\n                b' ' | b'\\t' | b'\\x0c' | b'\\n' | b'\\r' => {\n                    // Skip whitespace.\n                    pos += 1;\n                }\n                b'-' => {\n                    // Skip line comments.\n                    if sql.get(pos + 1) == Some(&b'-') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'\\n' {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                b'/' => {\n                    // Skip C style comments.\n                    if sql.get(pos + 1) == Some(&b'*') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'*' && sql.get(pos + 1) == Some(&b'/') {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                        pos += 2;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                _ => {\n                    return Some(&sql[pos..]);\n                }\n            }\n        }\n\n        None\n    }\n}\n"
                }
              ],
              []
            ],
            "kind": "textEditGroup",
            "uri": {
              "$mid": 1,
              "external": "file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "fsPath": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "path": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "scheme": "file"
            }
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `detect_types` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `check_same_thread` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `thread_ident` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `sqlite3` (`**/Cargo.toml`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/Cargo.toml#1-1), 1 줄에서 80 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "assistant",
          "text": "**Planning multi-step git workflow** **Starting first todo and setting branch** **Creating new branch for issue 6287** **Completing task todo1** **Locating SQLite module** **Opening file for reading** **Implementing connection initializer error handling**\n\nI’m working through how the connection initializer should behave when called a second time—specifically, it must raise an OperationalError like in CPython, matching expected SQLite errors when reopening a DB with invalid paths. I’m comparing this requirement against CPython’s actual connection.c implementation to make sure the error handling is consistent with their behavior and the user’s test expectations. **Analyzing reinitialization error handling** **Analyzing uninitialized executemany error handling** **Searching for Statement struct** **Analyzing connection reinitialization logic**\n\nThis is a deep dive into how connection reinitialization works, focusing on when `__init__` is called again on an existing connection, closing old DB handles, setting the internal state correctly, and returning appropriate errors to match test expectations. I'm thinking through how the base class `py_new` and `__init__` interact, spotting possible double initialization issues, and how to mimic CPython's behavior with resetting factories and marking uninitialized on failure. It looks like the current panic in `init` needs removal to allow proper reinit logic. **Investigating sqlite connection function** **Analyzing connection initialization flow**\n\nI'm untangling how the `connect` function creates Connection instances, focusing on how and when `__new__` and `__init__` get called in Rust versus Python. I want to understand why the current `__init__` is a no-op and how to correctly implement reinitialization to match CPython's behavior, possibly shifting database opening from `py_new` to `__init__`. This involves digging into Rust traits like `Constructor` and `Initializer` and testing whether `__init__` runs when calling `Connection::py_new` from Rust. **Analyzing Connection initialization and reinitialization logic**\n\nI'm examining how Connection's `py_new` and `__init__` interact, especially since `sqlite.connect` calls `py_new` but might skip `__init__`. To mimic CPython, I plan to implement `Initializer::init` to handle reinitialization safely by closing existing connections, updating fields like `detect_types` and `row_factory`, and reopening the DB. This should enable manual `__init__` calls without panics and align behavior with CPython, even though it may cause some redundant reopening on direct `Connection(...)` calls. **Detailing Connection reinitialization and db state handling**\n\nI'm working through how `Connection.__init__` should drop the old DB connection before reinitializing, ensuring that failed reloads clear the connection so methods like `executemany` raise the proper error. I’m also considering how to avoid redundant DB opens when `__init__` automatically follows `__new__` on direct type calls, and how to reset fields like `row_factory` and `text_factory` to defaults before reopening the DB. This approach should keep behavior close to CPython’s while handling edge cases cleanly. **Clarifying initialization sequence and connection setup**\n\nI'm sorting out when `__init__` runs after `py_new`, confirming that calling `sqlite.connect` manually runs only `py_new` (which opens the DB), while direct calls to `Connection()` trigger both `py_new` and `__init__`, causing redundant opens that I'll accept for now. I’m also planning to adjust `init` to safely reinitialize or open connections while resetting relevant fields, aligning behavior with CPython’s. **Evaluating initialization redesign options**\n\nI'm weighing how to shift DB opening fully into `__init__` to mimic CPython, but calling `__init__` manually from Rust is tricky, so I’m considering flags in `Connection` to track initialization state and avoid redundant opens. The goal is to allow both direct type calls and `connect` function use cases to initialize properly without double-opening or skipping initialization, accepting some redundant work in rare cases for simplicity. ``` @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs ``` **Analyzing mutability constraints** **Inspecting example source file** **Exploring mutation options for PyRef fields** **Searching for PyRef definition** **Seeking method to obtain `&Py<T>`** **Exploring mutable PyRef options** **Investigating Py<T> interior mutability** **Analyzing mutability of detect_types** **Evaluating mutable field strategies** **Analyzing use of atomic types for mutation** **Evaluating thread_ident synchronization approaches**\n\nI'm exploring how to safely manage the `thread_ident` field, which can't use `PyAtomic` directly due to type constraints. Wrapping it with `PyMutex` or `PyRwLock` seems plausible, though with some overhead for frequent reads in `check_thread`. I'm also considering whether updating it on reinit is strictly necessary, and how to obtain mutable access to `thread_ident` through `PyRef` and `payload_mut` methods. There's a lot to weigh about safety, performance, and Rust constraints here! **Considering atomic and mutex wrappers for fields** **Adjusting Connection atomic and mutex fields** **Updating thread synchronization code** **Considering atomic updates and interior mutability** **Planning Connection struct updates** **Refactoring struct fields and initialization**\n\nI'm updating struct fields to use atomic and mutex wrappers for thread safety, adjusting the `py_new` constructor accordingly, and planning to remove an unused mutex guard in `init`. Step-by-step, I'll revise methods to store and load from these new types, add helper methods for cleaner access, and prepare for testing after formatting. This careful restructuring should improve concurrency handling while keeping existing logic intact. ``` @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs ``` **Updating initialization function** ``` @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs ``` **Updating check_thread method** **Reviewing specific code lines** **Searching for function definition** **Identifying code block for replacement** ``` @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs ``` **Updating Cursor execute methods** ``` @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs ``` **Preparing to modify Cursor code** **Optimizing detect_types usage** ``` @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs ``` **Verifying field access updates** **Reviewing detect_types and check_same_thread usage** **Updating thread_ident references** **Reviewing and cleaning concurrency code** **Preparing to run tests and clippy** **Preparing for testing and linting** **Resolving regrtest filtering conflict** **Investigating missing _sqlite3 module for tests**\n\nI'm puzzled by skipped tests needing `_sqlite3`, which might be an optional RustPython feature not built by default. The crate probably requires enabling a `sqlite` feature to build this module, so I'll look into Cargo.toml and config to confirm and figure out how to run tests with that feature enabled. **Verifying SQLite feature configuration** **Enabling sqlite feature for tests** **Preparing to run cargo clippy with features** **Updating task statuses** **Preparing to commit changes** **Preparing commit with only relevant changes** **Preparing commit with descriptive message** **Preparing commit message** **Marking todo item complete** **Summarizing final changes and tests**\n\nI'll create a concise summary highlighting modifications in `crates/stdlib/src/sqlite.rs`, including enhanced init handling with database drops and reopening, use of atomics and mutexes for thread-safe state, improved `check_thread` logic, and fixed `executemany` post-reinit behavior. I'll note running tests with the `sqlite` feature enabled and formatting/linting commands, mention the commit created, and call out the earlier skipped test that later passed. The summary will use bullet points for clarity and a friendly tone as requested. **Summary**\n- Updated @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs so now mirrors CPython: it drops the current handle, resets factories, and reopens the database, leaving the object uninitialized when the reopen fails (allowing to raise the expected ).\n- Wrapped , , and `thread_ident` in atomic/mutex primitives, adjusted readers ( , row casts, thread checks) to load from those, and ensured state is safely refreshed during reinitialization.\n- Added the necessary test/lint hygiene (fmt + clippy) and committed the change as “Fix sqlite connection reinitialization.”\n\n**Testing**\n- `cargo run --release --features sqlite -- -m test -m test_connection_bad_reinit test_sqlite3.test_dbapi`\n\n**Linting/Formatting**\n- - `cargo clippy --features sqlite`",
          "timestamp": "2025-11-21T16:17:21.635+00:00"
        },
        {
          "type": "user",
          "text": "흠 cpython구현에서는 initialize flag를 두고 그걸로 판단하는거 같은데, 아니면 너가 작성하기 전 코드에서는 guard.is_some()으로 Already initialized를 체크하잖아. 왜 이렇게 한거야?\n이렇게 복잡하게 구현하는 이유가 있어? 다시 구현사항을 롤백하고 cpython코드와 호환성을 맞춰봐.\n\n아래는 코드를 발췌한 내용이야.\n우선 진행할때 왜 현재 처럼 했는지 먼저 설명해주고, 지금 구현이 맞는거 같으면 멈춰도 되고 내 요구사항처럼 맞춰어야 된다고 생각하면 설명하고 나서 수정해.\n수정 하기전에 branch를 백업용으로 하나 만들어놓고 시작해줘.\n그리고 기존에는 Connection의 struct field를 채우는 부분이 어디였는지도 설명해줘.\n\n(in connection.c)\n    if (self->initialized) {\n        self->initialized = 0;\n\n        PyTypeObject *tp = Py_TYPE(self);\n        tp->tp_clear((PyObject *)self);\n        if (connection_close(self) < 0) {\n            return -1;\n        }\n    }\n\n---\n(in connection.h)\n\n    int initialized;\n\n    /* thread identification of the thread the connection was created in */\n    unsigned long thread_ident;",
          "timestamp": "2025-11-21T16:17:45.382+00:00"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "assistant",
          "text": "**Preparing backup branch and managing tasks** **Explaining connection initialization changes**\n\nI’m putting together a detailed explanation of the prior switch from a simple boolean guard to atomic types managing connection state in the Rust code. This includes why the atomic approach was introduced—to handle reinitialization properly as the base connection is opened in `py_new` and `__init__` can be called again—and how that relates to tests expecting certain failures on reinit. I’ll note how fields like `detect_types` were assigned in `py_new` and why interior mutability required atomic wrappers. Finally, I’m outlining a plan to revert closer to CP’s simpler `initialized` flag with atomic bools to keep interior mutability but restore compatibility and clarity, as the user requested. 우선 왜 지금처럼 구현했는지부터 설명드릴게요.\n\n- RustPython의 은 가 호출되면 안에서 바로 SQLite 핸들을 열고 안에 로 넣습니다. 그래서 `test_connection_bad_reinit`이 를 다시 호출했을 때, 기존 코드처럼 이면 “이미 초기화되었다”고 조용히 빠져나가 버려서 CPython과 달리 재초기화를 시도하지 않았고, 그 결과 두 번째 이 OperationalError를 터뜨리지 못했습니다. 이걸 고치려고 저는 에서 무조건 로 현재 DB를 비운 뒤 새로 열도록 했습니다. 즉, CPython이 `self->initialized` 플래그를 확인해서 이미 초기화돼 있으면 `connection_close()`로 정리해 주는 흐름을 Option 기반으로 흉내 낸 것입니다.\n\n- 구조체 필드들은 안에서 한 번만 채워집니다. , , `thread_ident` 같은 값도 여기에서 설정됐고, 이후 에서는 다시 쓸 일이 없었기 때문에 interior mutability가 필요 없었습니다. 이번 수정에서는 재호출 때도 갱신이 필요해져서 / 로 감싼 것이고요.\n\n말씀해주신 것처럼 CPython은 플래그(`self->initialized`)를 명시적으로 두고 그걸 기반으로 teardown과 재초기화를 수행합니다. 제 구현은 Option과 여러 atomic/mutex 조합으로 동일한 효과를 내긴 하지만, 구조가 복잡해졌고 CPython 흐름을 따라가기 어렵다는 피드백도 타당해 보입니다. 따라서 다음 단계에서는 CPython과 최대한 동일한 형태로 정리하려 합니다:\n\n1. 에 `initialized: PyAtomic<bool>`(CPython의 대응)을 추가하고, `thread_ident`도 별도의 락 대신 전용 필드에 저장·복구하는 식으로 단순화하겠습니다.\n2. 에서는 CPython처럼 `initialized`가 이미 true면 먼저 내부 상태를 초기화(`tp_clear`에 해당하는 필드 리셋 + `connection_close`)하고, 그 뒤 새 DB를 열도록 하겠습니다. 이렇게 하면 “이미 초기화된 커넥션을 다시 초기화하면 OperationalError가 난다”는 CPython의 동작을 그대로 얻을 수 있습니다.\n3. 필드 재설정은 기존처럼 에서 한 번, 그리고 재호출 시에는 CPython 흐름을 따라 필요한 값만 갱신하도록 정리하겠습니다.\n\n이제 위 계획대로 CPython 호환 흐름으로 맞추는 작업을 진행해도 될까요?",
          "timestamp": "2025-11-21T16:19:04.661+00:00"
        },
        {
          "type": "user",
          "text": "ㅇㅇ cpython과 최대한 동일한 형태로 구현해",
          "timestamp": "2025-11-21T16:19:25.268+00:00"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_readFile"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_readFile",
          "input": "읽기 [](file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs#800-800), 800 줄에서 1120 줄까지"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `PyRefMut` (`**/crates/**/*.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `Cannot operate on a closed database` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `Cannot operate on a closed` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "textEditGroup",
          "input": {
            "done": true,
            "edits": [
              [
                {
                  "range": {
                    "endColumn": 1,
                    "endLineNumber": 3404,
                    "startColumn": 1,
                    "startLineNumber": 1
                  },
                  "text": "// spell-checker:ignore libsqlite3 threadsafety PYSQLITE decltypes colnames collseq cantinit dirtywal\n// spell-checker:ignore corruptfs narg setinputsizes setoutputsize lastrowid arraysize executemany\n// spell-checker:ignore blobopen executescript iterdump getlimit setlimit errorcode errorname\n// spell-checker:ignore rowid rowcount fetchone fetchmany fetchall errcode errname vtable pagecount\n// spell-checker:ignore autocommit libversion toobig errmsg nomem threadsafe longlong vdbe reindex\n// spell-checker:ignore savepoint cantopen ioerr nolfs nomem notadb notfound fullpath notempdir vtab\n// spell-checker:ignore checkreservedlock noent fstat rdlock shmlock shmmap shmopen shmsize sharedcache\n// spell-checker:ignore cantlock commithook foreignkey notnull primarykey gettemppath autoindex convpath\n// spell-checker:ignore dbmoved vnode nbytes\n\nuse rustpython_vm::{AsObject, PyRef, VirtualMachine, builtins::PyModule};\n\n// pub(crate) use _sqlite::make_module;\npub(crate) fn make_module(vm: &VirtualMachine) -> PyRef<PyModule> {\n    // TODO: sqlite version check\n    let module = _sqlite::make_module(vm);\n    _sqlite::setup_module(module.as_object(), vm);\n    module\n}\n\n#[pymodule]\nmod _sqlite {\n    use crossbeam_utils::atomic::AtomicCell;\n    use libsqlite3_sys::{\n        SQLITE_BLOB, SQLITE_DETERMINISTIC, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL,\n        SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, SQLITE_OPEN_URI, SQLITE_TEXT, SQLITE_TRACE_STMT,\n        SQLITE_TRANSIENT, SQLITE_UTF8, sqlite3, sqlite3_aggregate_context, sqlite3_backup_finish,\n        sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining,\n        sqlite3_backup_step, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64,\n        sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name,\n        sqlite3_bind_text, sqlite3_blob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open,\n        sqlite3_blob_read, sqlite3_blob_write, sqlite3_busy_timeout, sqlite3_changes,\n        sqlite3_close_v2, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count,\n        sqlite3_column_decltype, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_name,\n        sqlite3_column_text, sqlite3_column_type, sqlite3_complete, sqlite3_context,\n        sqlite3_context_db_handle, sqlite3_create_collation_v2, sqlite3_create_function_v2,\n        sqlite3_create_window_function, sqlite3_data_count, sqlite3_db_handle, sqlite3_errcode,\n        sqlite3_errmsg, sqlite3_exec, sqlite3_expanded_sql, sqlite3_extended_errcode,\n        sqlite3_finalize, sqlite3_get_autocommit, sqlite3_interrupt, sqlite3_last_insert_rowid,\n        sqlite3_libversion, sqlite3_limit, sqlite3_open_v2, sqlite3_prepare_v2,\n        sqlite3_progress_handler, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double,\n        sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_error_toobig,\n        sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_set_authorizer,\n        sqlite3_sleep, sqlite3_step, sqlite3_stmt, sqlite3_stmt_busy, sqlite3_stmt_readonly,\n        sqlite3_threadsafe, sqlite3_total_changes, sqlite3_trace_v2, sqlite3_user_data,\n        sqlite3_value, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double,\n        sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type,\n    };\n    use malachite_bigint::Sign;\n    use rustpython_common::{\n        atomic::{Ordering, PyAtomic, Radium},\n        hash::PyHash,\n        lock::{PyMappedMutexGuard, PyMutex, PyMutexGuard},\n        static_cell,\n    };\n    use rustpython_vm::{\n        __exports::paste,\n        AsObject, Py, PyAtomicRef, PyObject, PyObjectRef, PyPayload, PyRef, PyResult,\n        TryFromBorrowedObject, VirtualMachine, atomic_func,\n        builtins::{\n            PyBaseException, PyBaseExceptionRef, PyByteArray, PyBytes, PyDict, PyDictRef, PyFloat,\n            PyInt, PyIntRef, PySlice, PyStr, PyStrRef, PyTuple, PyTupleRef, PyType, PyTypeRef,\n            PyUtf8Str, PyUtf8StrRef,\n        },\n        convert::IntoObject,\n        function::{\n            ArgCallable, ArgIterable, FsPath, FuncArgs, OptionalArg, PyComparisonValue,\n            PySetterValue,\n        },\n        object::{Traverse, TraverseFn},\n        protocol::{\n            PyBuffer, PyIterReturn, PyMappingMethods, PyNumberMethods, PySequence,\n            PySequenceMethods,\n        },\n        sliceable::{SaturatedSliceIter, SliceableSequenceOp},\n        types::{\n            AsMapping, AsNumber, AsSequence, Callable, Comparable, Constructor, Hashable,\n            Initializer, IterNext, Iterable, PyComparisonOp, SelfIter, Unconstructible,\n        },\n        utils::ToCString,\n    };\n    use std::{\n        ffi::{CStr, c_int, c_longlong, c_uint, c_void},\n        fmt::Debug,\n        ops::Deref,\n        ptr::{NonNull, null, null_mut},\n        thread::ThreadId,\n    };\n\n    macro_rules! exceptions {\n        ($(($x:ident, $base:expr)),*) => {\n            paste::paste! {\n                static_cell! {\n                    $(\n                        static [<$x:snake:upper>]: PyTypeRef;\n                    )*\n                }\n                $(\n                    #[allow(dead_code)]\n                    fn [<new_ $x:snake>](vm: &VirtualMachine, msg: String) -> PyBaseExceptionRef {\n                        vm.new_exception_msg([<$x:snake _type>]().to_owned(), msg)\n                    }\n                    fn [<$x:snake _type>]() -> &'static Py<PyType> {\n                        [<$x:snake:upper>].get().expect(\"exception type not initialize\")\n                    }\n                )*\n                fn setup_module_exceptions(module: &PyObject, vm: &VirtualMachine) {\n                    $(\n                        #[allow(clippy::redundant_closure_call)]\n                        let exception = [<$x:snake:upper>].get_or_init(|| {\n                            let base = $base(vm);\n                            vm.ctx.new_exception_type(\"_sqlite3\", stringify!($x), Some(vec![base.to_owned()]))\n                        });\n                        module.set_attr(stringify!($x), exception.clone().into_object(), vm).unwrap();\n                    )*\n                }\n            }\n        };\n    }\n\n    exceptions!(\n        (Warning, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (Error, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (InterfaceError, |_| error_type()),\n        (DatabaseError, |_| error_type()),\n        (DataError, |_| database_error_type()),\n        (OperationalError, |_| database_error_type()),\n        (IntegrityError, |_| database_error_type()),\n        (InternalError, |_| database_error_type()),\n        (ProgrammingError, |_| database_error_type()),\n        (NotSupportedError, |_| database_error_type())\n    );\n\n    #[pyattr]\n    fn sqlite_version(vm: &VirtualMachine) -> String {\n        let s = unsafe { sqlite3_libversion() };\n        ptr_to_str(s, vm).unwrap().to_owned()\n    }\n\n    #[pyattr]\n    fn threadsafety(_: &VirtualMachine) -> c_int {\n        let mode = unsafe { sqlite3_threadsafe() };\n        match mode {\n            0 => 0,\n            1 => 3,\n            2 => 1,\n            _ => panic!(\"Unable to interpret SQLite threadsafety mode\"),\n        }\n    }\n\n    #[pyattr(name = \"_deprecated_version\")]\n    const PYSQLITE_VERSION: &str = \"2.6.0\";\n\n    #[pyattr]\n    const PARSE_DECLTYPES: c_int = 1;\n    #[pyattr]\n    const PARSE_COLNAMES: c_int = 2;\n\n    #[pyattr]\n    use libsqlite3_sys::{\n        SQLITE_ALTER_TABLE, SQLITE_ANALYZE, SQLITE_ATTACH, SQLITE_CREATE_INDEX,\n        SQLITE_CREATE_TABLE, SQLITE_CREATE_TEMP_INDEX, SQLITE_CREATE_TEMP_TABLE,\n        SQLITE_CREATE_TEMP_TRIGGER, SQLITE_CREATE_TEMP_VIEW, SQLITE_CREATE_TRIGGER,\n        SQLITE_CREATE_VIEW, SQLITE_CREATE_VTABLE, SQLITE_DELETE, SQLITE_DENY, SQLITE_DETACH,\n        SQLITE_DROP_INDEX, SQLITE_DROP_TABLE, SQLITE_DROP_TEMP_INDEX, SQLITE_DROP_TEMP_TABLE,\n        SQLITE_DROP_TEMP_TRIGGER, SQLITE_DROP_TEMP_VIEW, SQLITE_DROP_TRIGGER, SQLITE_DROP_VIEW,\n        SQLITE_DROP_VTABLE, SQLITE_FUNCTION, SQLITE_IGNORE, SQLITE_INSERT, SQLITE_LIMIT_ATTACHED,\n        SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH,\n        SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH,\n        SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER,\n        SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_PRAGMA, SQLITE_READ,\n        SQLITE_RECURSIVE, SQLITE_REINDEX, SQLITE_SAVEPOINT, SQLITE_SELECT, SQLITE_TRANSACTION,\n        SQLITE_UPDATE,\n    };\n\n    macro_rules! error_codes {\n        ($($x:ident),*) => {\n            $(\n                #[allow(unused_imports)]\n                use libsqlite3_sys::$x;\n            )*\n            static ERROR_CODES: &[(&str, c_int)] = &[\n            $(\n                (stringify!($x), libsqlite3_sys::$x),\n            )*\n            ];\n        };\n    }\n\n    error_codes!(\n        SQLITE_ABORT,\n        SQLITE_AUTH,\n        SQLITE_BUSY,\n        SQLITE_CANTOPEN,\n        SQLITE_CONSTRAINT,\n        SQLITE_CORRUPT,\n        SQLITE_DONE,\n        SQLITE_EMPTY,\n        SQLITE_ERROR,\n        SQLITE_FORMAT,\n        SQLITE_FULL,\n        SQLITE_INTERNAL,\n        SQLITE_INTERRUPT,\n        SQLITE_IOERR,\n        SQLITE_LOCKED,\n        SQLITE_MISMATCH,\n        SQLITE_MISUSE,\n        SQLITE_NOLFS,\n        SQLITE_NOMEM,\n        SQLITE_NOTADB,\n        SQLITE_NOTFOUND,\n        SQLITE_OK,\n        SQLITE_PERM,\n        SQLITE_PROTOCOL,\n        SQLITE_RANGE,\n        SQLITE_READONLY,\n        SQLITE_ROW,\n        SQLITE_SCHEMA,\n        SQLITE_TOOBIG,\n        SQLITE_NOTICE,\n        SQLITE_WARNING,\n        SQLITE_ABORT_ROLLBACK,\n        SQLITE_BUSY_RECOVERY,\n        SQLITE_CANTOPEN_FULLPATH,\n        SQLITE_CANTOPEN_ISDIR,\n        SQLITE_CANTOPEN_NOTEMPDIR,\n        SQLITE_CORRUPT_VTAB,\n        SQLITE_IOERR_ACCESS,\n        SQLITE_IOERR_BLOCKED,\n        SQLITE_IOERR_CHECKRESERVEDLOCK,\n        SQLITE_IOERR_CLOSE,\n        SQLITE_IOERR_DELETE,\n        SQLITE_IOERR_DELETE_NOENT,\n        SQLITE_IOERR_DIR_CLOSE,\n        SQLITE_IOERR_DIR_FSYNC,\n        SQLITE_IOERR_FSTAT,\n        SQLITE_IOERR_FSYNC,\n        SQLITE_IOERR_LOCK,\n        SQLITE_IOERR_NOMEM,\n        SQLITE_IOERR_RDLOCK,\n        SQLITE_IOERR_READ,\n        SQLITE_IOERR_SEEK,\n        SQLITE_IOERR_SHMLOCK,\n        SQLITE_IOERR_SHMMAP,\n        SQLITE_IOERR_SHMOPEN,\n        SQLITE_IOERR_SHMSIZE,\n        SQLITE_IOERR_SHORT_READ,\n        SQLITE_IOERR_TRUNCATE,\n        SQLITE_IOERR_UNLOCK,\n        SQLITE_IOERR_WRITE,\n        SQLITE_LOCKED_SHAREDCACHE,\n        SQLITE_READONLY_CANTLOCK,\n        SQLITE_READONLY_RECOVERY,\n        SQLITE_CONSTRAINT_CHECK,\n        SQLITE_CONSTRAINT_COMMITHOOK,\n        SQLITE_CONSTRAINT_FOREIGNKEY,\n        SQLITE_CONSTRAINT_FUNCTION,\n        SQLITE_CONSTRAINT_NOTNULL,\n        SQLITE_CONSTRAINT_PRIMARYKEY,\n        SQLITE_CONSTRAINT_TRIGGER,\n        SQLITE_CONSTRAINT_UNIQUE,\n        SQLITE_CONSTRAINT_VTAB,\n        SQLITE_READONLY_ROLLBACK,\n        SQLITE_IOERR_MMAP,\n        SQLITE_NOTICE_RECOVER_ROLLBACK,\n        SQLITE_NOTICE_RECOVER_WAL,\n        SQLITE_BUSY_SNAPSHOT,\n        SQLITE_IOERR_GETTEMPPATH,\n        SQLITE_WARNING_AUTOINDEX,\n        SQLITE_CANTOPEN_CONVPATH,\n        SQLITE_IOERR_CONVPATH,\n        SQLITE_CONSTRAINT_ROWID,\n        SQLITE_READONLY_DBMOVED,\n        SQLITE_AUTH_USER,\n        SQLITE_OK_LOAD_PERMANENTLY,\n        SQLITE_IOERR_VNODE,\n        SQLITE_IOERR_AUTH,\n        SQLITE_IOERR_BEGIN_ATOMIC,\n        SQLITE_IOERR_COMMIT_ATOMIC,\n        SQLITE_IOERR_ROLLBACK_ATOMIC,\n        SQLITE_ERROR_MISSING_COLLSEQ,\n        SQLITE_ERROR_RETRY,\n        SQLITE_READONLY_CANTINIT,\n        SQLITE_READONLY_DIRECTORY,\n        SQLITE_CORRUPT_SEQUENCE,\n        SQLITE_LOCKED_VTAB,\n        SQLITE_CANTOPEN_DIRTYWAL,\n        SQLITE_ERROR_SNAPSHOT,\n        SQLITE_CANTOPEN_SYMLINK,\n        SQLITE_CONSTRAINT_PINNED,\n        SQLITE_OK_SYMLINK,\n        SQLITE_BUSY_TIMEOUT,\n        SQLITE_CORRUPT_INDEX,\n        SQLITE_IOERR_DATA,\n        SQLITE_IOERR_CORRUPTFS\n    );\n\n    #[derive(FromArgs)]\n    struct ConnectArgs {\n        #[pyarg(any)]\n        database: FsPath,\n        #[pyarg(any, default = 5.0)]\n        timeout: f64,\n        #[pyarg(any, default = 0)]\n        detect_types: c_int,\n        #[pyarg(any, default = Some(vm.ctx.empty_str.to_owned()))]\n        isolation_level: Option<PyStrRef>,\n        #[pyarg(any, default = true)]\n        check_same_thread: bool,\n        #[pyarg(any, default = Connection::class(&vm.ctx).to_owned())]\n        factory: PyTypeRef,\n        // TODO: cache statements\n        #[allow(dead_code)]\n        #[pyarg(any, default = 0)]\n        cached_statements: c_int,\n        #[pyarg(any, default = false)]\n        uri: bool,\n    }\n\n    unsafe impl Traverse for ConnectArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.isolation_level.traverse(tracer_fn);\n            self.factory.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct BackupArgs {\n        #[pyarg(any)]\n        target: PyRef<Connection>,\n        #[pyarg(named, default = -1)]\n        pages: c_int,\n        #[pyarg(named, optional)]\n        progress: Option<ArgCallable>,\n        #[pyarg(named, optional)]\n        name: Option<PyStrRef>,\n        #[pyarg(named, default = 0.250)]\n        sleep: f64,\n    }\n\n    unsafe impl Traverse for BackupArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.progress.traverse(tracer_fn);\n            self.name.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct CreateFunctionArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(any)]\n        narg: c_int,\n        #[pyarg(any)]\n        func: PyObjectRef,\n        #[pyarg(named, default)]\n        deterministic: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct CreateAggregateArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(positional)]\n        narg: c_int,\n        #[pyarg(positional)]\n        aggregate_class: PyObjectRef,\n    }\n\n    #[derive(FromArgs)]\n    struct BlobOpenArgs {\n        #[pyarg(positional)]\n        table: PyStrRef,\n        #[pyarg(positional)]\n        column: PyStrRef,\n        #[pyarg(positional)]\n        row: i64,\n        #[pyarg(named, default)]\n        readonly: bool,\n        #[pyarg(named, default = vm.ctx.new_str(\"main\"))]\n        name: PyStrRef,\n    }\n\n    struct CallbackData {\n        obj: NonNull<PyObject>,\n        vm: *const VirtualMachine,\n    }\n\n    impl CallbackData {\n        fn new(obj: PyObjectRef, vm: &VirtualMachine) -> Option<Self> {\n            (!vm.is_none(&obj)).then_some(Self {\n                obj: obj.into_raw(),\n                vm,\n            })\n        }\n\n        fn retrieve(&self) -> (&PyObject, &VirtualMachine) {\n            unsafe { (self.obj.as_ref(), &*self.vm) }\n        }\n\n        unsafe extern \"C\" fn destructor(data: *mut c_void) {\n            drop(unsafe { Box::from_raw(data.cast::<Self>()) });\n        }\n\n        unsafe extern \"C\" fn func_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (func, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n\n                let val = func.call(args, vm)?;\n\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                context.result_exception(vm, exc, \"user-defined function raised exception\\0\")\n            }\n        }\n\n        unsafe extern \"C\" fn step_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (cls, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            if unsafe { (*instance).is_null() } {\n                match cls.call((), vm) {\n                    Ok(obj) => unsafe { *instance = obj.into_raw().as_ptr() },\n                    Err(exc) => {\n                        return context.result_exception(\n                            vm,\n                            exc,\n                            \"user-defined aggregate's '__init__' method raised error\\0\",\n                        );\n                    }\n                }\n            }\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"step\", args, vm);\n        }\n\n        unsafe extern \"C\" fn finalize_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let Some(instance) = (unsafe { (*instance).as_ref() }) else {\n                return;\n            };\n\n            Self::callback_result_from_method(context, instance, \"finalize\", vm);\n        }\n\n        unsafe extern \"C\" fn collation_callback(\n            data: *mut c_void,\n            a_len: c_int,\n            a_ptr: *const c_void,\n            b_len: c_int,\n            b_ptr: *const c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n\n            let f = || -> PyResult<c_int> {\n                let text1 = ptr_to_string(a_ptr.cast(), a_len, null_mut(), vm)?;\n                let text1 = vm.ctx.new_str(text1);\n                let text2 = ptr_to_string(b_ptr.cast(), b_len, null_mut(), vm)?;\n                let text2 = vm.ctx.new_str(text2);\n\n                let val = callable.call((text1, text2), vm)?;\n                let Some(val) = val.to_number().index(vm) else {\n                    return Ok(0);\n                };\n\n                let val = match val?.as_bigint().sign() {\n                    Sign::Plus => 1,\n                    Sign::Minus => -1,\n                    Sign::NoSign => 0,\n                };\n\n                Ok(val)\n            };\n\n            f().unwrap_or(0)\n        }\n\n        unsafe extern \"C\" fn value_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::callback_result_from_method(context, instance, \"value\", vm);\n        }\n\n        unsafe extern \"C\" fn inverse_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"inverse\", args, vm);\n        }\n\n        unsafe extern \"C\" fn authorizer_callback(\n            data: *mut c_void,\n            action: c_int,\n            arg1: *const libc::c_char,\n            arg2: *const libc::c_char,\n            db_name: *const libc::c_char,\n            access: *const libc::c_char,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let f = || -> PyResult<c_int> {\n                let arg1 = ptr_to_str(arg1, vm)?;\n                let arg2 = ptr_to_str(arg2, vm)?;\n                let db_name = ptr_to_str(db_name, vm)?;\n                let access = ptr_to_str(access, vm)?;\n\n                let val = callable.call((action, arg1, arg2, db_name, access), vm)?;\n                let Some(val) = val.downcast_ref::<PyInt>() else {\n                    return Ok(SQLITE_DENY);\n                };\n                val.try_to_primitive::<c_int>(vm)\n            };\n\n            f().unwrap_or(SQLITE_DENY)\n        }\n\n        unsafe extern \"C\" fn trace_callback(\n            _typ: c_uint,\n            data: *mut c_void,\n            stmt: *mut c_void,\n            sql: *mut c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let expanded = unsafe { sqlite3_expanded_sql(stmt.cast()) };\n            let f = || -> PyResult<()> {\n                let stmt = ptr_to_str(expanded, vm).or_else(|_| ptr_to_str(sql.cast(), vm))?;\n                callable.call((stmt,), vm)?;\n                Ok(())\n            };\n            let _ = f();\n            0\n        }\n\n        unsafe extern \"C\" fn progress_callback(data: *mut c_void) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            if let Ok(val) = callable.call((), vm)\n                && let Ok(val) = val.is_true(vm)\n            {\n                return val as c_int;\n            }\n            -1\n        }\n\n        fn callback_result_from_method(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let val = vm.call_method(instance, name, ())?;\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n\n        fn call_method_with_args(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            args: &[*mut sqlite3_value],\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n                vm.call_method(instance, name, args).map(drop)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n    }\n\n    impl Drop for CallbackData {\n        fn drop(&mut self) {\n            unsafe { PyObjectRef::from_raw(self.obj) };\n        }\n    }\n\n    #[pyfunction]\n    fn connect(args: ConnectArgs, vm: &VirtualMachine) -> PyResult {\n        Connection::py_new(args.factory.clone(), args, vm)\n    }\n\n    #[pyfunction]\n    fn complete_statement(statement: PyStrRef, vm: &VirtualMachine) -> PyResult<bool> {\n        let s = statement.to_cstring(vm)?;\n        let ret = unsafe { sqlite3_complete(s.as_ptr()) };\n        Ok(ret == 1)\n    }\n\n    #[pyfunction]\n    fn enable_callback_tracebacks(flag: bool) {\n        enable_traceback().store(flag, Ordering::Relaxed);\n    }\n\n    #[pyfunction]\n    fn register_adapter(typ: PyTypeRef, adapter: ArgCallable, vm: &VirtualMachine) -> PyResult<()> {\n        if typ.is(PyInt::class(&vm.ctx))\n            || typ.is(PyFloat::class(&vm.ctx))\n            || typ.is(PyStr::class(&vm.ctx))\n            || typ.is(PyByteArray::class(&vm.ctx))\n        {\n            let _ = BASE_TYPE_ADAPTED.set(());\n        }\n        let protocol = PrepareProtocol::class(&vm.ctx).to_owned();\n        let key = vm.ctx.new_tuple(vec![typ.into(), protocol.into()]);\n        adapters().set_item(key.as_object(), adapter.into(), vm)\n    }\n\n    #[pyfunction]\n    fn register_converter(\n        typename: PyStrRef,\n        converter: ArgCallable,\n        vm: &VirtualMachine,\n    ) -> PyResult<()> {\n        let name = typename.as_str().to_uppercase();\n        converters().set_item(&name, converter.into(), vm)\n    }\n\n    fn _adapt<F>(obj: &PyObject, proto: PyTypeRef, alt: F, vm: &VirtualMachine) -> PyResult\n    where\n        F: FnOnce(&PyObject) -> PyResult,\n    {\n        let proto = proto.into_object();\n        let key = vm\n            .ctx\n            .new_tuple(vec![obj.class().to_owned().into(), proto.clone()]);\n\n        if let Some(adapter) = adapters().get_item_opt(key.as_object(), vm)? {\n            return adapter.call((obj,), vm);\n        }\n        if let Ok(adapter) = proto.get_attr(\"__adapt__\", vm) {\n            match adapter.call((obj,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n        if let Ok(adapter) = obj.get_attr(\"__conform__\", vm) {\n            match adapter.call((proto,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n\n        alt(obj)\n    }\n\n    #[pyfunction]\n    fn adapt(\n        obj: PyObjectRef,\n        proto: OptionalArg<Option<PyTypeRef>>,\n        alt: OptionalArg<PyObjectRef>,\n        vm: &VirtualMachine,\n    ) -> PyResult {\n        if matches!(proto, OptionalArg::Present(None)) {\n            return if let OptionalArg::Present(alt) = alt {\n                Ok(alt)\n            } else {\n                Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n            };\n        }\n\n        let proto = proto\n            .flatten()\n            .unwrap_or_else(|| PrepareProtocol::class(&vm.ctx).to_owned());\n\n        _adapt(\n            &obj,\n            proto,\n            |_| {\n                if let OptionalArg::Present(alt) = alt {\n                    Ok(alt)\n                } else {\n                    Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n                }\n            },\n            vm,\n        )\n    }\n\n    fn need_adapt(obj: &PyObject, vm: &VirtualMachine) -> bool {\n        if BASE_TYPE_ADAPTED.get().is_some() {\n            true\n        } else {\n            let cls = obj.class();\n            !(cls.is(vm.ctx.types.int_type)\n                || cls.is(vm.ctx.types.float_type)\n                || cls.is(vm.ctx.types.str_type)\n                || cls.is(vm.ctx.types.bytearray_type))\n        }\n    }\n\n    static_cell! {\n        static CONVERTERS: PyDictRef;\n        static ADAPTERS: PyDictRef;\n        static BASE_TYPE_ADAPTED: ();\n        static USER_FUNCTION_EXCEPTION: PyAtomicRef<Option<PyBaseException>>;\n        static ENABLE_TRACEBACK: PyAtomic<bool>;\n    }\n\n    fn converters() -> &'static Py<PyDict> {\n        CONVERTERS.get().expect(\"converters not initialize\")\n    }\n\n    fn adapters() -> &'static Py<PyDict> {\n        ADAPTERS.get().expect(\"adapters not initialize\")\n    }\n\n    fn user_function_exception() -> &'static PyAtomicRef<Option<PyBaseException>> {\n        USER_FUNCTION_EXCEPTION\n            .get()\n            .expect(\"user function exception not initialize\")\n    }\n\n    fn enable_traceback() -> &'static PyAtomic<bool> {\n        ENABLE_TRACEBACK\n            .get()\n            .expect(\"enable traceback not initialize\")\n    }\n\n    pub(super) fn setup_module(module: &PyObject, vm: &VirtualMachine) {\n        for (name, code) in ERROR_CODES {\n            let name = vm.ctx.intern_str(*name);\n            let code = vm.new_pyobj(*code);\n            module.set_attr(name, code, vm).unwrap();\n        }\n\n        setup_module_exceptions(module, vm);\n\n        let _ = CONVERTERS.set(vm.ctx.new_dict());\n        let _ = ADAPTERS.set(vm.ctx.new_dict());\n        let _ = USER_FUNCTION_EXCEPTION.set(PyAtomicRef::from(None));\n        let _ = ENABLE_TRACEBACK.set(Radium::new(false));\n\n        module\n            .set_attr(\"converters\", converters().to_owned(), vm)\n            .unwrap();\n        module\n            .set_attr(\"adapters\", adapters().to_owned(), vm)\n            .unwrap();\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(PyPayload)]\n    struct Connection {\n        db: PyMutex<Option<Sqlite>>,\n        initialized: PyAtomic<bool>,\n        detect_types: PyAtomic<c_int>,\n        isolation_level: PyAtomicRef<Option<PyStr>>,\n        check_same_thread: PyAtomic<bool>,\n        thread_ident: PyMutex<ThreadId>,\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        text_factory: PyAtomicRef<PyObject>,\n    }\n\n    impl Debug for Connection {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"Sqlite3 Connection\")\n        }\n    }\n\n    impl Constructor for Connection {\n        type Args = ConnectArgs;\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n\n            // For non-subclassed Connection, initialize in __new__\n            // For subclassed Connection, leave db as None and require __init__ to be called\n            let is_base_class = cls.is(Connection::class(&vm.ctx).as_object());\n\n            let mut db = if is_base_class {\n                // Initialize immediately for base class\n                Some(Connection::initialize_db(&args, vm)?)\n            } else {\n                // For subclasses, require __init__ to be called\n                None\n            };\n\n            let initialized = db.is_some();\n\n            let conn = Self {\n                db: PyMutex::new(db.take()),\n                initialized: Radium::new(initialized),\n                detect_types: Radium::new(args.detect_types),\n                isolation_level: PyAtomicRef::from(args.isolation_level),\n                check_same_thread: Radium::new(args.check_same_thread),\n                thread_ident: PyMutex::new(std::thread::current().id()),\n                row_factory: PyAtomicRef::from(None),\n                text_factory: PyAtomicRef::from(text_factory),\n            };\n\n            Ok(conn.into_ref_with_type(vm, cls)?.into())\n        }\n    }\n\n    impl Callable for Connection {\n        type Args = FuncArgs;\n\n        fn call(zelf: &Py<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let _ = zelf.db_lock(vm)?;\n\n            let (sql,): (PyUtf8StrRef,) = args.bind(vm)?;\n\n            if let Some(stmt) = Statement::new(zelf, sql, vm)? {\n                Ok(stmt.into_ref(&vm.ctx).into())\n            } else {\n                Ok(vm.ctx.none())\n            }\n        }\n    }\n\n    impl Initializer for Connection {\n        type Args = ConnectArgs;\n\n        fn init(zelf: PyRef<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult<()> {\n            let was_initialized = zelf.initialized.swap(false, Ordering::Relaxed);\n\n            // Reset factories to their defaults, matching CPython's behavior.\n            zelf.reset_factories(vm);\n\n            if was_initialized {\n                zelf.drop_db();\n            }\n\n            // Attempt to open the new database before mutating other state so failures leave\n            // the connection uninitialized (and subsequent operations raise ProgrammingError).\n            let db = Self::initialize_db(&args, vm)?;\n\n            let ConnectArgs {\n                detect_types,\n                isolation_level,\n                check_same_thread,\n                ..\n            } = args;\n\n            zelf.detect_types.store(detect_types, Ordering::Relaxed);\n            zelf.check_same_thread\n                .store(check_same_thread, Ordering::Relaxed);\n            *zelf.thread_ident.lock() = std::thread::current().id();\n            let _ = unsafe { zelf.isolation_level.swap(isolation_level) };\n\n            let mut guard = zelf.db.lock();\n            *guard = Some(db);\n            zelf.initialized.store(true, Ordering::Relaxed);\n            Ok(())\n        }\n    }\n\n    #[pyclass(with(Constructor, Callable, Initializer), flags(BASETYPE))]\n    impl Connection {\n        fn drop_db(&self) {\n            self.db.lock().take();\n        }\n\n        fn reset_factories(&self, vm: &VirtualMachine) {\n            let default_text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n            let _ = unsafe { self.row_factory.swap(None) };\n            let _ = unsafe { self.text_factory.swap(default_text_factory) };\n        }\n\n        fn initialize_db(args: &ConnectArgs, vm: &VirtualMachine) -> PyResult<Sqlite> {\n            let path = args.database.to_cstring(vm)?;\n            let db = Sqlite::from(SqliteRaw::open(path.as_ptr(), args.uri, vm)?);\n            let timeout = (args.timeout * 1000.0) as c_int;\n            db.busy_timeout(timeout);\n            if let Some(isolation_level) = &args.isolation_level {\n                begin_statement_ptr_from_isolation_level(isolation_level, vm)?;\n            }\n            Ok(db)\n        }\n\n        fn db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            self.check_thread(vm)?;\n            self._db_lock(vm)\n        }\n\n        fn _db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            let guard = self.db.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Connection.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn cursor(\n            zelf: PyRef<Self>,\n            factory: OptionalArg<ArgCallable>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            zelf.db_lock(vm).map(drop)?;\n\n            let cursor = if let OptionalArg::Present(factory) = factory {\n                let cursor = factory.invoke((zelf.clone(),), vm)?;\n                let cursor = cursor.downcast::<Cursor>().map_err(|x| {\n                    vm.new_type_error(format!(\"factory must return a cursor, not {}\", x.class()))\n                })?;\n                let _ = unsafe { cursor.row_factory.swap(zelf.row_factory.to_owned()) };\n                cursor\n            } else {\n                let row_factory = zelf.row_factory.to_owned();\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx)\n            };\n            Ok(cursor)\n        }\n\n        #[pymethod]\n        fn blobopen(\n            zelf: PyRef<Self>,\n            args: BlobOpenArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Blob>> {\n            let table = args.table.to_cstring(vm)?;\n            let column = args.column.to_cstring(vm)?;\n            let name = args.name.to_cstring(vm)?;\n\n            let db = zelf.db_lock(vm)?;\n\n            let mut blob = null_mut();\n            let ret = unsafe {\n                sqlite3_blob_open(\n                    db.db,\n                    name.as_ptr(),\n                    table.as_ptr(),\n                    column.as_ptr(),\n                    args.row,\n                    (!args.readonly) as c_int,\n                    &mut blob,\n                )\n            };\n            db.check(ret, vm)?;\n            drop(db);\n\n            let blob = SqliteBlob { blob };\n            let blob = Blob {\n                connection: zelf,\n                inner: PyMutex::new(Some(BlobInner { blob, offset: 0 })),\n            };\n            Ok(blob.into_ref(&vm.ctx))\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.check_thread(vm)?;\n            self.drop_db();\n            Ok(())\n        }\n\n        #[pymethod]\n        fn commit(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.db_lock(vm)?.implicit_commit(vm)\n        }\n\n        #[pymethod]\n        fn rollback(&self, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            if !db.is_autocommit() {\n                db._exec(b\"ROLLBACK\\0\", vm)\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::execute(cursor, sql, parameters, vm)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::executemany(cursor, sql, seq_of_params, vm)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            Cursor::executescript(\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx),\n                script,\n                vm,\n            )\n        }\n\n        // TODO: Make it build without clippy::manual_c_str_literals\n        #[pymethod]\n        #[allow(clippy::manual_c_str_literals)]\n        fn backup(zelf: &Py<Self>, args: BackupArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let BackupArgs {\n                target,\n                pages,\n                progress,\n                name,\n                sleep,\n            } = args;\n            if zelf.is(&target) {\n                return Err(vm.new_value_error(\"target cannot be the same connection instance\"));\n            }\n\n            let pages = if pages == 0 { -1 } else { pages };\n\n            let name_cstring;\n            let name_ptr = if let Some(name) = &name {\n                name_cstring = name.to_cstring(vm)?;\n                name_cstring.as_ptr()\n            } else {\n                b\"main\\0\".as_ptr().cast()\n            };\n\n            let sleep_ms = (sleep * 1000.0) as c_int;\n\n            let db = zelf.db_lock(vm)?;\n            let target_db = target.db_lock(vm)?;\n\n            let handle = unsafe {\n                sqlite3_backup_init(target_db.db, b\"main\\0\".as_ptr().cast(), db.db, name_ptr)\n            };\n\n            if handle.is_null() {\n                return Err(target_db.error_extended(vm));\n            }\n\n            drop(db);\n            drop(target_db);\n\n            loop {\n                let ret = unsafe { sqlite3_backup_step(handle, pages) };\n\n                if let Some(progress) = &progress {\n                    let remaining = unsafe { sqlite3_backup_remaining(handle) };\n                    let pagecount = unsafe { sqlite3_backup_pagecount(handle) };\n                    if let Err(err) = progress.invoke((ret, remaining, pagecount), vm) {\n                        unsafe { sqlite3_backup_finish(handle) };\n                        return Err(err);\n                    }\n                }\n\n                if ret == SQLITE_BUSY || ret == SQLITE_LOCKED {\n                    unsafe { sqlite3_sleep(sleep_ms) };\n                } else if ret != SQLITE_OK {\n                    break;\n                }\n            }\n\n            let ret = unsafe { sqlite3_backup_finish(handle) };\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(target.db_lock(vm)?.error_extended(vm))\n            }\n        }\n\n        #[pymethod]\n        fn create_function(&self, args: CreateFunctionArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let flags = if args.deterministic {\n                SQLITE_UTF8 | SQLITE_DETERMINISTIC\n            } else {\n                SQLITE_UTF8\n            };\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.func, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    flags,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                flags,\n                Box::into_raw(Box::new(data)).cast(),\n                Some(CallbackData::func_callback),\n                None,\n                None,\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_aggregate(&self, args: CreateAggregateArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.aggregate_class, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    SQLITE_UTF8,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                SQLITE_UTF8,\n                Box::into_raw(Box::new(data)).cast(),\n                None,\n                Some(CallbackData::step_callback),\n                Some(CallbackData::finalize_callback),\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_collation(\n            &self,\n            name: PyUtf8StrRef,\n            callable: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable.clone(), vm) else {\n                unsafe {\n                    sqlite3_create_collation_v2(\n                        db.db,\n                        name.as_ptr(),\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                    );\n                }\n                return Ok(());\n            };\n            let data = Box::into_raw(Box::new(data));\n\n            if !callable.is_callable() {\n                return Err(vm.new_type_error(\"parameter must be callable\"));\n            }\n\n            let ret = unsafe {\n                sqlite3_create_collation_v2(\n                    db.db,\n                    name.as_ptr(),\n                    SQLITE_UTF8,\n                    data.cast(),\n                    Some(CallbackData::collation_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n\n            db.check(ret, vm).inspect_err(|_| {\n                // create_collation do not call destructor if error occur\n                let _ = unsafe { Box::from_raw(data) };\n            })\n        }\n\n        #[pymethod]\n        fn create_window_function(\n            &self,\n            name: PyStrRef,\n            narg: c_int,\n            aggregate_class: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(aggregate_class, vm) else {\n                unsafe {\n                    sqlite3_create_window_function(\n                        db.db,\n                        name.as_ptr(),\n                        narg,\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                        None,\n                        None,\n                        None,\n                    )\n                };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_create_window_function(\n                    db.db,\n                    name.as_ptr(),\n                    narg,\n                    SQLITE_UTF8,\n                    Box::into_raw(Box::new(data)).cast(),\n                    Some(CallbackData::step_callback),\n                    Some(CallbackData::finalize_callback),\n                    Some(CallbackData::value_callback),\n                    Some(CallbackData::inverse_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n            db.check(ret, vm)\n                .map_err(|_| new_programming_error(vm, \"Error creating window function\".to_owned()))\n        }\n\n        #[pymethod]\n        fn set_authorizer(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_set_authorizer(db.db, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_set_authorizer(\n                    db.db,\n                    Some(CallbackData::authorizer_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n            db.check(ret, vm).map_err(|_| {\n                new_operational_error(vm, \"Error setting authorizer callback\".to_owned())\n            })\n        }\n\n        #[pymethod]\n        fn set_trace_callback(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_trace_v2(db.db, SQLITE_TRACE_STMT as u32, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_trace_v2(\n                    db.db,\n                    SQLITE_TRACE_STMT as u32,\n                    Some(CallbackData::trace_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            db.check(ret, vm)\n        }\n\n        #[pymethod]\n        fn set_progress_handler(\n            &self,\n            callable: PyObjectRef,\n            n: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_progress_handler(db.db, n, None, null_mut()) };\n                return Ok(());\n            };\n\n            unsafe {\n                sqlite3_progress_handler(\n                    db.db,\n                    n,\n                    Some(CallbackData::progress_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            Ok(())\n        }\n\n        #[pymethod]\n        fn iterdump(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            let module = vm.import(\"sqlite3.dump\", 0)?;\n            let func = module.get_attr(\"_iterdump\", vm)?;\n            func.call((zelf,), vm)\n        }\n\n        #[pymethod]\n        fn interrupt(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // DO NOT check thread safety\n            self._db_lock(vm).map(|x| x.interrupt())\n        }\n\n        #[pymethod]\n        fn getlimit(&self, category: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, -1, vm)\n        }\n\n        #[pymethod]\n        fn setlimit(&self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, limit, vm)\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>) -> PyRef<Self> {\n            zelf\n        }\n\n        #[pymethod]\n        fn __exit__(\n            &self,\n            cls: PyObjectRef,\n            exc: PyObjectRef,\n            tb: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            if vm.is_none(&cls) && vm.is_none(&exc) && vm.is_none(&tb) {\n                self.commit(vm)\n            } else {\n                self.rollback(vm)\n            }\n        }\n\n        #[pygetset]\n        fn isolation_level(&self) -> Option<PyStrRef> {\n            self.isolation_level.deref().map(|x| x.to_owned())\n        }\n        #[pygetset(setter)]\n        fn set_isolation_level(\n            &self,\n            value: PySetterValue<Option<PyStrRef>>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            match value {\n                PySetterValue::Assign(value) => {\n                    if let Some(val_str) = &value {\n                        begin_statement_ptr_from_isolation_level(val_str, vm)?;\n                    }\n\n                    // If setting isolation_level to None (auto-commit mode), commit any pending transaction\n                    if value.is_none() {\n                        let db = self.db_lock(vm)?;\n                        if !db.is_autocommit() {\n                            // Keep the lock and call implicit_commit directly to avoid race conditions\n                            db.implicit_commit(vm)?;\n                        }\n                    }\n                    let _ = unsafe { self.isolation_level.swap(value) };\n                    Ok(())\n                }\n                PySetterValue::Delete => Err(vm.new_attribute_error(\n                    \"'isolation_level' attribute cannot be deleted\".to_owned(),\n                )),\n            }\n        }\n\n        #[pygetset]\n        fn text_factory(&self) -> PyObjectRef {\n            self.text_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_text_factory(&self, val: PyObjectRef) {\n            let _ = unsafe { self.text_factory.swap(val) };\n        }\n\n        #[pygetset]\n        fn row_factory(&self) -> Option<PyObjectRef> {\n            self.row_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_row_factory(&self, val: Option<PyObjectRef>) {\n            let _ = unsafe { self.row_factory.swap(val) };\n        }\n\n        fn check_thread(&self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.check_same_thread.load(Ordering::Relaxed) {\n                let creator_id = *self.thread_ident.lock();\n                if std::thread::current().id() != creator_id {\n                    return Err(new_programming_error(\n                        vm,\n                        \"SQLite objects created in a thread can only be used in that same thread.\"\n                            .to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n\n        #[pygetset]\n        fn in_transaction(&self, vm: &VirtualMachine) -> PyResult<bool> {\n            self._db_lock(vm).map(|x| !x.is_autocommit())\n        }\n\n        #[pygetset]\n        fn total_changes(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self._db_lock(vm).map(|x| x.total_changes())\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Cursor {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        arraysize: PyAtomic<c_int>,\n        #[pytraverse(skip)]\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        inner: PyMutex<Option<CursorInner>>,\n    }\n\n    #[derive(Debug, Traverse)]\n    struct CursorInner {\n        description: Option<PyTupleRef>,\n        row_cast_map: Vec<Option<PyObjectRef>>,\n        #[pytraverse(skip)]\n        lastrowid: i64,\n        #[pytraverse(skip)]\n        rowcount: i64,\n        statement: Option<PyRef<Statement>>,\n        #[pytraverse(skip)]\n        closed: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct FetchManyArgs {\n        #[pyarg(any, name = \"size\", optional)]\n        size: Option<c_int>,\n    }\n\n    #[pyclass(with(Constructor, IterNext, Iterable), flags(BASETYPE))]\n    impl Cursor {\n        fn new(\n            connection: PyRef<Connection>,\n            row_factory: Option<PyObjectRef>,\n            _vm: &VirtualMachine,\n        ) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(row_factory),\n                inner: PyMutex::from(Some(CursorInner {\n                    description: None,\n                    row_cast_map: vec![],\n                    lastrowid: -1,\n                    rowcount: -1,\n                    statement: None,\n                    closed: false,\n                })),\n            }\n        }\n\n        fn new_uninitialized(connection: PyRef<Connection>, _vm: &VirtualMachine) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(None),\n                inner: PyMutex::from(None),\n            }\n        }\n\n        #[pymethod]\n        fn __init__(&self, _connection: PyRef<Connection>, _vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = self.inner.lock();\n            if guard.is_some() {\n                // Already initialized (e.g., from a call to super().__init__)\n                return Ok(());\n            }\n            *guard = Some(CursorInner {\n                description: None,\n                row_cast_map: vec![],\n                lastrowid: -1,\n                rowcount: -1,\n                statement: None,\n                closed: false,\n            });\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, CursorInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                let inner_guard =\n                    PyMutexGuard::map(guard, |x| unsafe { x.as_mut().unwrap_unchecked() });\n                if inner_guard.closed {\n                    return Err(new_programming_error(\n                        vm,\n                        \"Cannot operate on a closed cursor.\".to_owned(),\n                    ));\n                }\n                Ok(inner_guard)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let st = stmt.lock();\n            let params_needed = st.bind_parameter_count();\n\n            if let OptionalArg::Present(parameters) = parameters {\n                st.bind_parameters(&parameters, vm)?;\n            } else if params_needed > 0 {\n                let msg = format!(\n                    \"Incorrect number of bindings supplied. The current statement uses {}, and 0 were supplied.\",\n                    params_needed\n                );\n                return Err(new_programming_error(vm, msg));\n            }\n\n            let ret = st.step();\n\n            if ret != SQLITE_DONE && ret != SQLITE_ROW {\n                if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                    return Err(exc);\n                }\n                return Err(db.error_extended(vm));\n            }\n\n            inner.row_cast_map = zelf.build_row_cast_map(&st, vm)?;\n\n            let detect_types = zelf.connection.detect_types.load(Ordering::Relaxed);\n            inner.description = st.columns_description(detect_types, vm)?;\n\n            if ret == SQLITE_ROW {\n                drop(st);\n                inner.statement = Some(stmt);\n            } else {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount += db.changes() as i64;\n                }\n            }\n\n            inner.lastrowid = db.lastrowid();\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            let st = stmt.lock();\n\n            if st.readonly() {\n                return Err(new_programming_error(\n                    vm,\n                    \"executemany() can only execute DML statements.\".to_owned(),\n                ));\n            }\n\n            let detect_types = zelf.connection.detect_types.load(Ordering::Relaxed);\n            inner.description = st.columns_description(detect_types, vm)?;\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let iter = seq_of_params.iter(vm)?;\n            for params in iter {\n                let params = params?;\n                st.bind_parameters(&params, vm)?;\n\n                if !st.step_row_else_done(vm)? {\n                    if stmt.is_dml {\n                        inner.rowcount += db.changes() as i64;\n                    }\n                    st.reset();\n                }\n\n                // if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                //     return Err(exc);\n                // }\n            }\n\n            if st.busy() {\n                drop(st);\n                inner.statement = Some(stmt);\n            }\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let db = zelf.connection.db_lock(vm)?;\n\n            db.sql_limit(script.byte_len(), vm)?;\n\n            db.implicit_commit(vm)?;\n\n            let script = script.to_cstring(vm)?;\n            let mut ptr = script.as_ptr();\n\n            while let Some(st) = db.prepare(ptr, &mut ptr, vm)? {\n                while st.step_row_else_done(vm)? {}\n            }\n\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn fetchone(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult {\n            Self::next(zelf, vm).map(|x| match x {\n                PyIterReturn::Return(row) => row,\n                PyIterReturn::StopIteration(_) => vm.ctx.none(),\n            })\n        }\n\n        #[pymethod]\n        fn fetchmany(\n            zelf: &Py<Self>,\n            args: FetchManyArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<PyObjectRef>> {\n            let max_rows = args\n                .size\n                .unwrap_or_else(|| zelf.arraysize.load(Ordering::Relaxed));\n\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Cursor::next(zelf, vm)? {\n                list.push(row);\n                if max_rows > 0 && list.len() as c_int >= max_rows {\n                    break;\n                }\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn fetchall(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Self::next(zelf, vm)? {\n                list.push(row);\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // Check if __init__ was called\n            let mut guard = self.inner.lock();\n            if guard.is_none() {\n                return Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ));\n            }\n\n            if let Some(inner) = guard.as_mut() {\n                if let Some(stmt) = &inner.statement {\n                    stmt.lock().reset();\n                }\n                inner.closed = true;\n            }\n            Ok(())\n        }\n\n        #[pymethod]\n        fn setinputsizes(&self, _sizes: PyObjectRef) {}\n        #[pymethod]\n        fn setoutputsize(&self, _size: PyObjectRef, _column: OptionalArg<PyObjectRef>) {}\n\n        #[pygetset]\n        fn connection(&self) -> PyRef<Connection> {\n            self.connection.clone()\n        }\n\n        #[pygetset]\n        fn lastrowid(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.lastrowid)\n        }\n\n        #[pygetset]\n        fn rowcount(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.rowcount)\n        }\n\n        #[pygetset]\n        fn description(&self, vm: &VirtualMachine) -> PyResult<Option<PyTupleRef>> {\n            self.inner(vm).map(|x| x.description.clone())\n        }\n\n        #[pygetset]\n        fn arraysize(&self) -> c_int {\n            self.arraysize.load(Ordering::Relaxed)\n        }\n        #[pygetset(setter)]\n        fn set_arraysize(&self, val: c_int) {\n            self.arraysize.store(val, Ordering::Relaxed);\n        }\n\n        fn build_row_cast_map(\n            &self,\n            st: &SqliteStatementRaw,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<Option<PyObjectRef>>> {\n            let detect_types = self.connection.detect_types.load(Ordering::Relaxed);\n            if detect_types == 0 {\n                return Ok(vec![]);\n            }\n\n            let mut cast_map = vec![];\n            let num_cols = st.column_count();\n\n            for i in 0..num_cols {\n                if detect_types & PARSE_COLNAMES != 0 {\n                    let col_name = st.column_name(i);\n                    let col_name = ptr_to_str(col_name, vm)?;\n                    let col_name = col_name\n                        .chars()\n                        .skip_while(|&x| x != '[')\n                        .skip(1)\n                        .take_while(|&x| x != ']')\n                        .flat_map(|x| x.to_uppercase())\n                        .collect::<String>();\n                    if let Some(converter) = converters().get_item_opt(&col_name, vm)? {\n                        cast_map.push(Some(converter.clone()));\n                        continue;\n                    }\n                }\n                if detect_types & PARSE_DECLTYPES != 0 {\n                    let decltype = st.column_decltype(i);\n                    let decltype = ptr_to_str(decltype, vm)?;\n                    if let Some(decltype) = decltype.split_terminator(&[' ', '(']).next() {\n                        let decltype = decltype.to_uppercase();\n                        if let Some(converter) = converters().get_item_opt(&decltype, vm)? {\n                            cast_map.push(Some(converter.clone()));\n                            continue;\n                        }\n                    }\n                }\n                cast_map.push(None);\n            }\n\n            Ok(cast_map)\n        }\n    }\n\n    impl Constructor for Cursor {\n        type Args = (PyRef<Connection>,);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            Self::new_uninitialized(args.0, vm)\n                .into_ref_with_type(vm, cls)\n                .map(Into::into)\n        }\n    }\n\n    impl SelfIter for Cursor {}\n    impl IterNext for Cursor {\n        fn next(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyIterReturn> {\n            let mut inner = zelf.inner(vm)?;\n            let Some(stmt) = &inner.statement else {\n                return Ok(PyIterReturn::StopIteration(None));\n            };\n            let st = stmt.lock();\n            let db = zelf.connection.db_lock(vm)?;\n            // fetch_one_row\n\n            let num_cols = st.data_count();\n\n            let mut row = Vec::with_capacity(num_cols as usize);\n\n            for i in 0..num_cols {\n                let val = if let Some(converter) =\n                    inner.row_cast_map.get(i as usize).cloned().flatten()\n                {\n                    let blob = st.column_blob(i);\n                    if blob.is_null() {\n                        vm.ctx.none()\n                    } else {\n                        let nbytes = st.column_bytes(i);\n                        let blob = unsafe {\n                            std::slice::from_raw_parts(blob.cast::<u8>(), nbytes as usize)\n                        };\n                        let blob = vm.ctx.new_bytes(blob.to_vec());\n                        converter.call((blob,), vm)?\n                    }\n                } else {\n                    let col_type = st.column_type(i);\n                    match col_type {\n                        SQLITE_NULL => vm.ctx.none(),\n                        SQLITE_INTEGER => vm.ctx.new_int(st.column_int(i)).into(),\n                        SQLITE_FLOAT => vm.ctx.new_float(st.column_double(i)).into(),\n                        SQLITE_TEXT => {\n                            let text =\n                                ptr_to_vec(st.column_text(i), st.column_bytes(i), db.db, vm)?;\n\n                            let text_factory = zelf.connection.text_factory.to_owned();\n\n                            if text_factory.is(PyStr::class(&vm.ctx)) {\n                                let text = String::from_utf8(text).map_err(|err| {\n                                    let col_name = st.column_name(i);\n                                    let col_name_str = ptr_to_str(col_name, vm).unwrap_or(\"?\");\n                                    let valid_up_to = err.utf8_error().valid_up_to();\n                                    let text_prefix = String::from_utf8_lossy(&err.as_bytes()[..valid_up_to]);\n                                    let msg = format!(\n                                        \"Could not decode to UTF-8 column '{col_name_str}' with text '{text_prefix}'\"\n                                    );\n                                    new_operational_error(vm, msg)\n                                })?;\n                                vm.ctx.new_str(text).into()\n                            } else if text_factory.is(PyBytes::class(&vm.ctx)) {\n                                vm.ctx.new_bytes(text).into()\n                            } else if text_factory.is(PyByteArray::class(&vm.ctx)) {\n                                PyByteArray::from(text).into_ref(&vm.ctx).into()\n                            } else {\n                                let bytes = vm.ctx.new_bytes(text);\n                                text_factory.call((bytes,), vm)?\n                            }\n                        }\n                        SQLITE_BLOB => {\n                            let blob = ptr_to_vec(\n                                st.column_blob(i).cast(),\n                                st.column_bytes(i),\n                                db.db,\n                                vm,\n                            )?;\n\n                            vm.ctx.new_bytes(blob).into()\n                        }\n                        _ => {\n                            return Err(vm.new_not_implemented_error(format!(\n                                \"unknown column type: {col_type}\"\n                            )));\n                        }\n                    }\n                };\n\n                row.push(val);\n            }\n\n            if !st.step_row_else_done(vm)? {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount = db.changes() as i64;\n                }\n                inner.statement = None;\n            } else {\n                drop(st);\n            }\n\n            drop(db);\n            drop(inner);\n\n            let row = vm.ctx.new_tuple(row);\n\n            if let Some(row_factory) = zelf.row_factory.to_owned() {\n                row_factory\n                    .call((zelf.to_owned(), row), vm)\n                    .map(PyIterReturn::Return)\n            } else {\n                Ok(PyIterReturn::Return(row.into()))\n            }\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Row {\n        data: PyTupleRef,\n        description: PyTupleRef,\n    }\n\n    #[pyclass(\n        with(Constructor, Hashable, Comparable, Iterable, AsMapping, AsSequence),\n        flags(BASETYPE)\n    )]\n    impl Row {\n        #[pymethod]\n        fn keys(&self, _vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            Ok(self\n                .description\n                .iter()\n                .map(|x| x.downcast_ref::<PyTuple>().unwrap().as_slice()[0].clone())\n                .collect())\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            if let Some(i) = needle.downcast_ref::<PyInt>() {\n                let i = i.try_to_primitive::<isize>(vm)?;\n                self.data.getitem_by_index(vm, i)\n            } else if let Some(name) = needle.downcast_ref::<PyStr>() {\n                for (obj, i) in self.description.iter().zip(0..) {\n                    let obj = &obj.downcast_ref::<PyTuple>().unwrap().as_slice()[0];\n                    let Some(obj) = obj.downcast_ref::<PyStr>() else {\n                        break;\n                    };\n                    let a_iter = name.as_str().chars().flat_map(|x| x.to_uppercase());\n                    let b_iter = obj.as_str().chars().flat_map(|x| x.to_uppercase());\n\n                    if a_iter.eq(b_iter) {\n                        return self.data.getitem_by_index(vm, i);\n                    }\n                }\n                Err(vm.new_index_error(\"No item with that key\"))\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let list = self.data.getitem_by_slice(vm, slice.to_saturated(vm)?)?;\n                Ok(vm.ctx.new_tuple(list).into())\n            } else {\n                Err(vm.new_index_error(\"Index must be int or string\"))\n            }\n        }\n    }\n\n    impl Constructor for Row {\n        type Args = (PyRef<Cursor>, PyTupleRef);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let description = args\n                .0\n                .inner(vm)?\n                .description\n                .clone()\n                .ok_or_else(|| vm.new_value_error(\"no description in Cursor\"))?;\n\n            Self {\n                data: args.1,\n                description,\n            }\n            .into_ref_with_type(vm, cls)\n            .map(Into::into)\n        }\n    }\n\n    impl Hashable for Row {\n        fn hash(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyHash> {\n            Ok(zelf.description.as_object().hash(vm)? | zelf.data.as_object().hash(vm)?)\n        }\n    }\n\n    impl Comparable for Row {\n        fn cmp(\n            zelf: &Py<Self>,\n            other: &PyObject,\n            op: PyComparisonOp,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyComparisonValue> {\n            op.eq_only(|| {\n                if let Some(other) = other.downcast_ref::<Self>() {\n                    let eq = vm\n                        .bool_eq(zelf.description.as_object(), other.description.as_object())?\n                        && vm.bool_eq(zelf.data.as_object(), other.data.as_object())?;\n                    Ok(eq.into())\n                } else {\n                    Ok(PyComparisonValue::NotImplemented)\n                }\n            })\n        }\n    }\n\n    impl Iterable for Row {\n        fn iter(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            Iterable::iter(zelf.data.clone(), vm)\n        }\n    }\n\n    impl AsMapping for Row {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: std::sync::LazyLock<PyMappingMethods> =\n                std::sync::LazyLock::new(|| PyMappingMethods {\n                    length: atomic_func!(|mapping, _vm| Ok(Row::mapping_downcast(mapping)\n                        .data\n                        .len())),\n                    subscript: atomic_func!(|mapping, needle, vm| {\n                        Row::mapping_downcast(mapping).subscript(needle, vm)\n                    }),\n                    ..PyMappingMethods::NOT_IMPLEMENTED\n                });\n            &AS_MAPPING\n        }\n    }\n\n    impl AsSequence for Row {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: std::sync::LazyLock<PySequenceMethods> =\n                std::sync::LazyLock::new(|| PySequenceMethods {\n                    length: atomic_func!(|seq, _vm| Ok(Row::sequence_downcast(seq).data.len())),\n                    item: atomic_func!(|seq, i, vm| Row::sequence_downcast(seq)\n                        .data\n                        .getitem_by_index(vm, i)),\n                    ..PySequenceMethods::NOT_IMPLEMENTED\n                });\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Blob\", traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Blob {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        inner: PyMutex<Option<BlobInner>>,\n    }\n\n    impl Unconstructible for Blob {}\n\n    #[derive(Debug)]\n    struct BlobInner {\n        blob: SqliteBlob,\n        offset: c_int,\n    }\n\n    impl Drop for BlobInner {\n        fn drop(&mut self) {\n            unsafe { sqlite3_blob_close(self.blob.blob) };\n        }\n    }\n\n    #[pyclass(with(AsMapping, Unconstructible, AsNumber, AsSequence))]\n    impl Blob {\n        #[pymethod]\n        fn close(&self) {\n            self.inner.lock().take();\n        }\n\n        #[pymethod]\n        fn read(\n            &self,\n            length: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<PyBytes>> {\n            let mut length = length.unwrap_or(-1);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let max_read = blob_len - inner.offset;\n\n            if length < 0 || length > max_read {\n                length = max_read;\n            }\n\n            if length == 0 {\n                Ok(vm.ctx.empty_bytes.clone())\n            } else {\n                let mut buf = Vec::<u8>::with_capacity(length as usize);\n                let ret = inner\n                    .blob\n                    .read(buf.as_mut_ptr().cast(), length, inner.offset);\n                self.check(ret, vm)?;\n                unsafe { buf.set_len(length as usize) };\n                inner.offset += length;\n                Ok(vm.ctx.new_bytes(buf))\n            }\n        }\n\n        #[pymethod]\n        fn write(&self, data: PyBuffer, vm: &VirtualMachine) -> PyResult<()> {\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let length = Self::expect_write(blob_len, data.desc.len, inner.offset, vm)?;\n\n            let ret = data.contiguous_or_collect(|buf| {\n                inner.blob.write(buf.as_ptr().cast(), length, inner.offset)\n            });\n\n            self.check(ret, vm)?;\n            inner.offset += length;\n            Ok(())\n        }\n\n        #[pymethod]\n        fn tell(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.inner(vm).map(|x| x.offset)\n        }\n\n        #[pymethod]\n        fn seek(\n            &self,\n            mut offset: c_int,\n            origin: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let origin = origin.unwrap_or(libc::SEEK_SET);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n\n            let overflow_err = || vm.new_overflow_error(\"seek offset results in overflow\");\n\n            match origin {\n                libc::SEEK_SET => {}\n                libc::SEEK_CUR => {\n                    offset = offset.checked_add(inner.offset).ok_or_else(overflow_err)?\n                }\n                libc::SEEK_END => offset = offset.checked_add(blob_len).ok_or_else(overflow_err)?,\n                _ => {\n                    return Err(vm.new_value_error(\n                        \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\",\n                    ));\n                }\n            }\n\n            if offset < 0 || offset > blob_len {\n                Err(vm.new_value_error(\"offset out of blob range\"))\n            } else {\n                inner.offset = offset;\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult<PyRef<Self>> {\n            let _ = zelf.inner(vm)?;\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn __exit__(&self, _args: FuncArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let _ = self.inner(vm)?;\n            self.close();\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, BlobInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Cannot operate on a closed blob.\".to_owned(),\n                ))\n            }\n        }\n\n        fn wrapped_index(index: PyIntRef, length: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let mut index = index.try_to_primitive::<c_int>(vm)?;\n            if index < 0 {\n                index += length;\n            }\n            if index < 0 || index >= length {\n                Err(vm.new_index_error(\"Blob index out of range\"))\n            } else {\n                Ok(index)\n            }\n        }\n\n        fn expect_write(\n            blob_len: c_int,\n            length: usize,\n            offset: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<c_int> {\n            let max_write = blob_len - offset;\n            if length <= max_write as usize {\n                Ok(length as c_int)\n            } else {\n                Err(vm.new_value_error(\"data longer than blob length\"))\n            }\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            let inner = self.inner(vm)?;\n            if let Some(index) = needle.try_index_opt(vm) {\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                let mut byte: u8 = 0;\n                let ret = inner.blob.read_single(&mut byte, index);\n                self.check(ret, vm).map(|_| vm.ctx.new_int(byte).into())\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, length) = slice.adjust_indices(blob_len as usize);\n                let mut buf = Vec::<u8>::with_capacity(length);\n\n                if step == 1 {\n                    let ret = inner.blob.read(\n                        buf.as_mut_ptr().cast(),\n                        length as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n                    unsafe { buf.set_len(length) };\n                } else {\n                    let iter = SaturatedSliceIter::from_adjust_indices(range, step, length);\n                    let mut byte: u8 = 0;\n                    for index in iter {\n                        let ret = inner.blob.read_single(&mut byte, index as c_int);\n                        self.check(ret, vm)?;\n                        buf.push(byte);\n                    }\n                }\n                Ok(vm.ctx.new_bytes(buf).into())\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn ass_subscript(\n            &self,\n            needle: &PyObject,\n            value: Option<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(value) = value else {\n                return Err(vm.new_type_error(\"Blob doesn't support slice deletion\"));\n            };\n            let inner = self.inner(vm)?;\n\n            if let Some(index) = needle.try_index_opt(vm) {\n                // Handle single item assignment: blob[i] = b\n                let Some(value) = value.downcast_ref::<PyInt>() else {\n                    return Err(vm.new_type_error(format!(\n                        \"'{}' object cannot be interpreted as an integer\",\n                        value.class()\n                    )));\n                };\n                let value = value.try_to_primitive::<u8>(vm)?;\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                Self::expect_write(blob_len, 1, index, vm)?;\n                let ret = inner.blob.write_single(value, index);\n                self.check(ret, vm)\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                // Handle slice assignment: blob[a:b:c] = b\"...\"\n                let value_buf = PyBuffer::try_from_borrowed_object(vm, &value)?;\n\n                let buf = value_buf\n                    .as_contiguous()\n                    .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, slice_len) = slice.adjust_indices(blob_len as usize);\n\n                if step == 0 {\n                    return Err(vm.new_value_error(\"slice step cannot be zero\"));\n                }\n\n                if buf.len() != slice_len {\n                    return Err(vm.new_index_error(\"Blob slice assignment is wrong size\"));\n                }\n\n                if slice_len == 0 {\n                    return Ok(());\n                }\n\n                if step == 1 {\n                    let ret = inner.blob.write(\n                        buf.as_ptr().cast(),\n                        buf.len() as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                } else {\n                    let span_len = range.end - range.start;\n                    let mut temp_buf = vec![0u8; span_len];\n\n                    let ret = inner.blob.read(\n                        temp_buf.as_mut_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n\n                    let mut i_in_temp: usize = 0;\n                    for i_in_src in 0..slice_len {\n                        temp_buf[i_in_temp] = buf[i_in_src];\n                        i_in_temp += step as usize;\n                    }\n\n                    let ret = inner.blob.write(\n                        temp_buf.as_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                }\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn check(&self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.connection.db_lock(vm)?.error_extended(vm))\n            }\n        }\n    }\n\n    impl AsMapping for Blob {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: PyMappingMethods = PyMappingMethods {\n                length: atomic_func!(|mapping, vm| Blob::mapping_downcast(mapping)\n                    .inner(vm)\n                    .map(|x| x.blob.bytes() as usize)),\n                subscript: atomic_func!(|mapping, needle, vm| {\n                    Blob::mapping_downcast(mapping).subscript(needle, vm)\n                }),\n                ass_subscript: atomic_func!(|mapping, needle, value, vm| {\n                    Blob::mapping_downcast(mapping).ass_subscript(needle, value, vm)\n                }),\n            };\n            &AS_MAPPING\n        }\n    }\n\n    impl AsNumber for Blob {\n        fn as_number() -> &'static PyNumberMethods {\n            static AS_NUMBER: PyNumberMethods = PyNumberMethods {\n                add: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for +: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                multiply: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for *: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                ..PyNumberMethods::NOT_IMPLEMENTED\n            };\n            &AS_NUMBER\n        }\n    }\n\n    impl AsSequence for Blob {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: PySequenceMethods = PySequenceMethods {\n                length: AtomicCell::new(None),\n                concat: AtomicCell::new(None),\n                repeat: AtomicCell::new(None),\n                item: AtomicCell::new(None),\n                ass_item: AtomicCell::new(None),\n                contains: atomic_func!(|seq, _needle, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"argument of type '{}' is not iterable\",\n                        seq.obj.class().name(),\n                    )))\n                }),\n                inplace_concat: AtomicCell::new(None),\n                inplace_repeat: AtomicCell::new(None),\n            };\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(Debug, PyPayload)]\n    struct PrepareProtocol {}\n\n    #[pyclass()]\n    impl PrepareProtocol {}\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Statement\")]\n    #[derive(PyPayload)]\n    struct Statement {\n        st: PyMutex<SqliteStatement>,\n        pub is_dml: bool,\n    }\n\n    impl Debug for Statement {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(\n                f,\n                \"{} Statement\",\n                if self.is_dml { \"DML\" } else { \"Non-DML\" }\n            )\n        }\n    }\n\n    impl Unconstructible for Statement {}\n\n    #[pyclass(with(Unconstructible))]\n    impl Statement {\n        fn new(\n            connection: &Connection,\n            sql: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<Self>> {\n            if sql.as_str().contains('\\0') {\n                return Err(new_programming_error(\n                    vm,\n                    \"statement contains a null character.\".to_owned(),\n                ));\n            }\n            let sql_cstr = sql.to_cstring(vm)?;\n\n            let db = connection.db_lock(vm)?;\n\n            db.sql_limit(sql.byte_len(), vm)?;\n\n            let mut tail = null();\n            let st = db.prepare(sql_cstr.as_ptr(), &mut tail, vm)?;\n\n            let Some(st) = st else {\n                return Ok(None);\n            };\n\n            let tail = unsafe { CStr::from_ptr(tail) };\n            let tail = tail.to_bytes();\n            if lstrip_sql(tail).is_some() {\n                return Err(new_programming_error(\n                    vm,\n                    \"You can only execute one statement at a time.\".to_owned(),\n                ));\n            }\n\n            let is_dml = if let Some(head) = lstrip_sql(sql_cstr.as_bytes()) {\n                head.len() >= 6\n                    && (head[..6].eq_ignore_ascii_case(b\"insert\")\n                        || head[..6].eq_ignore_ascii_case(b\"update\")\n                        || head[..6].eq_ignore_ascii_case(b\"delete\")\n                        || (head.len() >= 7 && head[..7].eq_ignore_ascii_case(b\"replace\")))\n            } else {\n                false\n            };\n\n            Ok(Some(Self {\n                st: PyMutex::from(st),\n                is_dml,\n            }))\n        }\n\n        fn lock(&self) -> PyMutexGuard<'_, SqliteStatement> {\n            self.st.lock()\n        }\n    }\n\n    struct Sqlite {\n        raw: SqliteRaw,\n    }\n\n    impl From<SqliteRaw> for Sqlite {\n        fn from(raw: SqliteRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for Sqlite {\n        fn drop(&mut self) {\n            unsafe { sqlite3_close_v2(self.raw.db) };\n        }\n    }\n\n    impl Deref for Sqlite {\n        type Target = SqliteRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteRaw {\n        db: *mut sqlite3,\n    }\n\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"threading\")] {\n            unsafe impl Send for SqliteStatement {}\n            // unsafe impl Sync for SqliteStatement {}\n            unsafe impl Send for Sqlite {}\n            // unsafe impl Sync for Sqlite {}\n            unsafe impl Send for SqliteBlob {}\n        }\n    }\n\n    impl From<SqliteStatementRaw> for SqliteRaw {\n        fn from(stmt: SqliteStatementRaw) -> Self {\n            unsafe {\n                Self {\n                    db: sqlite3_db_handle(stmt.st),\n                }\n            }\n        }\n    }\n\n    impl SqliteRaw {\n        fn check(self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.error_extended(vm))\n            }\n        }\n\n        fn error_extended(self, vm: &VirtualMachine) -> PyBaseExceptionRef {\n            let errcode = unsafe { sqlite3_errcode(self.db) };\n            let typ = exception_type_from_errcode(errcode, vm);\n            let extended_errcode = unsafe { sqlite3_extended_errcode(self.db) };\n            let errmsg = unsafe { sqlite3_errmsg(self.db) };\n            let errmsg = unsafe { CStr::from_ptr(errmsg) };\n            let errmsg = errmsg.to_str().unwrap().to_owned();\n\n            raise_exception(typ.to_owned(), extended_errcode, errmsg, vm)\n        }\n\n        fn open(path: *const libc::c_char, uri: bool, vm: &VirtualMachine) -> PyResult<Self> {\n            let mut db = null_mut();\n            let ret = unsafe {\n                sqlite3_open_v2(\n                    path,\n                    &raw mut db,\n                    SQLITE_OPEN_READWRITE\n                        | SQLITE_OPEN_CREATE\n                        | if uri { SQLITE_OPEN_URI } else { 0 },\n                    null(),\n                )\n            };\n            let zelf = Self { db };\n            zelf.check(ret, vm).map(|_| zelf)\n        }\n\n        fn _exec(self, sql: &[u8], vm: &VirtualMachine) -> PyResult<()> {\n            let ret =\n                unsafe { sqlite3_exec(self.db, sql.as_ptr().cast(), None, null_mut(), null_mut()) };\n            self.check(ret, vm)\n        }\n\n        fn prepare(\n            self,\n            sql: *const libc::c_char,\n            tail: *mut *const libc::c_char,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<SqliteStatement>> {\n            let mut st = null_mut();\n            let ret = unsafe { sqlite3_prepare_v2(self.db, sql, -1, &mut st, tail) };\n            self.check(ret, vm)?;\n            if st.is_null() {\n                Ok(None)\n            } else {\n                Ok(Some(SqliteStatement::from(SqliteStatementRaw::from(st))))\n            }\n        }\n\n        fn limit(self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let old_limit = unsafe { sqlite3_limit(self.db, category, limit) };\n            if old_limit >= 0 {\n                Ok(old_limit)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"'category' is out of bounds\".to_owned(),\n                ))\n            }\n        }\n\n        fn sql_limit(self, len: usize, vm: &VirtualMachine) -> PyResult<()> {\n            if len <= unsafe { sqlite3_limit(self.db, SQLITE_LIMIT_SQL_LENGTH, -1) } as usize {\n                Ok(())\n            } else {\n                Err(new_data_error(vm, \"query string is too large\".to_owned()))\n            }\n        }\n\n        fn is_autocommit(self) -> bool {\n            unsafe { sqlite3_get_autocommit(self.db) != 0 }\n        }\n\n        fn changes(self) -> c_int {\n            unsafe { sqlite3_changes(self.db) }\n        }\n\n        fn total_changes(self) -> c_int {\n            unsafe { sqlite3_total_changes(self.db) }\n        }\n\n        fn lastrowid(self) -> c_longlong {\n            unsafe { sqlite3_last_insert_rowid(self.db) }\n        }\n\n        fn implicit_commit(self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.is_autocommit() {\n                Ok(())\n            } else {\n                self._exec(b\"COMMIT\\0\", vm)\n            }\n        }\n\n        fn begin_transaction(\n            self,\n            isolation_level: Option<PyStrRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(isolation_level) = isolation_level else {\n                return Ok(());\n            };\n            let mut s = Vec::with_capacity(16);\n            s.extend(b\"BEGIN \");\n            s.extend(isolation_level.as_str().bytes());\n            s.push(b'\\0');\n            self._exec(&s, vm)\n        }\n\n        fn interrupt(self) {\n            unsafe { sqlite3_interrupt(self.db) }\n        }\n\n        fn busy_timeout(self, timeout: i32) {\n            unsafe { sqlite3_busy_timeout(self.db, timeout) };\n        }\n\n        #[allow(clippy::too_many_arguments)]\n        fn create_function(\n            self,\n            name: *const libc::c_char,\n            narg: c_int,\n            flags: c_int,\n            data: *mut c_void,\n            func: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            step: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            finalize: Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n            destroy: Option<unsafe extern \"C\" fn(arg1: *mut c_void)>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let ret = unsafe {\n                sqlite3_create_function_v2(\n                    self.db, name, narg, flags, data, func, step, finalize, destroy,\n                )\n            };\n            self.check(ret, vm)\n                .map_err(|_| new_operational_error(vm, \"Error creating function\".to_owned()))\n        }\n    }\n\n    struct SqliteStatement {\n        raw: SqliteStatementRaw,\n    }\n\n    impl From<SqliteStatementRaw> for SqliteStatement {\n        fn from(raw: SqliteStatementRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for SqliteStatement {\n        fn drop(&mut self) {\n            unsafe {\n                sqlite3_finalize(self.raw.st);\n            }\n        }\n    }\n\n    impl Deref for SqliteStatement {\n        type Target = SqliteStatementRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteStatementRaw {\n        st: *mut sqlite3_stmt,\n    }\n\n    impl From<*mut sqlite3_stmt> for SqliteStatementRaw {\n        fn from(st: *mut sqlite3_stmt) -> Self {\n            SqliteStatementRaw { st }\n        }\n    }\n\n    impl SqliteStatementRaw {\n        fn step(self) -> c_int {\n            unsafe { sqlite3_step(self.st) }\n        }\n\n        fn step_row_else_done(self, vm: &VirtualMachine) -> PyResult<bool> {\n            let ret = self.step();\n\n            if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                Err(exc)\n            } else if ret == SQLITE_ROW {\n                Ok(true)\n            } else if ret == SQLITE_DONE {\n                Ok(false)\n            } else {\n                Err(SqliteRaw::from(self).error_extended(vm))\n            }\n        }\n\n        fn reset(self) {\n            unsafe { sqlite3_reset(self.st) };\n        }\n\n        fn data_count(self) -> c_int {\n            unsafe { sqlite3_data_count(self.st) }\n        }\n\n        fn bind_parameter(\n            self,\n            pos: c_int,\n            parameter: &PyObject,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let adapted;\n            let obj = if need_adapt(parameter, vm) {\n                adapted = _adapt(\n                    parameter,\n                    PrepareProtocol::class(&vm.ctx).to_owned(),\n                    |x| Ok(x.to_owned()),\n                    vm,\n                )?;\n                &adapted\n            } else {\n                parameter\n            };\n\n            let ret = if vm.is_none(obj) {\n                unsafe { sqlite3_bind_null(self.st, pos) }\n            } else if let Some(val) = obj.downcast_ref::<PyInt>() {\n                let val = val.try_to_primitive::<i64>(vm).map_err(|_| {\n                    vm.new_overflow_error(\"Python int too large to convert to SQLite INTEGER\")\n                })?;\n                unsafe { sqlite3_bind_int64(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyFloat>() {\n                let val = val.to_f64();\n                unsafe { sqlite3_bind_double(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyStr>() {\n                let val = val.try_as_utf8(vm)?;\n                let (ptr, len) = str_to_ptr_len(val, vm)?;\n                unsafe { sqlite3_bind_text(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, obj) {\n                let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                unsafe { sqlite3_bind_blob(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Error binding parameter {}: type '{}' is not supported\",\n                        pos,\n                        obj.class()\n                    ),\n                ));\n            };\n\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                let db = SqliteRaw::from(self);\n                db.check(ret, vm)\n            }\n        }\n\n        fn bind_parameters(self, parameters: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            if let Some(dict) = parameters.downcast_ref::<PyDict>() {\n                self.bind_parameters_name(dict, vm)\n            } else if let Ok(seq) = PySequence::try_protocol(parameters, vm) {\n                self.bind_parameters_sequence(seq, vm)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"parameters are of unsupported type\".to_owned(),\n                ))\n            }\n        }\n\n        fn bind_parameters_name(self, dict: &Py<PyDict>, vm: &VirtualMachine) -> PyResult<()> {\n            let num_needed = unsafe { sqlite3_bind_parameter_count(self.st) };\n\n            for i in 1..=num_needed {\n                let name = unsafe { sqlite3_bind_parameter_name(self.st, i) };\n                if name.is_null() {\n                    return Err(new_programming_error(vm, \"Binding {} has no name, but you supplied a dictionary (which has only names).\".to_owned()));\n                }\n                let name = unsafe { name.add(1) };\n                let name = ptr_to_str(name, vm)?;\n\n                let val = match dict.get_item_opt(name, vm)? {\n                    Some(val) => val,\n                    None => {\n                        return Err(new_programming_error(\n                            vm,\n                            format!(\"You did not supply a value for binding parameter :{name}.\",),\n                        ));\n                    }\n                };\n\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn bind_parameter_count(self) -> c_int {\n            unsafe { sqlite3_bind_parameter_count(self.st) }\n        }\n\n        fn bind_parameters_sequence(\n            self,\n            seq: PySequence<'_>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let num_needed = self.bind_parameter_count();\n            let num_supplied = seq.length(vm)?;\n\n            if num_supplied != num_needed as usize {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Incorrect number of bindings supplied. The current statement uses {}, and {} were supplied.\",\n                        num_needed, num_supplied\n                    ),\n                ));\n            }\n\n            for i in 1..=num_needed {\n                let val = seq.get_item(i as isize - 1, vm)?;\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn column_count(self) -> c_int {\n            unsafe { sqlite3_column_count(self.st) }\n        }\n\n        fn column_type(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_type(self.st, pos) }\n        }\n\n        fn column_int(self, pos: c_int) -> i64 {\n            unsafe { sqlite3_column_int64(self.st, pos) }\n        }\n\n        fn column_double(self, pos: c_int) -> f64 {\n            unsafe { sqlite3_column_double(self.st, pos) }\n        }\n\n        fn column_blob(self, pos: c_int) -> *const c_void {\n            unsafe { sqlite3_column_blob(self.st, pos) }\n        }\n\n        fn column_text(self, pos: c_int) -> *const u8 {\n            unsafe { sqlite3_column_text(self.st, pos) }\n        }\n\n        fn column_decltype(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_decltype(self.st, pos) }\n        }\n\n        fn column_bytes(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_bytes(self.st, pos) }\n        }\n\n        fn column_name(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_name(self.st, pos) }\n        }\n\n        fn columns_name(self, detect_types: i32, vm: &VirtualMachine) -> PyResult<Vec<PyStrRef>> {\n            let count = self.column_count();\n            (0..count)\n                .map(|i| {\n                    let name = self.column_name(i);\n                    let name_str = ptr_to_str(name, vm)?;\n\n                    // If PARSE_COLNAMES is enabled, strip everything after the first '[' (and preceding space)\n                    let processed_name = if detect_types & PARSE_COLNAMES != 0\n                        && let Some(bracket_pos) = name_str.find('[')\n                    {\n                        // Check if there's a single space before '[' and remove it (CPython compatibility)\n                        let end_pos = if bracket_pos > 0\n                            && name_str.chars().nth(bracket_pos - 1) == Some(' ')\n                        {\n                            bracket_pos - 1\n                        } else {\n                            bracket_pos\n                        };\n\n                        &name_str[..end_pos]\n                    } else {\n                        name_str\n                    };\n\n                    Ok(vm.ctx.new_str(processed_name))\n                })\n                .collect()\n        }\n\n        fn columns_description(\n            self,\n            detect_types: i32,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<PyTupleRef>> {\n            if self.column_count() == 0 {\n                return Ok(None);\n            }\n            let columns = self\n                .columns_name(detect_types, vm)?\n                .into_iter()\n                .map(|s| {\n                    vm.ctx\n                        .new_tuple(vec![\n                            s.into(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                        ])\n                        .into()\n                })\n                .collect();\n            Ok(Some(vm.ctx.new_tuple(columns)))\n        }\n\n        fn busy(self) -> bool {\n            unsafe { sqlite3_stmt_busy(self.st) != 0 }\n        }\n\n        fn readonly(self) -> bool {\n            unsafe { sqlite3_stmt_readonly(self.st) != 0 }\n        }\n    }\n\n    #[derive(Debug, Copy, Clone)]\n    struct SqliteBlob {\n        blob: *mut sqlite3_blob,\n    }\n\n    impl SqliteBlob {\n        fn bytes(self) -> c_int {\n            unsafe { sqlite3_blob_bytes(self.blob) }\n        }\n\n        fn write(self, buf: *const c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_write(self.blob, buf, length, offset) }\n        }\n\n        fn read(self, buf: *mut c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_read(self.blob, buf, length, offset) }\n        }\n\n        fn read_single(self, byte: &mut u8, offset: c_int) -> c_int {\n            self.read(byte as *mut u8 as *mut _, 1, offset)\n        }\n\n        fn write_single(self, byte: u8, offset: c_int) -> c_int {\n            self.write(&byte as *const u8 as *const _, 1, offset)\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteContext {\n        ctx: *mut sqlite3_context,\n    }\n\n    impl From<*mut sqlite3_context> for SqliteContext {\n        fn from(ctx: *mut sqlite3_context) -> Self {\n            Self { ctx }\n        }\n    }\n\n    impl SqliteContext {\n        fn user_data<T>(self) -> *mut T {\n            unsafe { sqlite3_user_data(self.ctx).cast() }\n        }\n\n        fn aggregate_context<T>(self) -> *mut T {\n            unsafe { sqlite3_aggregate_context(self.ctx, std::mem::size_of::<T>() as c_int).cast() }\n        }\n\n        fn result_exception(self, vm: &VirtualMachine, exc: PyBaseExceptionRef, msg: &str) {\n            if exc.fast_isinstance(vm.ctx.exceptions.memory_error) {\n                unsafe { sqlite3_result_error_nomem(self.ctx) }\n            } else if exc.fast_isinstance(vm.ctx.exceptions.overflow_error) {\n                unsafe { sqlite3_result_error_toobig(self.ctx) }\n            } else {\n                unsafe { sqlite3_result_error(self.ctx, msg.as_ptr().cast(), -1) }\n            }\n            if enable_traceback().load(Ordering::Relaxed) {\n                vm.print_exception(exc);\n            }\n        }\n\n        fn db_handle(self) -> *mut sqlite3 {\n            unsafe { sqlite3_context_db_handle(self.ctx) }\n        }\n\n        fn result_from_object(self, val: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            unsafe {\n                if vm.is_none(val) {\n                    sqlite3_result_null(self.ctx)\n                } else if let Some(val) = val.downcast_ref::<PyInt>() {\n                    sqlite3_result_int64(self.ctx, val.try_to_primitive(vm)?)\n                } else if let Some(val) = val.downcast_ref::<PyFloat>() {\n                    sqlite3_result_double(self.ctx, val.to_f64())\n                } else if let Some(val) = val.downcast_ref::<PyStr>() {\n                    let val = val.try_as_utf8(vm)?;\n                    let (ptr, len) = str_to_ptr_len(val, vm)?;\n                    sqlite3_result_text(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, val) {\n                    let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                    sqlite3_result_blob(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else {\n                    return Err(new_programming_error(\n                        vm,\n                        \"result type not support\".to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n    }\n\n    fn value_to_object(val: *mut sqlite3_value, db: *mut sqlite3, vm: &VirtualMachine) -> PyResult {\n        let obj = unsafe {\n            match sqlite3_value_type(val) {\n                SQLITE_INTEGER => vm.ctx.new_int(sqlite3_value_int64(val)).into(),\n                SQLITE_FLOAT => vm.ctx.new_float(sqlite3_value_double(val)).into(),\n                SQLITE_TEXT => {\n                    let text =\n                        ptr_to_vec(sqlite3_value_text(val), sqlite3_value_bytes(val), db, vm)?;\n                    let text = String::from_utf8(text)\n                        .map_err(|_| vm.new_value_error(\"invalid utf-8 with SQLITE_TEXT\"))?;\n                    vm.ctx.new_str(text).into()\n                }\n                SQLITE_BLOB => {\n                    let blob = ptr_to_vec(\n                        sqlite3_value_blob(val).cast(),\n                        sqlite3_value_bytes(val),\n                        db,\n                        vm,\n                    )?;\n                    vm.ctx.new_bytes(blob).into()\n                }\n                _ => vm.ctx.none(),\n            }\n        };\n        Ok(obj)\n    }\n\n    fn ptr_to_str<'a>(p: *const libc::c_char, vm: &VirtualMachine) -> PyResult<&'a str> {\n        if p.is_null() {\n            return Err(vm.new_memory_error(\"string pointer is null\"));\n        }\n        unsafe { CStr::from_ptr(p).to_str() }\n            .map_err(|_| vm.new_value_error(\"Invalid UIF-8 codepoint\"))\n    }\n\n    fn ptr_to_string(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<String> {\n        let s = ptr_to_vec(p, nbytes, db, vm)?;\n        String::from_utf8(s).map_err(|_| vm.new_value_error(\"invalid utf-8\"))\n    }\n\n    fn ptr_to_vec(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<Vec<u8>> {\n        if p.is_null() {\n            if !db.is_null() && unsafe { sqlite3_errcode(db) } == SQLITE_NOMEM {\n                Err(vm.new_memory_error(\"sqlite out of memory\"))\n            } else {\n                Ok(vec![])\n            }\n        } else if nbytes < 0 {\n            Err(vm.new_system_error(\"negative size with ptr\"))\n        } else {\n            Ok(unsafe { std::slice::from_raw_parts(p.cast(), nbytes as usize) }.to_vec())\n        }\n    }\n\n    fn str_to_ptr_len(s: &PyUtf8Str, vm: &VirtualMachine) -> PyResult<(*const libc::c_char, i32)> {\n        let s_str = s.as_str();\n        let len = c_int::try_from(s_str.len())\n            .map_err(|_| vm.new_overflow_error(\"TEXT longer than INT_MAX bytes\"))?;\n        let ptr = s_str.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn buffer_to_ptr_len(buffer: &PyBuffer, vm: &VirtualMachine) -> PyResult<(*const c_void, i32)> {\n        let bytes = buffer\n            .as_contiguous()\n            .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n        let len = c_int::try_from(bytes.len())\n            .map_err(|_| vm.new_overflow_error(\"BLOB longer than INT_MAX bytes\"))?;\n        let ptr = bytes.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn exception_type_from_errcode(errcode: c_int, vm: &VirtualMachine) -> &'static Py<PyType> {\n        match errcode {\n            SQLITE_INTERNAL | SQLITE_NOTFOUND => internal_error_type(),\n            SQLITE_NOMEM => vm.ctx.exceptions.memory_error,\n            SQLITE_ERROR | SQLITE_PERM | SQLITE_ABORT | SQLITE_BUSY | SQLITE_LOCKED\n            | SQLITE_READONLY | SQLITE_INTERRUPT | SQLITE_IOERR | SQLITE_FULL | SQLITE_CANTOPEN\n            | SQLITE_PROTOCOL | SQLITE_EMPTY | SQLITE_SCHEMA => operational_error_type(),\n            SQLITE_CORRUPT => database_error_type(),\n            SQLITE_TOOBIG => data_error_type(),\n            SQLITE_CONSTRAINT | SQLITE_MISMATCH => integrity_error_type(),\n            SQLITE_MISUSE | SQLITE_RANGE => interface_error_type(),\n            _ => database_error_type(),\n        }\n    }\n\n    fn name_from_errcode(errcode: c_int) -> &'static str {\n        for (name, code) in ERROR_CODES {\n            if *code == errcode {\n                return name;\n            }\n        }\n        \"unknown error code\"\n    }\n\n    fn raise_exception(\n        typ: PyTypeRef,\n        errcode: c_int,\n        msg: String,\n        vm: &VirtualMachine,\n    ) -> PyBaseExceptionRef {\n        let dict = vm.ctx.new_dict();\n        if let Err(e) = dict.set_item(\"sqlite_errorcode\", vm.ctx.new_int(errcode).into(), vm) {\n            return e;\n        }\n        let errname = name_from_errcode(errcode);\n        if let Err(e) = dict.set_item(\"sqlite_errorname\", vm.ctx.new_str(errname).into(), vm) {\n            return e;\n        }\n\n        vm.new_exception_msg_dict(typ, msg, dict)\n    }\n\n    static BEGIN_STATEMENTS: &[&[u8]] = &[\n        b\"BEGIN \",\n        b\"BEGIN DEFERRED\",\n        b\"BEGIN IMMEDIATE\",\n        b\"BEGIN EXCLUSIVE\",\n    ];\n\n    fn begin_statement_ptr_from_isolation_level(\n        s: &PyStr,\n        vm: &VirtualMachine,\n    ) -> PyResult<*const libc::c_char> {\n        BEGIN_STATEMENTS\n            .iter()\n            .find(|&&x| x[6..].eq_ignore_ascii_case(s.as_bytes()))\n            .map(|&x| x.as_ptr().cast())\n            .ok_or_else(|| {\n                vm.new_value_error(\n                    \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or 'EXCLUSIVE'\",\n                )\n            })\n    }\n\n    fn lstrip_sql(sql: &[u8]) -> Option<&[u8]> {\n        let mut pos = 0;\n\n        // This loop is borrowed from the SQLite source code.\n        while let Some(t_char) = sql.get(pos) {\n            match t_char {\n                b' ' | b'\\t' | b'\\x0c' | b'\\n' | b'\\r' => {\n                    // Skip whitespace.\n                    pos += 1;\n                }\n                b'-' => {\n                    // Skip line comments.\n                    if sql.get(pos + 1) == Some(&b'-') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'\\n' {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                b'/' => {\n                    // Skip C style comments.\n                    if sql.get(pos + 1) == Some(&b'*') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'*' && sql.get(pos + 1) == Some(&b'/') {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                        pos += 2;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                _ => {\n                    return Some(&sql[pos..]);\n                }\n            }\n        }\n\n        None\n    }\n}\n"
                }
              ],
              []
            ],
            "kind": "textEditGroup",
            "uri": {
              "$mid": 1,
              "external": "file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "fsPath": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "path": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "scheme": "file"
            }
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_applyPatch"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_applyPatch",
          "input": "\"패치 적용\" 사용"
        },
        {
          "type": "tool_use",
          "name": "textEditGroup",
          "input": {
            "done": true,
            "edits": [
              [
                {
                  "range": {
                    "endColumn": 1,
                    "endLineNumber": 3404,
                    "startColumn": 1,
                    "startLineNumber": 1
                  },
                  "text": "// spell-checker:ignore libsqlite3 threadsafety PYSQLITE decltypes colnames collseq cantinit dirtywal\n// spell-checker:ignore corruptfs narg setinputsizes setoutputsize lastrowid arraysize executemany\n// spell-checker:ignore blobopen executescript iterdump getlimit setlimit errorcode errorname\n// spell-checker:ignore rowid rowcount fetchone fetchmany fetchall errcode errname vtable pagecount\n// spell-checker:ignore autocommit libversion toobig errmsg nomem threadsafe longlong vdbe reindex\n// spell-checker:ignore savepoint cantopen ioerr nolfs nomem notadb notfound fullpath notempdir vtab\n// spell-checker:ignore checkreservedlock noent fstat rdlock shmlock shmmap shmopen shmsize sharedcache\n// spell-checker:ignore cantlock commithook foreignkey notnull primarykey gettemppath autoindex convpath\n// spell-checker:ignore dbmoved vnode nbytes\n\nuse rustpython_vm::{AsObject, PyRef, VirtualMachine, builtins::PyModule};\n\n// pub(crate) use _sqlite::make_module;\npub(crate) fn make_module(vm: &VirtualMachine) -> PyRef<PyModule> {\n    // TODO: sqlite version check\n    let module = _sqlite::make_module(vm);\n    _sqlite::setup_module(module.as_object(), vm);\n    module\n}\n\n#[pymodule]\nmod _sqlite {\n    use crossbeam_utils::atomic::AtomicCell;\n    use libsqlite3_sys::{\n        SQLITE_BLOB, SQLITE_DETERMINISTIC, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL,\n        SQLITE_OPEN_CREATE, SQLITE_OPEN_READWRITE, SQLITE_OPEN_URI, SQLITE_TEXT, SQLITE_TRACE_STMT,\n        SQLITE_TRANSIENT, SQLITE_UTF8, sqlite3, sqlite3_aggregate_context, sqlite3_backup_finish,\n        sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining,\n        sqlite3_backup_step, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64,\n        sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name,\n        sqlite3_bind_text, sqlite3_blob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open,\n        sqlite3_blob_read, sqlite3_blob_write, sqlite3_busy_timeout, sqlite3_changes,\n        sqlite3_close_v2, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count,\n        sqlite3_column_decltype, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_name,\n        sqlite3_column_text, sqlite3_column_type, sqlite3_complete, sqlite3_context,\n        sqlite3_context_db_handle, sqlite3_create_collation_v2, sqlite3_create_function_v2,\n        sqlite3_create_window_function, sqlite3_data_count, sqlite3_db_handle, sqlite3_errcode,\n        sqlite3_errmsg, sqlite3_exec, sqlite3_expanded_sql, sqlite3_extended_errcode,\n        sqlite3_finalize, sqlite3_get_autocommit, sqlite3_interrupt, sqlite3_last_insert_rowid,\n        sqlite3_libversion, sqlite3_limit, sqlite3_open_v2, sqlite3_prepare_v2,\n        sqlite3_progress_handler, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double,\n        sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_error_toobig,\n        sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_set_authorizer,\n        sqlite3_sleep, sqlite3_step, sqlite3_stmt, sqlite3_stmt_busy, sqlite3_stmt_readonly,\n        sqlite3_threadsafe, sqlite3_total_changes, sqlite3_trace_v2, sqlite3_user_data,\n        sqlite3_value, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double,\n        sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type,\n    };\n    use malachite_bigint::Sign;\n    use rustpython_common::{\n        atomic::{Ordering, PyAtomic, Radium},\n        hash::PyHash,\n        lock::{PyMappedMutexGuard, PyMutex, PyMutexGuard},\n        static_cell,\n    };\n    use rustpython_vm::{\n        __exports::paste,\n        AsObject, Py, PyAtomicRef, PyObject, PyObjectRef, PyPayload, PyRef, PyResult,\n        TryFromBorrowedObject, VirtualMachine, atomic_func,\n        builtins::{\n            PyBaseException, PyBaseExceptionRef, PyByteArray, PyBytes, PyDict, PyDictRef, PyFloat,\n            PyInt, PyIntRef, PySlice, PyStr, PyStrRef, PyTuple, PyTupleRef, PyType, PyTypeRef,\n            PyUtf8Str, PyUtf8StrRef,\n        },\n        convert::IntoObject,\n        function::{\n            ArgCallable, ArgIterable, FsPath, FuncArgs, OptionalArg, PyComparisonValue,\n            PySetterValue,\n        },\n        object::{Traverse, TraverseFn},\n        protocol::{\n            PyBuffer, PyIterReturn, PyMappingMethods, PyNumberMethods, PySequence,\n            PySequenceMethods,\n        },\n        sliceable::{SaturatedSliceIter, SliceableSequenceOp},\n        types::{\n            AsMapping, AsNumber, AsSequence, Callable, Comparable, Constructor, Hashable,\n            Initializer, IterNext, Iterable, PyComparisonOp, SelfIter, Unconstructible,\n        },\n        utils::ToCString,\n    };\n    use std::{\n        ffi::{CStr, c_int, c_longlong, c_uint, c_void},\n        fmt::Debug,\n        ops::Deref,\n        ptr::{NonNull, null, null_mut},\n        thread::ThreadId,\n    };\n\n    macro_rules! exceptions {\n        ($(($x:ident, $base:expr)),*) => {\n            paste::paste! {\n                static_cell! {\n                    $(\n                        static [<$x:snake:upper>]: PyTypeRef;\n                    )*\n                }\n                $(\n                    #[allow(dead_code)]\n                    fn [<new_ $x:snake>](vm: &VirtualMachine, msg: String) -> PyBaseExceptionRef {\n                        vm.new_exception_msg([<$x:snake _type>]().to_owned(), msg)\n                    }\n                    fn [<$x:snake _type>]() -> &'static Py<PyType> {\n                        [<$x:snake:upper>].get().expect(\"exception type not initialize\")\n                    }\n                )*\n                fn setup_module_exceptions(module: &PyObject, vm: &VirtualMachine) {\n                    $(\n                        #[allow(clippy::redundant_closure_call)]\n                        let exception = [<$x:snake:upper>].get_or_init(|| {\n                            let base = $base(vm);\n                            vm.ctx.new_exception_type(\"_sqlite3\", stringify!($x), Some(vec![base.to_owned()]))\n                        });\n                        module.set_attr(stringify!($x), exception.clone().into_object(), vm).unwrap();\n                    )*\n                }\n            }\n        };\n    }\n\n    exceptions!(\n        (Warning, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (Error, |vm: &VirtualMachine| vm\n            .ctx\n            .exceptions\n            .exception_type),\n        (InterfaceError, |_| error_type()),\n        (DatabaseError, |_| error_type()),\n        (DataError, |_| database_error_type()),\n        (OperationalError, |_| database_error_type()),\n        (IntegrityError, |_| database_error_type()),\n        (InternalError, |_| database_error_type()),\n        (ProgrammingError, |_| database_error_type()),\n        (NotSupportedError, |_| database_error_type())\n    );\n\n    #[pyattr]\n    fn sqlite_version(vm: &VirtualMachine) -> String {\n        let s = unsafe { sqlite3_libversion() };\n        ptr_to_str(s, vm).unwrap().to_owned()\n    }\n\n    #[pyattr]\n    fn threadsafety(_: &VirtualMachine) -> c_int {\n        let mode = unsafe { sqlite3_threadsafe() };\n        match mode {\n            0 => 0,\n            1 => 3,\n            2 => 1,\n            _ => panic!(\"Unable to interpret SQLite threadsafety mode\"),\n        }\n    }\n\n    #[pyattr(name = \"_deprecated_version\")]\n    const PYSQLITE_VERSION: &str = \"2.6.0\";\n\n    #[pyattr]\n    const PARSE_DECLTYPES: c_int = 1;\n    #[pyattr]\n    const PARSE_COLNAMES: c_int = 2;\n\n    #[pyattr]\n    use libsqlite3_sys::{\n        SQLITE_ALTER_TABLE, SQLITE_ANALYZE, SQLITE_ATTACH, SQLITE_CREATE_INDEX,\n        SQLITE_CREATE_TABLE, SQLITE_CREATE_TEMP_INDEX, SQLITE_CREATE_TEMP_TABLE,\n        SQLITE_CREATE_TEMP_TRIGGER, SQLITE_CREATE_TEMP_VIEW, SQLITE_CREATE_TRIGGER,\n        SQLITE_CREATE_VIEW, SQLITE_CREATE_VTABLE, SQLITE_DELETE, SQLITE_DENY, SQLITE_DETACH,\n        SQLITE_DROP_INDEX, SQLITE_DROP_TABLE, SQLITE_DROP_TEMP_INDEX, SQLITE_DROP_TEMP_TABLE,\n        SQLITE_DROP_TEMP_TRIGGER, SQLITE_DROP_TEMP_VIEW, SQLITE_DROP_TRIGGER, SQLITE_DROP_VIEW,\n        SQLITE_DROP_VTABLE, SQLITE_FUNCTION, SQLITE_IGNORE, SQLITE_INSERT, SQLITE_LIMIT_ATTACHED,\n        SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH,\n        SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH,\n        SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER,\n        SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_PRAGMA, SQLITE_READ,\n        SQLITE_RECURSIVE, SQLITE_REINDEX, SQLITE_SAVEPOINT, SQLITE_SELECT, SQLITE_TRANSACTION,\n        SQLITE_UPDATE,\n    };\n\n    macro_rules! error_codes {\n        ($($x:ident),*) => {\n            $(\n                #[allow(unused_imports)]\n                use libsqlite3_sys::$x;\n            )*\n            static ERROR_CODES: &[(&str, c_int)] = &[\n            $(\n                (stringify!($x), libsqlite3_sys::$x),\n            )*\n            ];\n        };\n    }\n\n    error_codes!(\n        SQLITE_ABORT,\n        SQLITE_AUTH,\n        SQLITE_BUSY,\n        SQLITE_CANTOPEN,\n        SQLITE_CONSTRAINT,\n        SQLITE_CORRUPT,\n        SQLITE_DONE,\n        SQLITE_EMPTY,\n        SQLITE_ERROR,\n        SQLITE_FORMAT,\n        SQLITE_FULL,\n        SQLITE_INTERNAL,\n        SQLITE_INTERRUPT,\n        SQLITE_IOERR,\n        SQLITE_LOCKED,\n        SQLITE_MISMATCH,\n        SQLITE_MISUSE,\n        SQLITE_NOLFS,\n        SQLITE_NOMEM,\n        SQLITE_NOTADB,\n        SQLITE_NOTFOUND,\n        SQLITE_OK,\n        SQLITE_PERM,\n        SQLITE_PROTOCOL,\n        SQLITE_RANGE,\n        SQLITE_READONLY,\n        SQLITE_ROW,\n        SQLITE_SCHEMA,\n        SQLITE_TOOBIG,\n        SQLITE_NOTICE,\n        SQLITE_WARNING,\n        SQLITE_ABORT_ROLLBACK,\n        SQLITE_BUSY_RECOVERY,\n        SQLITE_CANTOPEN_FULLPATH,\n        SQLITE_CANTOPEN_ISDIR,\n        SQLITE_CANTOPEN_NOTEMPDIR,\n        SQLITE_CORRUPT_VTAB,\n        SQLITE_IOERR_ACCESS,\n        SQLITE_IOERR_BLOCKED,\n        SQLITE_IOERR_CHECKRESERVEDLOCK,\n        SQLITE_IOERR_CLOSE,\n        SQLITE_IOERR_DELETE,\n        SQLITE_IOERR_DELETE_NOENT,\n        SQLITE_IOERR_DIR_CLOSE,\n        SQLITE_IOERR_DIR_FSYNC,\n        SQLITE_IOERR_FSTAT,\n        SQLITE_IOERR_FSYNC,\n        SQLITE_IOERR_LOCK,\n        SQLITE_IOERR_NOMEM,\n        SQLITE_IOERR_RDLOCK,\n        SQLITE_IOERR_READ,\n        SQLITE_IOERR_SEEK,\n        SQLITE_IOERR_SHMLOCK,\n        SQLITE_IOERR_SHMMAP,\n        SQLITE_IOERR_SHMOPEN,\n        SQLITE_IOERR_SHMSIZE,\n        SQLITE_IOERR_SHORT_READ,\n        SQLITE_IOERR_TRUNCATE,\n        SQLITE_IOERR_UNLOCK,\n        SQLITE_IOERR_WRITE,\n        SQLITE_LOCKED_SHAREDCACHE,\n        SQLITE_READONLY_CANTLOCK,\n        SQLITE_READONLY_RECOVERY,\n        SQLITE_CONSTRAINT_CHECK,\n        SQLITE_CONSTRAINT_COMMITHOOK,\n        SQLITE_CONSTRAINT_FOREIGNKEY,\n        SQLITE_CONSTRAINT_FUNCTION,\n        SQLITE_CONSTRAINT_NOTNULL,\n        SQLITE_CONSTRAINT_PRIMARYKEY,\n        SQLITE_CONSTRAINT_TRIGGER,\n        SQLITE_CONSTRAINT_UNIQUE,\n        SQLITE_CONSTRAINT_VTAB,\n        SQLITE_READONLY_ROLLBACK,\n        SQLITE_IOERR_MMAP,\n        SQLITE_NOTICE_RECOVER_ROLLBACK,\n        SQLITE_NOTICE_RECOVER_WAL,\n        SQLITE_BUSY_SNAPSHOT,\n        SQLITE_IOERR_GETTEMPPATH,\n        SQLITE_WARNING_AUTOINDEX,\n        SQLITE_CANTOPEN_CONVPATH,\n        SQLITE_IOERR_CONVPATH,\n        SQLITE_CONSTRAINT_ROWID,\n        SQLITE_READONLY_DBMOVED,\n        SQLITE_AUTH_USER,\n        SQLITE_OK_LOAD_PERMANENTLY,\n        SQLITE_IOERR_VNODE,\n        SQLITE_IOERR_AUTH,\n        SQLITE_IOERR_BEGIN_ATOMIC,\n        SQLITE_IOERR_COMMIT_ATOMIC,\n        SQLITE_IOERR_ROLLBACK_ATOMIC,\n        SQLITE_ERROR_MISSING_COLLSEQ,\n        SQLITE_ERROR_RETRY,\n        SQLITE_READONLY_CANTINIT,\n        SQLITE_READONLY_DIRECTORY,\n        SQLITE_CORRUPT_SEQUENCE,\n        SQLITE_LOCKED_VTAB,\n        SQLITE_CANTOPEN_DIRTYWAL,\n        SQLITE_ERROR_SNAPSHOT,\n        SQLITE_CANTOPEN_SYMLINK,\n        SQLITE_CONSTRAINT_PINNED,\n        SQLITE_OK_SYMLINK,\n        SQLITE_BUSY_TIMEOUT,\n        SQLITE_CORRUPT_INDEX,\n        SQLITE_IOERR_DATA,\n        SQLITE_IOERR_CORRUPTFS\n    );\n\n    #[derive(FromArgs)]\n    struct ConnectArgs {\n        #[pyarg(any)]\n        database: FsPath,\n        #[pyarg(any, default = 5.0)]\n        timeout: f64,\n        #[pyarg(any, default = 0)]\n        detect_types: c_int,\n        #[pyarg(any, default = Some(vm.ctx.empty_str.to_owned()))]\n        isolation_level: Option<PyStrRef>,\n        #[pyarg(any, default = true)]\n        check_same_thread: bool,\n        #[pyarg(any, default = Connection::class(&vm.ctx).to_owned())]\n        factory: PyTypeRef,\n        // TODO: cache statements\n        #[allow(dead_code)]\n        #[pyarg(any, default = 0)]\n        cached_statements: c_int,\n        #[pyarg(any, default = false)]\n        uri: bool,\n    }\n\n    unsafe impl Traverse for ConnectArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.isolation_level.traverse(tracer_fn);\n            self.factory.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct BackupArgs {\n        #[pyarg(any)]\n        target: PyRef<Connection>,\n        #[pyarg(named, default = -1)]\n        pages: c_int,\n        #[pyarg(named, optional)]\n        progress: Option<ArgCallable>,\n        #[pyarg(named, optional)]\n        name: Option<PyStrRef>,\n        #[pyarg(named, default = 0.250)]\n        sleep: f64,\n    }\n\n    unsafe impl Traverse for BackupArgs {\n        fn traverse(&self, tracer_fn: &mut TraverseFn<'_>) {\n            self.progress.traverse(tracer_fn);\n            self.name.traverse(tracer_fn);\n        }\n    }\n\n    #[derive(FromArgs)]\n    struct CreateFunctionArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(any)]\n        narg: c_int,\n        #[pyarg(any)]\n        func: PyObjectRef,\n        #[pyarg(named, default)]\n        deterministic: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct CreateAggregateArgs {\n        #[pyarg(any)]\n        name: PyStrRef,\n        #[pyarg(positional)]\n        narg: c_int,\n        #[pyarg(positional)]\n        aggregate_class: PyObjectRef,\n    }\n\n    #[derive(FromArgs)]\n    struct BlobOpenArgs {\n        #[pyarg(positional)]\n        table: PyStrRef,\n        #[pyarg(positional)]\n        column: PyStrRef,\n        #[pyarg(positional)]\n        row: i64,\n        #[pyarg(named, default)]\n        readonly: bool,\n        #[pyarg(named, default = vm.ctx.new_str(\"main\"))]\n        name: PyStrRef,\n    }\n\n    struct CallbackData {\n        obj: NonNull<PyObject>,\n        vm: *const VirtualMachine,\n    }\n\n    impl CallbackData {\n        fn new(obj: PyObjectRef, vm: &VirtualMachine) -> Option<Self> {\n            (!vm.is_none(&obj)).then_some(Self {\n                obj: obj.into_raw(),\n                vm,\n            })\n        }\n\n        fn retrieve(&self) -> (&PyObject, &VirtualMachine) {\n            unsafe { (self.obj.as_ref(), &*self.vm) }\n        }\n\n        unsafe extern \"C\" fn destructor(data: *mut c_void) {\n            drop(unsafe { Box::from_raw(data.cast::<Self>()) });\n        }\n\n        unsafe extern \"C\" fn func_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (func, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n\n                let val = func.call(args, vm)?;\n\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                context.result_exception(vm, exc, \"user-defined function raised exception\\0\")\n            }\n        }\n\n        unsafe extern \"C\" fn step_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (cls, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            if unsafe { (*instance).is_null() } {\n                match cls.call((), vm) {\n                    Ok(obj) => unsafe { *instance = obj.into_raw().as_ptr() },\n                    Err(exc) => {\n                        return context.result_exception(\n                            vm,\n                            exc,\n                            \"user-defined aggregate's '__init__' method raised error\\0\",\n                        );\n                    }\n                }\n            }\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"step\", args, vm);\n        }\n\n        unsafe extern \"C\" fn finalize_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let Some(instance) = (unsafe { (*instance).as_ref() }) else {\n                return;\n            };\n\n            Self::callback_result_from_method(context, instance, \"finalize\", vm);\n        }\n\n        unsafe extern \"C\" fn collation_callback(\n            data: *mut c_void,\n            a_len: c_int,\n            a_ptr: *const c_void,\n            b_len: c_int,\n            b_ptr: *const c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n\n            let f = || -> PyResult<c_int> {\n                let text1 = ptr_to_string(a_ptr.cast(), a_len, null_mut(), vm)?;\n                let text1 = vm.ctx.new_str(text1);\n                let text2 = ptr_to_string(b_ptr.cast(), b_len, null_mut(), vm)?;\n                let text2 = vm.ctx.new_str(text2);\n\n                let val = callable.call((text1, text2), vm)?;\n                let Some(val) = val.to_number().index(vm) else {\n                    return Ok(0);\n                };\n\n                let val = match val?.as_bigint().sign() {\n                    Sign::Plus => 1,\n                    Sign::Minus => -1,\n                    Sign::NoSign => 0,\n                };\n\n                Ok(val)\n            };\n\n            f().unwrap_or(0)\n        }\n\n        unsafe extern \"C\" fn value_callback(context: *mut sqlite3_context) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::callback_result_from_method(context, instance, \"value\", vm);\n        }\n\n        unsafe extern \"C\" fn inverse_callback(\n            context: *mut sqlite3_context,\n            argc: c_int,\n            argv: *mut *mut sqlite3_value,\n        ) {\n            let context = SqliteContext::from(context);\n            let (_, vm) = unsafe { (*context.user_data::<Self>()).retrieve() };\n            let args = unsafe { std::slice::from_raw_parts(argv, argc as usize) };\n            let instance = context.aggregate_context::<*const PyObject>();\n            let instance = unsafe { &**instance };\n\n            Self::call_method_with_args(context, instance, \"inverse\", args, vm);\n        }\n\n        unsafe extern \"C\" fn authorizer_callback(\n            data: *mut c_void,\n            action: c_int,\n            arg1: *const libc::c_char,\n            arg2: *const libc::c_char,\n            db_name: *const libc::c_char,\n            access: *const libc::c_char,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let f = || -> PyResult<c_int> {\n                let arg1 = ptr_to_str(arg1, vm)?;\n                let arg2 = ptr_to_str(arg2, vm)?;\n                let db_name = ptr_to_str(db_name, vm)?;\n                let access = ptr_to_str(access, vm)?;\n\n                let val = callable.call((action, arg1, arg2, db_name, access), vm)?;\n                let Some(val) = val.downcast_ref::<PyInt>() else {\n                    return Ok(SQLITE_DENY);\n                };\n                val.try_to_primitive::<c_int>(vm)\n            };\n\n            f().unwrap_or(SQLITE_DENY)\n        }\n\n        unsafe extern \"C\" fn trace_callback(\n            _typ: c_uint,\n            data: *mut c_void,\n            stmt: *mut c_void,\n            sql: *mut c_void,\n        ) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            let expanded = unsafe { sqlite3_expanded_sql(stmt.cast()) };\n            let f = || -> PyResult<()> {\n                let stmt = ptr_to_str(expanded, vm).or_else(|_| ptr_to_str(sql.cast(), vm))?;\n                callable.call((stmt,), vm)?;\n                Ok(())\n            };\n            let _ = f();\n            0\n        }\n\n        unsafe extern \"C\" fn progress_callback(data: *mut c_void) -> c_int {\n            let (callable, vm) = unsafe { (*data.cast::<Self>()).retrieve() };\n            if let Ok(val) = callable.call((), vm)\n                && let Ok(val) = val.is_true(vm)\n            {\n                return val as c_int;\n            }\n            -1\n        }\n\n        fn callback_result_from_method(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let val = vm.call_method(instance, name, ())?;\n                context.result_from_object(&val, vm)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n\n        fn call_method_with_args(\n            context: SqliteContext,\n            instance: &PyObject,\n            name: &str,\n            args: &[*mut sqlite3_value],\n            vm: &VirtualMachine,\n        ) {\n            let f = || -> PyResult<()> {\n                let db = context.db_handle();\n                let args = args\n                    .iter()\n                    .cloned()\n                    .map(|val| value_to_object(val, db, vm))\n                    .collect::<PyResult<Vec<PyObjectRef>>>()?;\n                vm.call_method(instance, name, args).map(drop)\n            };\n\n            if let Err(exc) = f() {\n                if exc.fast_isinstance(vm.ctx.exceptions.attribute_error) {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method not defined\\0\"),\n                    )\n                } else {\n                    context.result_exception(\n                        vm,\n                        exc,\n                        &format!(\"user-defined aggregate's '{name}' method raised error\\0\"),\n                    )\n                }\n            }\n        }\n    }\n\n    impl Drop for CallbackData {\n        fn drop(&mut self) {\n            unsafe { PyObjectRef::from_raw(self.obj) };\n        }\n    }\n\n    #[pyfunction]\n    fn connect(args: ConnectArgs, vm: &VirtualMachine) -> PyResult {\n        Connection::py_new(args.factory.clone(), args, vm)\n    }\n\n    #[pyfunction]\n    fn complete_statement(statement: PyStrRef, vm: &VirtualMachine) -> PyResult<bool> {\n        let s = statement.to_cstring(vm)?;\n        let ret = unsafe { sqlite3_complete(s.as_ptr()) };\n        Ok(ret == 1)\n    }\n\n    #[pyfunction]\n    fn enable_callback_tracebacks(flag: bool) {\n        enable_traceback().store(flag, Ordering::Relaxed);\n    }\n\n    #[pyfunction]\n    fn register_adapter(typ: PyTypeRef, adapter: ArgCallable, vm: &VirtualMachine) -> PyResult<()> {\n        if typ.is(PyInt::class(&vm.ctx))\n            || typ.is(PyFloat::class(&vm.ctx))\n            || typ.is(PyStr::class(&vm.ctx))\n            || typ.is(PyByteArray::class(&vm.ctx))\n        {\n            let _ = BASE_TYPE_ADAPTED.set(());\n        }\n        let protocol = PrepareProtocol::class(&vm.ctx).to_owned();\n        let key = vm.ctx.new_tuple(vec![typ.into(), protocol.into()]);\n        adapters().set_item(key.as_object(), adapter.into(), vm)\n    }\n\n    #[pyfunction]\n    fn register_converter(\n        typename: PyStrRef,\n        converter: ArgCallable,\n        vm: &VirtualMachine,\n    ) -> PyResult<()> {\n        let name = typename.as_str().to_uppercase();\n        converters().set_item(&name, converter.into(), vm)\n    }\n\n    fn _adapt<F>(obj: &PyObject, proto: PyTypeRef, alt: F, vm: &VirtualMachine) -> PyResult\n    where\n        F: FnOnce(&PyObject) -> PyResult,\n    {\n        let proto = proto.into_object();\n        let key = vm\n            .ctx\n            .new_tuple(vec![obj.class().to_owned().into(), proto.clone()]);\n\n        if let Some(adapter) = adapters().get_item_opt(key.as_object(), vm)? {\n            return adapter.call((obj,), vm);\n        }\n        if let Ok(adapter) = proto.get_attr(\"__adapt__\", vm) {\n            match adapter.call((obj,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n        if let Ok(adapter) = obj.get_attr(\"__conform__\", vm) {\n            match adapter.call((proto,), vm) {\n                Ok(val) => {\n                    if !vm.is_none(&val) {\n                        return Ok(val);\n                    }\n                }\n                Err(exc) => {\n                    if !exc.fast_isinstance(vm.ctx.exceptions.type_error) {\n                        return Err(exc);\n                    }\n                }\n            }\n        }\n\n        alt(obj)\n    }\n\n    #[pyfunction]\n    fn adapt(\n        obj: PyObjectRef,\n        proto: OptionalArg<Option<PyTypeRef>>,\n        alt: OptionalArg<PyObjectRef>,\n        vm: &VirtualMachine,\n    ) -> PyResult {\n        if matches!(proto, OptionalArg::Present(None)) {\n            return if let OptionalArg::Present(alt) = alt {\n                Ok(alt)\n            } else {\n                Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n            };\n        }\n\n        let proto = proto\n            .flatten()\n            .unwrap_or_else(|| PrepareProtocol::class(&vm.ctx).to_owned());\n\n        _adapt(\n            &obj,\n            proto,\n            |_| {\n                if let OptionalArg::Present(alt) = alt {\n                    Ok(alt)\n                } else {\n                    Err(new_programming_error(vm, \"can't adapt\".to_owned()))\n                }\n            },\n            vm,\n        )\n    }\n\n    fn need_adapt(obj: &PyObject, vm: &VirtualMachine) -> bool {\n        if BASE_TYPE_ADAPTED.get().is_some() {\n            true\n        } else {\n            let cls = obj.class();\n            !(cls.is(vm.ctx.types.int_type)\n                || cls.is(vm.ctx.types.float_type)\n                || cls.is(vm.ctx.types.str_type)\n                || cls.is(vm.ctx.types.bytearray_type))\n        }\n    }\n\n    static_cell! {\n        static CONVERTERS: PyDictRef;\n        static ADAPTERS: PyDictRef;\n        static BASE_TYPE_ADAPTED: ();\n        static USER_FUNCTION_EXCEPTION: PyAtomicRef<Option<PyBaseException>>;\n        static ENABLE_TRACEBACK: PyAtomic<bool>;\n    }\n\n    fn converters() -> &'static Py<PyDict> {\n        CONVERTERS.get().expect(\"converters not initialize\")\n    }\n\n    fn adapters() -> &'static Py<PyDict> {\n        ADAPTERS.get().expect(\"adapters not initialize\")\n    }\n\n    fn user_function_exception() -> &'static PyAtomicRef<Option<PyBaseException>> {\n        USER_FUNCTION_EXCEPTION\n            .get()\n            .expect(\"user function exception not initialize\")\n    }\n\n    fn enable_traceback() -> &'static PyAtomic<bool> {\n        ENABLE_TRACEBACK\n            .get()\n            .expect(\"enable traceback not initialize\")\n    }\n\n    pub(super) fn setup_module(module: &PyObject, vm: &VirtualMachine) {\n        for (name, code) in ERROR_CODES {\n            let name = vm.ctx.intern_str(*name);\n            let code = vm.new_pyobj(*code);\n            module.set_attr(name, code, vm).unwrap();\n        }\n\n        setup_module_exceptions(module, vm);\n\n        let _ = CONVERTERS.set(vm.ctx.new_dict());\n        let _ = ADAPTERS.set(vm.ctx.new_dict());\n        let _ = USER_FUNCTION_EXCEPTION.set(PyAtomicRef::from(None));\n        let _ = ENABLE_TRACEBACK.set(Radium::new(false));\n\n        module\n            .set_attr(\"converters\", converters().to_owned(), vm)\n            .unwrap();\n        module\n            .set_attr(\"adapters\", adapters().to_owned(), vm)\n            .unwrap();\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(PyPayload)]\n    struct Connection {\n        db: PyMutex<Option<Sqlite>>,\n        initialized: PyAtomic<bool>,\n        detect_types: PyAtomic<c_int>,\n        isolation_level: PyAtomicRef<Option<PyStr>>,\n        check_same_thread: PyAtomic<bool>,\n        thread_ident: PyMutex<ThreadId>,\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        text_factory: PyAtomicRef<PyObject>,\n    }\n\n    impl Debug for Connection {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(f, \"Sqlite3 Connection\")\n        }\n    }\n\n    impl Constructor for Connection {\n        type Args = ConnectArgs;\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n\n            // For non-subclassed Connection, initialize in __new__\n            // For subclassed Connection, leave db as None and require __init__ to be called\n            let is_base_class = cls.is(Connection::class(&vm.ctx).as_object());\n\n            let db = if is_base_class {\n                // Initialize immediately for base class\n                Some(Connection::initialize_db(&args, vm)?)\n            } else {\n                // For subclasses, require __init__ to be called\n                None\n            };\n\n            let initialized = db.is_some();\n\n            let conn = Self {\n                db: PyMutex::new(db),\n                initialized: Radium::new(initialized),\n                detect_types: Radium::new(args.detect_types),\n                isolation_level: PyAtomicRef::from(args.isolation_level),\n                check_same_thread: Radium::new(args.check_same_thread),\n                thread_ident: PyMutex::new(std::thread::current().id()),\n                row_factory: PyAtomicRef::from(None),\n                text_factory: PyAtomicRef::from(text_factory),\n            };\n\n            Ok(conn.into_ref_with_type(vm, cls)?.into())\n        }\n    }\n\n    impl Callable for Connection {\n        type Args = FuncArgs;\n\n        fn call(zelf: &Py<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let _ = zelf.db_lock(vm)?;\n\n            let (sql,): (PyUtf8StrRef,) = args.bind(vm)?;\n\n            if let Some(stmt) = Statement::new(zelf, sql, vm)? {\n                Ok(stmt.into_ref(&vm.ctx).into())\n            } else {\n                Ok(vm.ctx.none())\n            }\n        }\n    }\n\n    impl Initializer for Connection {\n        type Args = ConnectArgs;\n\n        fn init(zelf: PyRef<Self>, args: Self::Args, vm: &VirtualMachine) -> PyResult<()> {\n            let was_initialized = zelf.initialized.swap(false, Ordering::Relaxed);\n\n            // Reset factories to their defaults, matching CPython's behavior.\n            zelf.reset_factories(vm);\n\n            if was_initialized {\n                zelf.drop_db();\n            }\n\n            // Attempt to open the new database before mutating other state so failures leave\n            // the connection uninitialized (and subsequent operations raise ProgrammingError).\n            let db = Self::initialize_db(&args, vm)?;\n\n            let ConnectArgs {\n                detect_types,\n                isolation_level,\n                check_same_thread,\n                ..\n            } = args;\n\n            zelf.detect_types.store(detect_types, Ordering::Relaxed);\n            zelf.check_same_thread\n                .store(check_same_thread, Ordering::Relaxed);\n            *zelf.thread_ident.lock() = std::thread::current().id();\n            let _ = unsafe { zelf.isolation_level.swap(isolation_level) };\n\n            let mut guard = zelf.db.lock();\n            *guard = Some(db);\n            zelf.initialized.store(true, Ordering::Relaxed);\n            Ok(())\n        }\n    }\n\n    #[pyclass(with(Constructor, Callable, Initializer), flags(BASETYPE))]\n    impl Connection {\n        fn drop_db(&self) {\n            self.db.lock().take();\n        }\n\n        fn reset_factories(&self, vm: &VirtualMachine) {\n            let default_text_factory = PyStr::class(&vm.ctx).to_owned().into_object();\n            let _ = unsafe { self.row_factory.swap(None) };\n            let _ = unsafe { self.text_factory.swap(default_text_factory) };\n        }\n\n        fn initialize_db(args: &ConnectArgs, vm: &VirtualMachine) -> PyResult<Sqlite> {\n            let path = args.database.to_cstring(vm)?;\n            let db = Sqlite::from(SqliteRaw::open(path.as_ptr(), args.uri, vm)?);\n            let timeout = (args.timeout * 1000.0) as c_int;\n            db.busy_timeout(timeout);\n            if let Some(isolation_level) = &args.isolation_level {\n                begin_statement_ptr_from_isolation_level(isolation_level, vm)?;\n            }\n            Ok(db)\n        }\n\n        fn db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            self.check_thread(vm)?;\n            self._db_lock(vm)\n        }\n\n        fn _db_lock(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, Sqlite>> {\n            let guard = self.db.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Connection.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn cursor(\n            zelf: PyRef<Self>,\n            factory: OptionalArg<ArgCallable>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            zelf.db_lock(vm).map(drop)?;\n\n            let cursor = if let OptionalArg::Present(factory) = factory {\n                let cursor = factory.invoke((zelf.clone(),), vm)?;\n                let cursor = cursor.downcast::<Cursor>().map_err(|x| {\n                    vm.new_type_error(format!(\"factory must return a cursor, not {}\", x.class()))\n                })?;\n                let _ = unsafe { cursor.row_factory.swap(zelf.row_factory.to_owned()) };\n                cursor\n            } else {\n                let row_factory = zelf.row_factory.to_owned();\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx)\n            };\n            Ok(cursor)\n        }\n\n        #[pymethod]\n        fn blobopen(\n            zelf: PyRef<Self>,\n            args: BlobOpenArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Blob>> {\n            let table = args.table.to_cstring(vm)?;\n            let column = args.column.to_cstring(vm)?;\n            let name = args.name.to_cstring(vm)?;\n\n            let db = zelf.db_lock(vm)?;\n\n            let mut blob = null_mut();\n            let ret = unsafe {\n                sqlite3_blob_open(\n                    db.db,\n                    name.as_ptr(),\n                    table.as_ptr(),\n                    column.as_ptr(),\n                    args.row,\n                    (!args.readonly) as c_int,\n                    &mut blob,\n                )\n            };\n            db.check(ret, vm)?;\n            drop(db);\n\n            let blob = SqliteBlob { blob };\n            let blob = Blob {\n                connection: zelf,\n                inner: PyMutex::new(Some(BlobInner { blob, offset: 0 })),\n            };\n            Ok(blob.into_ref(&vm.ctx))\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.check_thread(vm)?;\n            self.drop_db();\n            Ok(())\n        }\n\n        #[pymethod]\n        fn commit(&self, vm: &VirtualMachine) -> PyResult<()> {\n            self.db_lock(vm)?.implicit_commit(vm)\n        }\n\n        #[pymethod]\n        fn rollback(&self, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            if !db.is_autocommit() {\n                db._exec(b\"ROLLBACK\\0\", vm)\n            } else {\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::execute(cursor, sql, parameters, vm)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            let cursor = Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx);\n            Cursor::executemany(cursor, sql, seq_of_params, vm)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Cursor>> {\n            let row_factory = zelf.row_factory.to_owned();\n            Cursor::executescript(\n                Cursor::new(zelf, row_factory, vm).into_ref(&vm.ctx),\n                script,\n                vm,\n            )\n        }\n\n        // TODO: Make it build without clippy::manual_c_str_literals\n        #[pymethod]\n        #[allow(clippy::manual_c_str_literals)]\n        fn backup(zelf: &Py<Self>, args: BackupArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let BackupArgs {\n                target,\n                pages,\n                progress,\n                name,\n                sleep,\n            } = args;\n            if zelf.is(&target) {\n                return Err(vm.new_value_error(\"target cannot be the same connection instance\"));\n            }\n\n            let pages = if pages == 0 { -1 } else { pages };\n\n            let name_cstring;\n            let name_ptr = if let Some(name) = &name {\n                name_cstring = name.to_cstring(vm)?;\n                name_cstring.as_ptr()\n            } else {\n                b\"main\\0\".as_ptr().cast()\n            };\n\n            let sleep_ms = (sleep * 1000.0) as c_int;\n\n            let db = zelf.db_lock(vm)?;\n            let target_db = target.db_lock(vm)?;\n\n            let handle = unsafe {\n                sqlite3_backup_init(target_db.db, b\"main\\0\".as_ptr().cast(), db.db, name_ptr)\n            };\n\n            if handle.is_null() {\n                return Err(target_db.error_extended(vm));\n            }\n\n            drop(db);\n            drop(target_db);\n\n            loop {\n                let ret = unsafe { sqlite3_backup_step(handle, pages) };\n\n                if let Some(progress) = &progress {\n                    let remaining = unsafe { sqlite3_backup_remaining(handle) };\n                    let pagecount = unsafe { sqlite3_backup_pagecount(handle) };\n                    if let Err(err) = progress.invoke((ret, remaining, pagecount), vm) {\n                        unsafe { sqlite3_backup_finish(handle) };\n                        return Err(err);\n                    }\n                }\n\n                if ret == SQLITE_BUSY || ret == SQLITE_LOCKED {\n                    unsafe { sqlite3_sleep(sleep_ms) };\n                } else if ret != SQLITE_OK {\n                    break;\n                }\n            }\n\n            let ret = unsafe { sqlite3_backup_finish(handle) };\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(target.db_lock(vm)?.error_extended(vm))\n            }\n        }\n\n        #[pymethod]\n        fn create_function(&self, args: CreateFunctionArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let flags = if args.deterministic {\n                SQLITE_UTF8 | SQLITE_DETERMINISTIC\n            } else {\n                SQLITE_UTF8\n            };\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.func, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    flags,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                flags,\n                Box::into_raw(Box::new(data)).cast(),\n                Some(CallbackData::func_callback),\n                None,\n                None,\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_aggregate(&self, args: CreateAggregateArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let name = args.name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(args.aggregate_class, vm) else {\n                return db.create_function(\n                    name.as_ptr(),\n                    args.narg,\n                    SQLITE_UTF8,\n                    null_mut(),\n                    None,\n                    None,\n                    None,\n                    None,\n                    vm,\n                );\n            };\n\n            db.create_function(\n                name.as_ptr(),\n                args.narg,\n                SQLITE_UTF8,\n                Box::into_raw(Box::new(data)).cast(),\n                None,\n                Some(CallbackData::step_callback),\n                Some(CallbackData::finalize_callback),\n                Some(CallbackData::destructor),\n                vm,\n            )\n        }\n\n        #[pymethod]\n        fn create_collation(\n            &self,\n            name: PyUtf8StrRef,\n            callable: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable.clone(), vm) else {\n                unsafe {\n                    sqlite3_create_collation_v2(\n                        db.db,\n                        name.as_ptr(),\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                    );\n                }\n                return Ok(());\n            };\n            let data = Box::into_raw(Box::new(data));\n\n            if !callable.is_callable() {\n                return Err(vm.new_type_error(\"parameter must be callable\"));\n            }\n\n            let ret = unsafe {\n                sqlite3_create_collation_v2(\n                    db.db,\n                    name.as_ptr(),\n                    SQLITE_UTF8,\n                    data.cast(),\n                    Some(CallbackData::collation_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n\n            db.check(ret, vm).inspect_err(|_| {\n                // create_collation do not call destructor if error occur\n                let _ = unsafe { Box::from_raw(data) };\n            })\n        }\n\n        #[pymethod]\n        fn create_window_function(\n            &self,\n            name: PyStrRef,\n            narg: c_int,\n            aggregate_class: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let name = name.to_cstring(vm)?;\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(aggregate_class, vm) else {\n                unsafe {\n                    sqlite3_create_window_function(\n                        db.db,\n                        name.as_ptr(),\n                        narg,\n                        SQLITE_UTF8,\n                        null_mut(),\n                        None,\n                        None,\n                        None,\n                        None,\n                        None,\n                    )\n                };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_create_window_function(\n                    db.db,\n                    name.as_ptr(),\n                    narg,\n                    SQLITE_UTF8,\n                    Box::into_raw(Box::new(data)).cast(),\n                    Some(CallbackData::step_callback),\n                    Some(CallbackData::finalize_callback),\n                    Some(CallbackData::value_callback),\n                    Some(CallbackData::inverse_callback),\n                    Some(CallbackData::destructor),\n                )\n            };\n            db.check(ret, vm)\n                .map_err(|_| new_programming_error(vm, \"Error creating window function\".to_owned()))\n        }\n\n        #[pymethod]\n        fn set_authorizer(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_set_authorizer(db.db, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_set_authorizer(\n                    db.db,\n                    Some(CallbackData::authorizer_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n            db.check(ret, vm).map_err(|_| {\n                new_operational_error(vm, \"Error setting authorizer callback\".to_owned())\n            })\n        }\n\n        #[pymethod]\n        fn set_trace_callback(&self, callable: PyObjectRef, vm: &VirtualMachine) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_trace_v2(db.db, SQLITE_TRACE_STMT as u32, None, null_mut()) };\n                return Ok(());\n            };\n\n            let ret = unsafe {\n                sqlite3_trace_v2(\n                    db.db,\n                    SQLITE_TRACE_STMT as u32,\n                    Some(CallbackData::trace_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            db.check(ret, vm)\n        }\n\n        #[pymethod]\n        fn set_progress_handler(\n            &self,\n            callable: PyObjectRef,\n            n: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let db = self.db_lock(vm)?;\n            let Some(data) = CallbackData::new(callable, vm) else {\n                unsafe { sqlite3_progress_handler(db.db, n, None, null_mut()) };\n                return Ok(());\n            };\n\n            unsafe {\n                sqlite3_progress_handler(\n                    db.db,\n                    n,\n                    Some(CallbackData::progress_callback),\n                    Box::into_raw(Box::new(data)).cast(),\n                )\n            };\n\n            Ok(())\n        }\n\n        #[pymethod]\n        fn iterdump(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            let module = vm.import(\"sqlite3.dump\", 0)?;\n            let func = module.get_attr(\"_iterdump\", vm)?;\n            func.call((zelf,), vm)\n        }\n\n        #[pymethod]\n        fn interrupt(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // DO NOT check thread safety\n            self._db_lock(vm).map(|x| x.interrupt())\n        }\n\n        #[pymethod]\n        fn getlimit(&self, category: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, -1, vm)\n        }\n\n        #[pymethod]\n        fn setlimit(&self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.db_lock(vm)?.limit(category, limit, vm)\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>) -> PyRef<Self> {\n            zelf\n        }\n\n        #[pymethod]\n        fn __exit__(\n            &self,\n            cls: PyObjectRef,\n            exc: PyObjectRef,\n            tb: PyObjectRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            if vm.is_none(&cls) && vm.is_none(&exc) && vm.is_none(&tb) {\n                self.commit(vm)\n            } else {\n                self.rollback(vm)\n            }\n        }\n\n        #[pygetset]\n        fn isolation_level(&self) -> Option<PyStrRef> {\n            self.isolation_level.deref().map(|x| x.to_owned())\n        }\n        #[pygetset(setter)]\n        fn set_isolation_level(\n            &self,\n            value: PySetterValue<Option<PyStrRef>>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            match value {\n                PySetterValue::Assign(value) => {\n                    if let Some(val_str) = &value {\n                        begin_statement_ptr_from_isolation_level(val_str, vm)?;\n                    }\n\n                    // If setting isolation_level to None (auto-commit mode), commit any pending transaction\n                    if value.is_none() {\n                        let db = self.db_lock(vm)?;\n                        if !db.is_autocommit() {\n                            // Keep the lock and call implicit_commit directly to avoid race conditions\n                            db.implicit_commit(vm)?;\n                        }\n                    }\n                    let _ = unsafe { self.isolation_level.swap(value) };\n                    Ok(())\n                }\n                PySetterValue::Delete => Err(vm.new_attribute_error(\n                    \"'isolation_level' attribute cannot be deleted\".to_owned(),\n                )),\n            }\n        }\n\n        #[pygetset]\n        fn text_factory(&self) -> PyObjectRef {\n            self.text_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_text_factory(&self, val: PyObjectRef) {\n            let _ = unsafe { self.text_factory.swap(val) };\n        }\n\n        #[pygetset]\n        fn row_factory(&self) -> Option<PyObjectRef> {\n            self.row_factory.to_owned()\n        }\n        #[pygetset(setter)]\n        fn set_row_factory(&self, val: Option<PyObjectRef>) {\n            let _ = unsafe { self.row_factory.swap(val) };\n        }\n\n        fn check_thread(&self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.check_same_thread.load(Ordering::Relaxed) {\n                let creator_id = *self.thread_ident.lock();\n                if std::thread::current().id() != creator_id {\n                    return Err(new_programming_error(\n                        vm,\n                        \"SQLite objects created in a thread can only be used in that same thread.\"\n                            .to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n\n        #[pygetset]\n        fn in_transaction(&self, vm: &VirtualMachine) -> PyResult<bool> {\n            self._db_lock(vm).map(|x| !x.is_autocommit())\n        }\n\n        #[pygetset]\n        fn total_changes(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self._db_lock(vm).map(|x| x.total_changes())\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Cursor {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        arraysize: PyAtomic<c_int>,\n        #[pytraverse(skip)]\n        row_factory: PyAtomicRef<Option<PyObject>>,\n        inner: PyMutex<Option<CursorInner>>,\n    }\n\n    #[derive(Debug, Traverse)]\n    struct CursorInner {\n        description: Option<PyTupleRef>,\n        row_cast_map: Vec<Option<PyObjectRef>>,\n        #[pytraverse(skip)]\n        lastrowid: i64,\n        #[pytraverse(skip)]\n        rowcount: i64,\n        statement: Option<PyRef<Statement>>,\n        #[pytraverse(skip)]\n        closed: bool,\n    }\n\n    #[derive(FromArgs)]\n    struct FetchManyArgs {\n        #[pyarg(any, name = \"size\", optional)]\n        size: Option<c_int>,\n    }\n\n    #[pyclass(with(Constructor, IterNext, Iterable), flags(BASETYPE))]\n    impl Cursor {\n        fn new(\n            connection: PyRef<Connection>,\n            row_factory: Option<PyObjectRef>,\n            _vm: &VirtualMachine,\n        ) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(row_factory),\n                inner: PyMutex::from(Some(CursorInner {\n                    description: None,\n                    row_cast_map: vec![],\n                    lastrowid: -1,\n                    rowcount: -1,\n                    statement: None,\n                    closed: false,\n                })),\n            }\n        }\n\n        fn new_uninitialized(connection: PyRef<Connection>, _vm: &VirtualMachine) -> Self {\n            Self {\n                connection,\n                arraysize: Radium::new(1),\n                row_factory: PyAtomicRef::from(None),\n                inner: PyMutex::from(None),\n            }\n        }\n\n        #[pymethod]\n        fn __init__(&self, _connection: PyRef<Connection>, _vm: &VirtualMachine) -> PyResult<()> {\n            let mut guard = self.inner.lock();\n            if guard.is_some() {\n                // Already initialized (e.g., from a call to super().__init__)\n                return Ok(());\n            }\n            *guard = Some(CursorInner {\n                description: None,\n                row_cast_map: vec![],\n                lastrowid: -1,\n                rowcount: -1,\n                statement: None,\n                closed: false,\n            });\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, CursorInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                let inner_guard =\n                    PyMutexGuard::map(guard, |x| unsafe { x.as_mut().unwrap_unchecked() });\n                if inner_guard.closed {\n                    return Err(new_programming_error(\n                        vm,\n                        \"Cannot operate on a closed cursor.\".to_owned(),\n                    ));\n                }\n                Ok(inner_guard)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ))\n            }\n        }\n\n        #[pymethod]\n        fn execute(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            parameters: OptionalArg<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let st = stmt.lock();\n            let params_needed = st.bind_parameter_count();\n\n            if let OptionalArg::Present(parameters) = parameters {\n                st.bind_parameters(&parameters, vm)?;\n            } else if params_needed > 0 {\n                let msg = format!(\n                    \"Incorrect number of bindings supplied. The current statement uses {}, and 0 were supplied.\",\n                    params_needed\n                );\n                return Err(new_programming_error(vm, msg));\n            }\n\n            let ret = st.step();\n\n            if ret != SQLITE_DONE && ret != SQLITE_ROW {\n                if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                    return Err(exc);\n                }\n                return Err(db.error_extended(vm));\n            }\n\n            inner.row_cast_map = zelf.build_row_cast_map(&st, vm)?;\n\n            let detect_types = zelf.connection.detect_types.load(Ordering::Relaxed);\n            inner.description = st.columns_description(detect_types, vm)?;\n\n            if ret == SQLITE_ROW {\n                drop(st);\n                inner.statement = Some(stmt);\n            } else {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount += db.changes() as i64;\n                }\n            }\n\n            inner.lastrowid = db.lastrowid();\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executemany(\n            zelf: PyRef<Self>,\n            sql: PyUtf8StrRef,\n            seq_of_params: ArgIterable,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let mut inner = zelf.inner(vm)?;\n\n            if let Some(stmt) = inner.statement.take() {\n                stmt.lock().reset();\n            }\n\n            let Some(stmt) = Statement::new(&zelf.connection, sql, vm)? else {\n                drop(inner);\n                return Ok(zelf);\n            };\n            let stmt = stmt.into_ref(&vm.ctx);\n\n            let st = stmt.lock();\n\n            if st.readonly() {\n                return Err(new_programming_error(\n                    vm,\n                    \"executemany() can only execute DML statements.\".to_owned(),\n                ));\n            }\n\n            let detect_types = zelf.connection.detect_types.load(Ordering::Relaxed);\n            inner.description = st.columns_description(detect_types, vm)?;\n\n            inner.rowcount = if stmt.is_dml { 0 } else { -1 };\n\n            let db = zelf.connection.db_lock(vm)?;\n\n            if stmt.is_dml\n                && db.is_autocommit()\n                && zelf.connection.isolation_level.deref().is_some()\n            {\n                db.begin_transaction(\n                    zelf.connection\n                        .isolation_level\n                        .deref()\n                        .map(|x| x.to_owned()),\n                    vm,\n                )?;\n            }\n\n            let iter = seq_of_params.iter(vm)?;\n            for params in iter {\n                let params = params?;\n                st.bind_parameters(&params, vm)?;\n\n                if !st.step_row_else_done(vm)? {\n                    if stmt.is_dml {\n                        inner.rowcount += db.changes() as i64;\n                    }\n                    st.reset();\n                }\n\n                // if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                //     return Err(exc);\n                // }\n            }\n\n            if st.busy() {\n                drop(st);\n                inner.statement = Some(stmt);\n            }\n\n            drop(inner);\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn executescript(\n            zelf: PyRef<Self>,\n            script: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<Self>> {\n            let db = zelf.connection.db_lock(vm)?;\n\n            db.sql_limit(script.byte_len(), vm)?;\n\n            db.implicit_commit(vm)?;\n\n            let script = script.to_cstring(vm)?;\n            let mut ptr = script.as_ptr();\n\n            while let Some(st) = db.prepare(ptr, &mut ptr, vm)? {\n                while st.step_row_else_done(vm)? {}\n            }\n\n            drop(db);\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn fetchone(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult {\n            Self::next(zelf, vm).map(|x| match x {\n                PyIterReturn::Return(row) => row,\n                PyIterReturn::StopIteration(_) => vm.ctx.none(),\n            })\n        }\n\n        #[pymethod]\n        fn fetchmany(\n            zelf: &Py<Self>,\n            args: FetchManyArgs,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<PyObjectRef>> {\n            let max_rows = args\n                .size\n                .unwrap_or_else(|| zelf.arraysize.load(Ordering::Relaxed));\n\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Cursor::next(zelf, vm)? {\n                list.push(row);\n                if max_rows > 0 && list.len() as c_int >= max_rows {\n                    break;\n                }\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn fetchall(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            let mut list = vec![];\n            while let PyIterReturn::Return(row) = Self::next(zelf, vm)? {\n                list.push(row);\n            }\n            Ok(list)\n        }\n\n        #[pymethod]\n        fn close(&self, vm: &VirtualMachine) -> PyResult<()> {\n            // Check if __init__ was called\n            let mut guard = self.inner.lock();\n            if guard.is_none() {\n                return Err(new_programming_error(\n                    vm,\n                    \"Base Cursor.__init__ not called.\".to_owned(),\n                ));\n            }\n\n            if let Some(inner) = guard.as_mut() {\n                if let Some(stmt) = &inner.statement {\n                    stmt.lock().reset();\n                }\n                inner.closed = true;\n            }\n            Ok(())\n        }\n\n        #[pymethod]\n        fn setinputsizes(&self, _sizes: PyObjectRef) {}\n        #[pymethod]\n        fn setoutputsize(&self, _size: PyObjectRef, _column: OptionalArg<PyObjectRef>) {}\n\n        #[pygetset]\n        fn connection(&self) -> PyRef<Connection> {\n            self.connection.clone()\n        }\n\n        #[pygetset]\n        fn lastrowid(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.lastrowid)\n        }\n\n        #[pygetset]\n        fn rowcount(&self, vm: &VirtualMachine) -> PyResult<i64> {\n            self.inner(vm).map(|x| x.rowcount)\n        }\n\n        #[pygetset]\n        fn description(&self, vm: &VirtualMachine) -> PyResult<Option<PyTupleRef>> {\n            self.inner(vm).map(|x| x.description.clone())\n        }\n\n        #[pygetset]\n        fn arraysize(&self) -> c_int {\n            self.arraysize.load(Ordering::Relaxed)\n        }\n        #[pygetset(setter)]\n        fn set_arraysize(&self, val: c_int) {\n            self.arraysize.store(val, Ordering::Relaxed);\n        }\n\n        fn build_row_cast_map(\n            &self,\n            st: &SqliteStatementRaw,\n            vm: &VirtualMachine,\n        ) -> PyResult<Vec<Option<PyObjectRef>>> {\n            let detect_types = self.connection.detect_types.load(Ordering::Relaxed);\n            if detect_types == 0 {\n                return Ok(vec![]);\n            }\n\n            let mut cast_map = vec![];\n            let num_cols = st.column_count();\n\n            for i in 0..num_cols {\n                if detect_types & PARSE_COLNAMES != 0 {\n                    let col_name = st.column_name(i);\n                    let col_name = ptr_to_str(col_name, vm)?;\n                    let col_name = col_name\n                        .chars()\n                        .skip_while(|&x| x != '[')\n                        .skip(1)\n                        .take_while(|&x| x != ']')\n                        .flat_map(|x| x.to_uppercase())\n                        .collect::<String>();\n                    if let Some(converter) = converters().get_item_opt(&col_name, vm)? {\n                        cast_map.push(Some(converter.clone()));\n                        continue;\n                    }\n                }\n                if detect_types & PARSE_DECLTYPES != 0 {\n                    let decltype = st.column_decltype(i);\n                    let decltype = ptr_to_str(decltype, vm)?;\n                    if let Some(decltype) = decltype.split_terminator(&[' ', '(']).next() {\n                        let decltype = decltype.to_uppercase();\n                        if let Some(converter) = converters().get_item_opt(&decltype, vm)? {\n                            cast_map.push(Some(converter.clone()));\n                            continue;\n                        }\n                    }\n                }\n                cast_map.push(None);\n            }\n\n            Ok(cast_map)\n        }\n    }\n\n    impl Constructor for Cursor {\n        type Args = (PyRef<Connection>,);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            Self::new_uninitialized(args.0, vm)\n                .into_ref_with_type(vm, cls)\n                .map(Into::into)\n        }\n    }\n\n    impl SelfIter for Cursor {}\n    impl IterNext for Cursor {\n        fn next(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyIterReturn> {\n            let mut inner = zelf.inner(vm)?;\n            let Some(stmt) = &inner.statement else {\n                return Ok(PyIterReturn::StopIteration(None));\n            };\n            let st = stmt.lock();\n            let db = zelf.connection.db_lock(vm)?;\n            // fetch_one_row\n\n            let num_cols = st.data_count();\n\n            let mut row = Vec::with_capacity(num_cols as usize);\n\n            for i in 0..num_cols {\n                let val = if let Some(converter) =\n                    inner.row_cast_map.get(i as usize).cloned().flatten()\n                {\n                    let blob = st.column_blob(i);\n                    if blob.is_null() {\n                        vm.ctx.none()\n                    } else {\n                        let nbytes = st.column_bytes(i);\n                        let blob = unsafe {\n                            std::slice::from_raw_parts(blob.cast::<u8>(), nbytes as usize)\n                        };\n                        let blob = vm.ctx.new_bytes(blob.to_vec());\n                        converter.call((blob,), vm)?\n                    }\n                } else {\n                    let col_type = st.column_type(i);\n                    match col_type {\n                        SQLITE_NULL => vm.ctx.none(),\n                        SQLITE_INTEGER => vm.ctx.new_int(st.column_int(i)).into(),\n                        SQLITE_FLOAT => vm.ctx.new_float(st.column_double(i)).into(),\n                        SQLITE_TEXT => {\n                            let text =\n                                ptr_to_vec(st.column_text(i), st.column_bytes(i), db.db, vm)?;\n\n                            let text_factory = zelf.connection.text_factory.to_owned();\n\n                            if text_factory.is(PyStr::class(&vm.ctx)) {\n                                let text = String::from_utf8(text).map_err(|err| {\n                                    let col_name = st.column_name(i);\n                                    let col_name_str = ptr_to_str(col_name, vm).unwrap_or(\"?\");\n                                    let valid_up_to = err.utf8_error().valid_up_to();\n                                    let text_prefix = String::from_utf8_lossy(&err.as_bytes()[..valid_up_to]);\n                                    let msg = format!(\n                                        \"Could not decode to UTF-8 column '{col_name_str}' with text '{text_prefix}'\"\n                                    );\n                                    new_operational_error(vm, msg)\n                                })?;\n                                vm.ctx.new_str(text).into()\n                            } else if text_factory.is(PyBytes::class(&vm.ctx)) {\n                                vm.ctx.new_bytes(text).into()\n                            } else if text_factory.is(PyByteArray::class(&vm.ctx)) {\n                                PyByteArray::from(text).into_ref(&vm.ctx).into()\n                            } else {\n                                let bytes = vm.ctx.new_bytes(text);\n                                text_factory.call((bytes,), vm)?\n                            }\n                        }\n                        SQLITE_BLOB => {\n                            let blob = ptr_to_vec(\n                                st.column_blob(i).cast(),\n                                st.column_bytes(i),\n                                db.db,\n                                vm,\n                            )?;\n\n                            vm.ctx.new_bytes(blob).into()\n                        }\n                        _ => {\n                            return Err(vm.new_not_implemented_error(format!(\n                                \"unknown column type: {col_type}\"\n                            )));\n                        }\n                    }\n                };\n\n                row.push(val);\n            }\n\n            if !st.step_row_else_done(vm)? {\n                st.reset();\n                drop(st);\n                if stmt.is_dml {\n                    inner.rowcount = db.changes() as i64;\n                }\n                inner.statement = None;\n            } else {\n                drop(st);\n            }\n\n            drop(db);\n            drop(inner);\n\n            let row = vm.ctx.new_tuple(row);\n\n            if let Some(row_factory) = zelf.row_factory.to_owned() {\n                row_factory\n                    .call((zelf.to_owned(), row), vm)\n                    .map(PyIterReturn::Return)\n            } else {\n                Ok(PyIterReturn::Return(row.into()))\n            }\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name, traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Row {\n        data: PyTupleRef,\n        description: PyTupleRef,\n    }\n\n    #[pyclass(\n        with(Constructor, Hashable, Comparable, Iterable, AsMapping, AsSequence),\n        flags(BASETYPE)\n    )]\n    impl Row {\n        #[pymethod]\n        fn keys(&self, _vm: &VirtualMachine) -> PyResult<Vec<PyObjectRef>> {\n            Ok(self\n                .description\n                .iter()\n                .map(|x| x.downcast_ref::<PyTuple>().unwrap().as_slice()[0].clone())\n                .collect())\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            if let Some(i) = needle.downcast_ref::<PyInt>() {\n                let i = i.try_to_primitive::<isize>(vm)?;\n                self.data.getitem_by_index(vm, i)\n            } else if let Some(name) = needle.downcast_ref::<PyStr>() {\n                for (obj, i) in self.description.iter().zip(0..) {\n                    let obj = &obj.downcast_ref::<PyTuple>().unwrap().as_slice()[0];\n                    let Some(obj) = obj.downcast_ref::<PyStr>() else {\n                        break;\n                    };\n                    let a_iter = name.as_str().chars().flat_map(|x| x.to_uppercase());\n                    let b_iter = obj.as_str().chars().flat_map(|x| x.to_uppercase());\n\n                    if a_iter.eq(b_iter) {\n                        return self.data.getitem_by_index(vm, i);\n                    }\n                }\n                Err(vm.new_index_error(\"No item with that key\"))\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let list = self.data.getitem_by_slice(vm, slice.to_saturated(vm)?)?;\n                Ok(vm.ctx.new_tuple(list).into())\n            } else {\n                Err(vm.new_index_error(\"Index must be int or string\"))\n            }\n        }\n    }\n\n    impl Constructor for Row {\n        type Args = (PyRef<Cursor>, PyTupleRef);\n\n        fn py_new(cls: PyTypeRef, args: Self::Args, vm: &VirtualMachine) -> PyResult {\n            let description = args\n                .0\n                .inner(vm)?\n                .description\n                .clone()\n                .ok_or_else(|| vm.new_value_error(\"no description in Cursor\"))?;\n\n            Self {\n                data: args.1,\n                description,\n            }\n            .into_ref_with_type(vm, cls)\n            .map(Into::into)\n        }\n    }\n\n    impl Hashable for Row {\n        fn hash(zelf: &Py<Self>, vm: &VirtualMachine) -> PyResult<PyHash> {\n            Ok(zelf.description.as_object().hash(vm)? | zelf.data.as_object().hash(vm)?)\n        }\n    }\n\n    impl Comparable for Row {\n        fn cmp(\n            zelf: &Py<Self>,\n            other: &PyObject,\n            op: PyComparisonOp,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyComparisonValue> {\n            op.eq_only(|| {\n                if let Some(other) = other.downcast_ref::<Self>() {\n                    let eq = vm\n                        .bool_eq(zelf.description.as_object(), other.description.as_object())?\n                        && vm.bool_eq(zelf.data.as_object(), other.data.as_object())?;\n                    Ok(eq.into())\n                } else {\n                    Ok(PyComparisonValue::NotImplemented)\n                }\n            })\n        }\n    }\n\n    impl Iterable for Row {\n        fn iter(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult {\n            Iterable::iter(zelf.data.clone(), vm)\n        }\n    }\n\n    impl AsMapping for Row {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: std::sync::LazyLock<PyMappingMethods> =\n                std::sync::LazyLock::new(|| PyMappingMethods {\n                    length: atomic_func!(|mapping, _vm| Ok(Row::mapping_downcast(mapping)\n                        .data\n                        .len())),\n                    subscript: atomic_func!(|mapping, needle, vm| {\n                        Row::mapping_downcast(mapping).subscript(needle, vm)\n                    }),\n                    ..PyMappingMethods::NOT_IMPLEMENTED\n                });\n            &AS_MAPPING\n        }\n    }\n\n    impl AsSequence for Row {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: std::sync::LazyLock<PySequenceMethods> =\n                std::sync::LazyLock::new(|| PySequenceMethods {\n                    length: atomic_func!(|seq, _vm| Ok(Row::sequence_downcast(seq).data.len())),\n                    item: atomic_func!(|seq, i, vm| Row::sequence_downcast(seq)\n                        .data\n                        .getitem_by_index(vm, i)),\n                    ..PySequenceMethods::NOT_IMPLEMENTED\n                });\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Blob\", traverse)]\n    #[derive(Debug, PyPayload)]\n    struct Blob {\n        connection: PyRef<Connection>,\n        #[pytraverse(skip)]\n        inner: PyMutex<Option<BlobInner>>,\n    }\n\n    impl Unconstructible for Blob {}\n\n    #[derive(Debug)]\n    struct BlobInner {\n        blob: SqliteBlob,\n        offset: c_int,\n    }\n\n    impl Drop for BlobInner {\n        fn drop(&mut self) {\n            unsafe { sqlite3_blob_close(self.blob.blob) };\n        }\n    }\n\n    #[pyclass(with(AsMapping, Unconstructible, AsNumber, AsSequence))]\n    impl Blob {\n        #[pymethod]\n        fn close(&self) {\n            self.inner.lock().take();\n        }\n\n        #[pymethod]\n        fn read(\n            &self,\n            length: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<PyRef<PyBytes>> {\n            let mut length = length.unwrap_or(-1);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let max_read = blob_len - inner.offset;\n\n            if length < 0 || length > max_read {\n                length = max_read;\n            }\n\n            if length == 0 {\n                Ok(vm.ctx.empty_bytes.clone())\n            } else {\n                let mut buf = Vec::<u8>::with_capacity(length as usize);\n                let ret = inner\n                    .blob\n                    .read(buf.as_mut_ptr().cast(), length, inner.offset);\n                self.check(ret, vm)?;\n                unsafe { buf.set_len(length as usize) };\n                inner.offset += length;\n                Ok(vm.ctx.new_bytes(buf))\n            }\n        }\n\n        #[pymethod]\n        fn write(&self, data: PyBuffer, vm: &VirtualMachine) -> PyResult<()> {\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n            let length = Self::expect_write(blob_len, data.desc.len, inner.offset, vm)?;\n\n            let ret = data.contiguous_or_collect(|buf| {\n                inner.blob.write(buf.as_ptr().cast(), length, inner.offset)\n            });\n\n            self.check(ret, vm)?;\n            inner.offset += length;\n            Ok(())\n        }\n\n        #[pymethod]\n        fn tell(&self, vm: &VirtualMachine) -> PyResult<c_int> {\n            self.inner(vm).map(|x| x.offset)\n        }\n\n        #[pymethod]\n        fn seek(\n            &self,\n            mut offset: c_int,\n            origin: OptionalArg<c_int>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let origin = origin.unwrap_or(libc::SEEK_SET);\n            let mut inner = self.inner(vm)?;\n            let blob_len = inner.blob.bytes();\n\n            let overflow_err = || vm.new_overflow_error(\"seek offset results in overflow\");\n\n            match origin {\n                libc::SEEK_SET => {}\n                libc::SEEK_CUR => {\n                    offset = offset.checked_add(inner.offset).ok_or_else(overflow_err)?\n                }\n                libc::SEEK_END => offset = offset.checked_add(blob_len).ok_or_else(overflow_err)?,\n                _ => {\n                    return Err(vm.new_value_error(\n                        \"'origin' should be os.SEEK_SET, os.SEEK_CUR, or os.SEEK_END\",\n                    ));\n                }\n            }\n\n            if offset < 0 || offset > blob_len {\n                Err(vm.new_value_error(\"offset out of blob range\"))\n            } else {\n                inner.offset = offset;\n                Ok(())\n            }\n        }\n\n        #[pymethod]\n        fn __enter__(zelf: PyRef<Self>, vm: &VirtualMachine) -> PyResult<PyRef<Self>> {\n            let _ = zelf.inner(vm)?;\n            Ok(zelf)\n        }\n\n        #[pymethod]\n        fn __exit__(&self, _args: FuncArgs, vm: &VirtualMachine) -> PyResult<()> {\n            let _ = self.inner(vm)?;\n            self.close();\n            Ok(())\n        }\n\n        fn inner(&self, vm: &VirtualMachine) -> PyResult<PyMappedMutexGuard<'_, BlobInner>> {\n            let guard = self.inner.lock();\n            if guard.is_some() {\n                Ok(PyMutexGuard::map(guard, |x| unsafe {\n                    x.as_mut().unwrap_unchecked()\n                }))\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"Cannot operate on a closed blob.\".to_owned(),\n                ))\n            }\n        }\n\n        fn wrapped_index(index: PyIntRef, length: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let mut index = index.try_to_primitive::<c_int>(vm)?;\n            if index < 0 {\n                index += length;\n            }\n            if index < 0 || index >= length {\n                Err(vm.new_index_error(\"Blob index out of range\"))\n            } else {\n                Ok(index)\n            }\n        }\n\n        fn expect_write(\n            blob_len: c_int,\n            length: usize,\n            offset: c_int,\n            vm: &VirtualMachine,\n        ) -> PyResult<c_int> {\n            let max_write = blob_len - offset;\n            if length <= max_write as usize {\n                Ok(length as c_int)\n            } else {\n                Err(vm.new_value_error(\"data longer than blob length\"))\n            }\n        }\n\n        fn subscript(&self, needle: &PyObject, vm: &VirtualMachine) -> PyResult {\n            let inner = self.inner(vm)?;\n            if let Some(index) = needle.try_index_opt(vm) {\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                let mut byte: u8 = 0;\n                let ret = inner.blob.read_single(&mut byte, index);\n                self.check(ret, vm).map(|_| vm.ctx.new_int(byte).into())\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, length) = slice.adjust_indices(blob_len as usize);\n                let mut buf = Vec::<u8>::with_capacity(length);\n\n                if step == 1 {\n                    let ret = inner.blob.read(\n                        buf.as_mut_ptr().cast(),\n                        length as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n                    unsafe { buf.set_len(length) };\n                } else {\n                    let iter = SaturatedSliceIter::from_adjust_indices(range, step, length);\n                    let mut byte: u8 = 0;\n                    for index in iter {\n                        let ret = inner.blob.read_single(&mut byte, index as c_int);\n                        self.check(ret, vm)?;\n                        buf.push(byte);\n                    }\n                }\n                Ok(vm.ctx.new_bytes(buf).into())\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn ass_subscript(\n            &self,\n            needle: &PyObject,\n            value: Option<PyObjectRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(value) = value else {\n                return Err(vm.new_type_error(\"Blob doesn't support slice deletion\"));\n            };\n            let inner = self.inner(vm)?;\n\n            if let Some(index) = needle.try_index_opt(vm) {\n                // Handle single item assignment: blob[i] = b\n                let Some(value) = value.downcast_ref::<PyInt>() else {\n                    return Err(vm.new_type_error(format!(\n                        \"'{}' object cannot be interpreted as an integer\",\n                        value.class()\n                    )));\n                };\n                let value = value.try_to_primitive::<u8>(vm)?;\n                let blob_len = inner.blob.bytes();\n                let index = Self::wrapped_index(index?, blob_len, vm)?;\n                Self::expect_write(blob_len, 1, index, vm)?;\n                let ret = inner.blob.write_single(value, index);\n                self.check(ret, vm)\n            } else if let Some(slice) = needle.downcast_ref::<PySlice>() {\n                // Handle slice assignment: blob[a:b:c] = b\"...\"\n                let value_buf = PyBuffer::try_from_borrowed_object(vm, &value)?;\n\n                let buf = value_buf\n                    .as_contiguous()\n                    .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n\n                let blob_len = inner.blob.bytes();\n                let slice = slice.to_saturated(vm)?;\n                let (range, step, slice_len) = slice.adjust_indices(blob_len as usize);\n\n                if step == 0 {\n                    return Err(vm.new_value_error(\"slice step cannot be zero\"));\n                }\n\n                if buf.len() != slice_len {\n                    return Err(vm.new_index_error(\"Blob slice assignment is wrong size\"));\n                }\n\n                if slice_len == 0 {\n                    return Ok(());\n                }\n\n                if step == 1 {\n                    let ret = inner.blob.write(\n                        buf.as_ptr().cast(),\n                        buf.len() as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                } else {\n                    let span_len = range.end - range.start;\n                    let mut temp_buf = vec![0u8; span_len];\n\n                    let ret = inner.blob.read(\n                        temp_buf.as_mut_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)?;\n\n                    let mut i_in_temp: usize = 0;\n                    for i_in_src in 0..slice_len {\n                        temp_buf[i_in_temp] = buf[i_in_src];\n                        i_in_temp += step as usize;\n                    }\n\n                    let ret = inner.blob.write(\n                        temp_buf.as_ptr().cast(),\n                        span_len as c_int,\n                        range.start as c_int,\n                    );\n                    self.check(ret, vm)\n                }\n            } else {\n                Err(vm.new_type_error(\"Blob indices must be integers\"))\n            }\n        }\n\n        fn check(&self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.connection.db_lock(vm)?.error_extended(vm))\n            }\n        }\n    }\n\n    impl AsMapping for Blob {\n        fn as_mapping() -> &'static PyMappingMethods {\n            static AS_MAPPING: PyMappingMethods = PyMappingMethods {\n                length: atomic_func!(|mapping, vm| Blob::mapping_downcast(mapping)\n                    .inner(vm)\n                    .map(|x| x.blob.bytes() as usize)),\n                subscript: atomic_func!(|mapping, needle, vm| {\n                    Blob::mapping_downcast(mapping).subscript(needle, vm)\n                }),\n                ass_subscript: atomic_func!(|mapping, needle, value, vm| {\n                    Blob::mapping_downcast(mapping).ass_subscript(needle, value, vm)\n                }),\n            };\n            &AS_MAPPING\n        }\n    }\n\n    impl AsNumber for Blob {\n        fn as_number() -> &'static PyNumberMethods {\n            static AS_NUMBER: PyNumberMethods = PyNumberMethods {\n                add: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for +: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                multiply: Some(|a, b, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"unsupported operand type(s) for *: '{}' and '{}'\",\n                        a.class().name(),\n                        b.class().name()\n                    )))\n                }),\n                ..PyNumberMethods::NOT_IMPLEMENTED\n            };\n            &AS_NUMBER\n        }\n    }\n\n    impl AsSequence for Blob {\n        fn as_sequence() -> &'static PySequenceMethods {\n            static AS_SEQUENCE: PySequenceMethods = PySequenceMethods {\n                length: AtomicCell::new(None),\n                concat: AtomicCell::new(None),\n                repeat: AtomicCell::new(None),\n                item: AtomicCell::new(None),\n                ass_item: AtomicCell::new(None),\n                contains: atomic_func!(|seq, _needle, vm| {\n                    Err(vm.new_type_error(format!(\n                        \"argument of type '{}' is not iterable\",\n                        seq.obj.class().name(),\n                    )))\n                }),\n                inplace_concat: AtomicCell::new(None),\n                inplace_repeat: AtomicCell::new(None),\n            };\n            &AS_SEQUENCE\n        }\n    }\n\n    #[pyattr]\n    #[pyclass(name)]\n    #[derive(Debug, PyPayload)]\n    struct PrepareProtocol {}\n\n    #[pyclass()]\n    impl PrepareProtocol {}\n\n    #[pyattr]\n    #[pyclass(module = \"sqlite3\", name = \"Statement\")]\n    #[derive(PyPayload)]\n    struct Statement {\n        st: PyMutex<SqliteStatement>,\n        pub is_dml: bool,\n    }\n\n    impl Debug for Statement {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n            write!(\n                f,\n                \"{} Statement\",\n                if self.is_dml { \"DML\" } else { \"Non-DML\" }\n            )\n        }\n    }\n\n    impl Unconstructible for Statement {}\n\n    #[pyclass(with(Unconstructible))]\n    impl Statement {\n        fn new(\n            connection: &Connection,\n            sql: PyUtf8StrRef,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<Self>> {\n            if sql.as_str().contains('\\0') {\n                return Err(new_programming_error(\n                    vm,\n                    \"statement contains a null character.\".to_owned(),\n                ));\n            }\n            let sql_cstr = sql.to_cstring(vm)?;\n\n            let db = connection.db_lock(vm)?;\n\n            db.sql_limit(sql.byte_len(), vm)?;\n\n            let mut tail = null();\n            let st = db.prepare(sql_cstr.as_ptr(), &mut tail, vm)?;\n\n            let Some(st) = st else {\n                return Ok(None);\n            };\n\n            let tail = unsafe { CStr::from_ptr(tail) };\n            let tail = tail.to_bytes();\n            if lstrip_sql(tail).is_some() {\n                return Err(new_programming_error(\n                    vm,\n                    \"You can only execute one statement at a time.\".to_owned(),\n                ));\n            }\n\n            let is_dml = if let Some(head) = lstrip_sql(sql_cstr.as_bytes()) {\n                head.len() >= 6\n                    && (head[..6].eq_ignore_ascii_case(b\"insert\")\n                        || head[..6].eq_ignore_ascii_case(b\"update\")\n                        || head[..6].eq_ignore_ascii_case(b\"delete\")\n                        || (head.len() >= 7 && head[..7].eq_ignore_ascii_case(b\"replace\")))\n            } else {\n                false\n            };\n\n            Ok(Some(Self {\n                st: PyMutex::from(st),\n                is_dml,\n            }))\n        }\n\n        fn lock(&self) -> PyMutexGuard<'_, SqliteStatement> {\n            self.st.lock()\n        }\n    }\n\n    struct Sqlite {\n        raw: SqliteRaw,\n    }\n\n    impl From<SqliteRaw> for Sqlite {\n        fn from(raw: SqliteRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for Sqlite {\n        fn drop(&mut self) {\n            unsafe { sqlite3_close_v2(self.raw.db) };\n        }\n    }\n\n    impl Deref for Sqlite {\n        type Target = SqliteRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteRaw {\n        db: *mut sqlite3,\n    }\n\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"threading\")] {\n            unsafe impl Send for SqliteStatement {}\n            // unsafe impl Sync for SqliteStatement {}\n            unsafe impl Send for Sqlite {}\n            // unsafe impl Sync for Sqlite {}\n            unsafe impl Send for SqliteBlob {}\n        }\n    }\n\n    impl From<SqliteStatementRaw> for SqliteRaw {\n        fn from(stmt: SqliteStatementRaw) -> Self {\n            unsafe {\n                Self {\n                    db: sqlite3_db_handle(stmt.st),\n                }\n            }\n        }\n    }\n\n    impl SqliteRaw {\n        fn check(self, ret: c_int, vm: &VirtualMachine) -> PyResult<()> {\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                Err(self.error_extended(vm))\n            }\n        }\n\n        fn error_extended(self, vm: &VirtualMachine) -> PyBaseExceptionRef {\n            let errcode = unsafe { sqlite3_errcode(self.db) };\n            let typ = exception_type_from_errcode(errcode, vm);\n            let extended_errcode = unsafe { sqlite3_extended_errcode(self.db) };\n            let errmsg = unsafe { sqlite3_errmsg(self.db) };\n            let errmsg = unsafe { CStr::from_ptr(errmsg) };\n            let errmsg = errmsg.to_str().unwrap().to_owned();\n\n            raise_exception(typ.to_owned(), extended_errcode, errmsg, vm)\n        }\n\n        fn open(path: *const libc::c_char, uri: bool, vm: &VirtualMachine) -> PyResult<Self> {\n            let mut db = null_mut();\n            let ret = unsafe {\n                sqlite3_open_v2(\n                    path,\n                    &raw mut db,\n                    SQLITE_OPEN_READWRITE\n                        | SQLITE_OPEN_CREATE\n                        | if uri { SQLITE_OPEN_URI } else { 0 },\n                    null(),\n                )\n            };\n            let zelf = Self { db };\n            zelf.check(ret, vm).map(|_| zelf)\n        }\n\n        fn _exec(self, sql: &[u8], vm: &VirtualMachine) -> PyResult<()> {\n            let ret =\n                unsafe { sqlite3_exec(self.db, sql.as_ptr().cast(), None, null_mut(), null_mut()) };\n            self.check(ret, vm)\n        }\n\n        fn prepare(\n            self,\n            sql: *const libc::c_char,\n            tail: *mut *const libc::c_char,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<SqliteStatement>> {\n            let mut st = null_mut();\n            let ret = unsafe { sqlite3_prepare_v2(self.db, sql, -1, &mut st, tail) };\n            self.check(ret, vm)?;\n            if st.is_null() {\n                Ok(None)\n            } else {\n                Ok(Some(SqliteStatement::from(SqliteStatementRaw::from(st))))\n            }\n        }\n\n        fn limit(self, category: c_int, limit: c_int, vm: &VirtualMachine) -> PyResult<c_int> {\n            let old_limit = unsafe { sqlite3_limit(self.db, category, limit) };\n            if old_limit >= 0 {\n                Ok(old_limit)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"'category' is out of bounds\".to_owned(),\n                ))\n            }\n        }\n\n        fn sql_limit(self, len: usize, vm: &VirtualMachine) -> PyResult<()> {\n            if len <= unsafe { sqlite3_limit(self.db, SQLITE_LIMIT_SQL_LENGTH, -1) } as usize {\n                Ok(())\n            } else {\n                Err(new_data_error(vm, \"query string is too large\".to_owned()))\n            }\n        }\n\n        fn is_autocommit(self) -> bool {\n            unsafe { sqlite3_get_autocommit(self.db) != 0 }\n        }\n\n        fn changes(self) -> c_int {\n            unsafe { sqlite3_changes(self.db) }\n        }\n\n        fn total_changes(self) -> c_int {\n            unsafe { sqlite3_total_changes(self.db) }\n        }\n\n        fn lastrowid(self) -> c_longlong {\n            unsafe { sqlite3_last_insert_rowid(self.db) }\n        }\n\n        fn implicit_commit(self, vm: &VirtualMachine) -> PyResult<()> {\n            if self.is_autocommit() {\n                Ok(())\n            } else {\n                self._exec(b\"COMMIT\\0\", vm)\n            }\n        }\n\n        fn begin_transaction(\n            self,\n            isolation_level: Option<PyStrRef>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let Some(isolation_level) = isolation_level else {\n                return Ok(());\n            };\n            let mut s = Vec::with_capacity(16);\n            s.extend(b\"BEGIN \");\n            s.extend(isolation_level.as_str().bytes());\n            s.push(b'\\0');\n            self._exec(&s, vm)\n        }\n\n        fn interrupt(self) {\n            unsafe { sqlite3_interrupt(self.db) }\n        }\n\n        fn busy_timeout(self, timeout: i32) {\n            unsafe { sqlite3_busy_timeout(self.db, timeout) };\n        }\n\n        #[allow(clippy::too_many_arguments)]\n        fn create_function(\n            self,\n            name: *const libc::c_char,\n            narg: c_int,\n            flags: c_int,\n            data: *mut c_void,\n            func: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            step: Option<\n                unsafe extern \"C\" fn(\n                    arg1: *mut sqlite3_context,\n                    arg2: c_int,\n                    arg3: *mut *mut sqlite3_value,\n                ),\n            >,\n            finalize: Option<unsafe extern \"C\" fn(arg1: *mut sqlite3_context)>,\n            destroy: Option<unsafe extern \"C\" fn(arg1: *mut c_void)>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let ret = unsafe {\n                sqlite3_create_function_v2(\n                    self.db, name, narg, flags, data, func, step, finalize, destroy,\n                )\n            };\n            self.check(ret, vm)\n                .map_err(|_| new_operational_error(vm, \"Error creating function\".to_owned()))\n        }\n    }\n\n    struct SqliteStatement {\n        raw: SqliteStatementRaw,\n    }\n\n    impl From<SqliteStatementRaw> for SqliteStatement {\n        fn from(raw: SqliteStatementRaw) -> Self {\n            Self { raw }\n        }\n    }\n\n    impl Drop for SqliteStatement {\n        fn drop(&mut self) {\n            unsafe {\n                sqlite3_finalize(self.raw.st);\n            }\n        }\n    }\n\n    impl Deref for SqliteStatement {\n        type Target = SqliteStatementRaw;\n\n        fn deref(&self) -> &Self::Target {\n            &self.raw\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteStatementRaw {\n        st: *mut sqlite3_stmt,\n    }\n\n    impl From<*mut sqlite3_stmt> for SqliteStatementRaw {\n        fn from(st: *mut sqlite3_stmt) -> Self {\n            SqliteStatementRaw { st }\n        }\n    }\n\n    impl SqliteStatementRaw {\n        fn step(self) -> c_int {\n            unsafe { sqlite3_step(self.st) }\n        }\n\n        fn step_row_else_done(self, vm: &VirtualMachine) -> PyResult<bool> {\n            let ret = self.step();\n\n            if let Some(exc) = unsafe { user_function_exception().swap(None) } {\n                Err(exc)\n            } else if ret == SQLITE_ROW {\n                Ok(true)\n            } else if ret == SQLITE_DONE {\n                Ok(false)\n            } else {\n                Err(SqliteRaw::from(self).error_extended(vm))\n            }\n        }\n\n        fn reset(self) {\n            unsafe { sqlite3_reset(self.st) };\n        }\n\n        fn data_count(self) -> c_int {\n            unsafe { sqlite3_data_count(self.st) }\n        }\n\n        fn bind_parameter(\n            self,\n            pos: c_int,\n            parameter: &PyObject,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let adapted;\n            let obj = if need_adapt(parameter, vm) {\n                adapted = _adapt(\n                    parameter,\n                    PrepareProtocol::class(&vm.ctx).to_owned(),\n                    |x| Ok(x.to_owned()),\n                    vm,\n                )?;\n                &adapted\n            } else {\n                parameter\n            };\n\n            let ret = if vm.is_none(obj) {\n                unsafe { sqlite3_bind_null(self.st, pos) }\n            } else if let Some(val) = obj.downcast_ref::<PyInt>() {\n                let val = val.try_to_primitive::<i64>(vm).map_err(|_| {\n                    vm.new_overflow_error(\"Python int too large to convert to SQLite INTEGER\")\n                })?;\n                unsafe { sqlite3_bind_int64(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyFloat>() {\n                let val = val.to_f64();\n                unsafe { sqlite3_bind_double(self.st, pos, val) }\n            } else if let Some(val) = obj.downcast_ref::<PyStr>() {\n                let val = val.try_as_utf8(vm)?;\n                let (ptr, len) = str_to_ptr_len(val, vm)?;\n                unsafe { sqlite3_bind_text(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, obj) {\n                let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                unsafe { sqlite3_bind_blob(self.st, pos, ptr, len, SQLITE_TRANSIENT()) }\n            } else {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Error binding parameter {}: type '{}' is not supported\",\n                        pos,\n                        obj.class()\n                    ),\n                ));\n            };\n\n            if ret == SQLITE_OK {\n                Ok(())\n            } else {\n                let db = SqliteRaw::from(self);\n                db.check(ret, vm)\n            }\n        }\n\n        fn bind_parameters(self, parameters: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            if let Some(dict) = parameters.downcast_ref::<PyDict>() {\n                self.bind_parameters_name(dict, vm)\n            } else if let Ok(seq) = PySequence::try_protocol(parameters, vm) {\n                self.bind_parameters_sequence(seq, vm)\n            } else {\n                Err(new_programming_error(\n                    vm,\n                    \"parameters are of unsupported type\".to_owned(),\n                ))\n            }\n        }\n\n        fn bind_parameters_name(self, dict: &Py<PyDict>, vm: &VirtualMachine) -> PyResult<()> {\n            let num_needed = unsafe { sqlite3_bind_parameter_count(self.st) };\n\n            for i in 1..=num_needed {\n                let name = unsafe { sqlite3_bind_parameter_name(self.st, i) };\n                if name.is_null() {\n                    return Err(new_programming_error(vm, \"Binding {} has no name, but you supplied a dictionary (which has only names).\".to_owned()));\n                }\n                let name = unsafe { name.add(1) };\n                let name = ptr_to_str(name, vm)?;\n\n                let val = match dict.get_item_opt(name, vm)? {\n                    Some(val) => val,\n                    None => {\n                        return Err(new_programming_error(\n                            vm,\n                            format!(\"You did not supply a value for binding parameter :{name}.\",),\n                        ));\n                    }\n                };\n\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn bind_parameter_count(self) -> c_int {\n            unsafe { sqlite3_bind_parameter_count(self.st) }\n        }\n\n        fn bind_parameters_sequence(\n            self,\n            seq: PySequence<'_>,\n            vm: &VirtualMachine,\n        ) -> PyResult<()> {\n            let num_needed = self.bind_parameter_count();\n            let num_supplied = seq.length(vm)?;\n\n            if num_supplied != num_needed as usize {\n                return Err(new_programming_error(\n                    vm,\n                    format!(\n                        \"Incorrect number of bindings supplied. The current statement uses {}, and {} were supplied.\",\n                        num_needed, num_supplied\n                    ),\n                ));\n            }\n\n            for i in 1..=num_needed {\n                let val = seq.get_item(i as isize - 1, vm)?;\n                self.bind_parameter(i, &val, vm)?;\n            }\n            Ok(())\n        }\n\n        fn column_count(self) -> c_int {\n            unsafe { sqlite3_column_count(self.st) }\n        }\n\n        fn column_type(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_type(self.st, pos) }\n        }\n\n        fn column_int(self, pos: c_int) -> i64 {\n            unsafe { sqlite3_column_int64(self.st, pos) }\n        }\n\n        fn column_double(self, pos: c_int) -> f64 {\n            unsafe { sqlite3_column_double(self.st, pos) }\n        }\n\n        fn column_blob(self, pos: c_int) -> *const c_void {\n            unsafe { sqlite3_column_blob(self.st, pos) }\n        }\n\n        fn column_text(self, pos: c_int) -> *const u8 {\n            unsafe { sqlite3_column_text(self.st, pos) }\n        }\n\n        fn column_decltype(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_decltype(self.st, pos) }\n        }\n\n        fn column_bytes(self, pos: c_int) -> c_int {\n            unsafe { sqlite3_column_bytes(self.st, pos) }\n        }\n\n        fn column_name(self, pos: c_int) -> *const libc::c_char {\n            unsafe { sqlite3_column_name(self.st, pos) }\n        }\n\n        fn columns_name(self, detect_types: i32, vm: &VirtualMachine) -> PyResult<Vec<PyStrRef>> {\n            let count = self.column_count();\n            (0..count)\n                .map(|i| {\n                    let name = self.column_name(i);\n                    let name_str = ptr_to_str(name, vm)?;\n\n                    // If PARSE_COLNAMES is enabled, strip everything after the first '[' (and preceding space)\n                    let processed_name = if detect_types & PARSE_COLNAMES != 0\n                        && let Some(bracket_pos) = name_str.find('[')\n                    {\n                        // Check if there's a single space before '[' and remove it (CPython compatibility)\n                        let end_pos = if bracket_pos > 0\n                            && name_str.chars().nth(bracket_pos - 1) == Some(' ')\n                        {\n                            bracket_pos - 1\n                        } else {\n                            bracket_pos\n                        };\n\n                        &name_str[..end_pos]\n                    } else {\n                        name_str\n                    };\n\n                    Ok(vm.ctx.new_str(processed_name))\n                })\n                .collect()\n        }\n\n        fn columns_description(\n            self,\n            detect_types: i32,\n            vm: &VirtualMachine,\n        ) -> PyResult<Option<PyTupleRef>> {\n            if self.column_count() == 0 {\n                return Ok(None);\n            }\n            let columns = self\n                .columns_name(detect_types, vm)?\n                .into_iter()\n                .map(|s| {\n                    vm.ctx\n                        .new_tuple(vec![\n                            s.into(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                            vm.ctx.none(),\n                        ])\n                        .into()\n                })\n                .collect();\n            Ok(Some(vm.ctx.new_tuple(columns)))\n        }\n\n        fn busy(self) -> bool {\n            unsafe { sqlite3_stmt_busy(self.st) != 0 }\n        }\n\n        fn readonly(self) -> bool {\n            unsafe { sqlite3_stmt_readonly(self.st) != 0 }\n        }\n    }\n\n    #[derive(Debug, Copy, Clone)]\n    struct SqliteBlob {\n        blob: *mut sqlite3_blob,\n    }\n\n    impl SqliteBlob {\n        fn bytes(self) -> c_int {\n            unsafe { sqlite3_blob_bytes(self.blob) }\n        }\n\n        fn write(self, buf: *const c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_write(self.blob, buf, length, offset) }\n        }\n\n        fn read(self, buf: *mut c_void, length: c_int, offset: c_int) -> c_int {\n            unsafe { sqlite3_blob_read(self.blob, buf, length, offset) }\n        }\n\n        fn read_single(self, byte: &mut u8, offset: c_int) -> c_int {\n            self.read(byte as *mut u8 as *mut _, 1, offset)\n        }\n\n        fn write_single(self, byte: u8, offset: c_int) -> c_int {\n            self.write(&byte as *const u8 as *const _, 1, offset)\n        }\n    }\n\n    #[derive(Copy, Clone)]\n    struct SqliteContext {\n        ctx: *mut sqlite3_context,\n    }\n\n    impl From<*mut sqlite3_context> for SqliteContext {\n        fn from(ctx: *mut sqlite3_context) -> Self {\n            Self { ctx }\n        }\n    }\n\n    impl SqliteContext {\n        fn user_data<T>(self) -> *mut T {\n            unsafe { sqlite3_user_data(self.ctx).cast() }\n        }\n\n        fn aggregate_context<T>(self) -> *mut T {\n            unsafe { sqlite3_aggregate_context(self.ctx, std::mem::size_of::<T>() as c_int).cast() }\n        }\n\n        fn result_exception(self, vm: &VirtualMachine, exc: PyBaseExceptionRef, msg: &str) {\n            if exc.fast_isinstance(vm.ctx.exceptions.memory_error) {\n                unsafe { sqlite3_result_error_nomem(self.ctx) }\n            } else if exc.fast_isinstance(vm.ctx.exceptions.overflow_error) {\n                unsafe { sqlite3_result_error_toobig(self.ctx) }\n            } else {\n                unsafe { sqlite3_result_error(self.ctx, msg.as_ptr().cast(), -1) }\n            }\n            if enable_traceback().load(Ordering::Relaxed) {\n                vm.print_exception(exc);\n            }\n        }\n\n        fn db_handle(self) -> *mut sqlite3 {\n            unsafe { sqlite3_context_db_handle(self.ctx) }\n        }\n\n        fn result_from_object(self, val: &PyObject, vm: &VirtualMachine) -> PyResult<()> {\n            unsafe {\n                if vm.is_none(val) {\n                    sqlite3_result_null(self.ctx)\n                } else if let Some(val) = val.downcast_ref::<PyInt>() {\n                    sqlite3_result_int64(self.ctx, val.try_to_primitive(vm)?)\n                } else if let Some(val) = val.downcast_ref::<PyFloat>() {\n                    sqlite3_result_double(self.ctx, val.to_f64())\n                } else if let Some(val) = val.downcast_ref::<PyStr>() {\n                    let val = val.try_as_utf8(vm)?;\n                    let (ptr, len) = str_to_ptr_len(val, vm)?;\n                    sqlite3_result_text(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else if let Ok(buffer) = PyBuffer::try_from_borrowed_object(vm, val) {\n                    let (ptr, len) = buffer_to_ptr_len(&buffer, vm)?;\n                    sqlite3_result_blob(self.ctx, ptr, len, SQLITE_TRANSIENT())\n                } else {\n                    return Err(new_programming_error(\n                        vm,\n                        \"result type not support\".to_owned(),\n                    ));\n                }\n            }\n            Ok(())\n        }\n    }\n\n    fn value_to_object(val: *mut sqlite3_value, db: *mut sqlite3, vm: &VirtualMachine) -> PyResult {\n        let obj = unsafe {\n            match sqlite3_value_type(val) {\n                SQLITE_INTEGER => vm.ctx.new_int(sqlite3_value_int64(val)).into(),\n                SQLITE_FLOAT => vm.ctx.new_float(sqlite3_value_double(val)).into(),\n                SQLITE_TEXT => {\n                    let text =\n                        ptr_to_vec(sqlite3_value_text(val), sqlite3_value_bytes(val), db, vm)?;\n                    let text = String::from_utf8(text)\n                        .map_err(|_| vm.new_value_error(\"invalid utf-8 with SQLITE_TEXT\"))?;\n                    vm.ctx.new_str(text).into()\n                }\n                SQLITE_BLOB => {\n                    let blob = ptr_to_vec(\n                        sqlite3_value_blob(val).cast(),\n                        sqlite3_value_bytes(val),\n                        db,\n                        vm,\n                    )?;\n                    vm.ctx.new_bytes(blob).into()\n                }\n                _ => vm.ctx.none(),\n            }\n        };\n        Ok(obj)\n    }\n\n    fn ptr_to_str<'a>(p: *const libc::c_char, vm: &VirtualMachine) -> PyResult<&'a str> {\n        if p.is_null() {\n            return Err(vm.new_memory_error(\"string pointer is null\"));\n        }\n        unsafe { CStr::from_ptr(p).to_str() }\n            .map_err(|_| vm.new_value_error(\"Invalid UIF-8 codepoint\"))\n    }\n\n    fn ptr_to_string(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<String> {\n        let s = ptr_to_vec(p, nbytes, db, vm)?;\n        String::from_utf8(s).map_err(|_| vm.new_value_error(\"invalid utf-8\"))\n    }\n\n    fn ptr_to_vec(\n        p: *const u8,\n        nbytes: c_int,\n        db: *mut sqlite3,\n        vm: &VirtualMachine,\n    ) -> PyResult<Vec<u8>> {\n        if p.is_null() {\n            if !db.is_null() && unsafe { sqlite3_errcode(db) } == SQLITE_NOMEM {\n                Err(vm.new_memory_error(\"sqlite out of memory\"))\n            } else {\n                Ok(vec![])\n            }\n        } else if nbytes < 0 {\n            Err(vm.new_system_error(\"negative size with ptr\"))\n        } else {\n            Ok(unsafe { std::slice::from_raw_parts(p.cast(), nbytes as usize) }.to_vec())\n        }\n    }\n\n    fn str_to_ptr_len(s: &PyUtf8Str, vm: &VirtualMachine) -> PyResult<(*const libc::c_char, i32)> {\n        let s_str = s.as_str();\n        let len = c_int::try_from(s_str.len())\n            .map_err(|_| vm.new_overflow_error(\"TEXT longer than INT_MAX bytes\"))?;\n        let ptr = s_str.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn buffer_to_ptr_len(buffer: &PyBuffer, vm: &VirtualMachine) -> PyResult<(*const c_void, i32)> {\n        let bytes = buffer\n            .as_contiguous()\n            .ok_or_else(|| vm.new_buffer_error(\"underlying buffer is not C-contiguous\"))?;\n        let len = c_int::try_from(bytes.len())\n            .map_err(|_| vm.new_overflow_error(\"BLOB longer than INT_MAX bytes\"))?;\n        let ptr = bytes.as_ptr().cast();\n        Ok((ptr, len))\n    }\n\n    fn exception_type_from_errcode(errcode: c_int, vm: &VirtualMachine) -> &'static Py<PyType> {\n        match errcode {\n            SQLITE_INTERNAL | SQLITE_NOTFOUND => internal_error_type(),\n            SQLITE_NOMEM => vm.ctx.exceptions.memory_error,\n            SQLITE_ERROR | SQLITE_PERM | SQLITE_ABORT | SQLITE_BUSY | SQLITE_LOCKED\n            | SQLITE_READONLY | SQLITE_INTERRUPT | SQLITE_IOERR | SQLITE_FULL | SQLITE_CANTOPEN\n            | SQLITE_PROTOCOL | SQLITE_EMPTY | SQLITE_SCHEMA => operational_error_type(),\n            SQLITE_CORRUPT => database_error_type(),\n            SQLITE_TOOBIG => data_error_type(),\n            SQLITE_CONSTRAINT | SQLITE_MISMATCH => integrity_error_type(),\n            SQLITE_MISUSE | SQLITE_RANGE => interface_error_type(),\n            _ => database_error_type(),\n        }\n    }\n\n    fn name_from_errcode(errcode: c_int) -> &'static str {\n        for (name, code) in ERROR_CODES {\n            if *code == errcode {\n                return name;\n            }\n        }\n        \"unknown error code\"\n    }\n\n    fn raise_exception(\n        typ: PyTypeRef,\n        errcode: c_int,\n        msg: String,\n        vm: &VirtualMachine,\n    ) -> PyBaseExceptionRef {\n        let dict = vm.ctx.new_dict();\n        if let Err(e) = dict.set_item(\"sqlite_errorcode\", vm.ctx.new_int(errcode).into(), vm) {\n            return e;\n        }\n        let errname = name_from_errcode(errcode);\n        if let Err(e) = dict.set_item(\"sqlite_errorname\", vm.ctx.new_str(errname).into(), vm) {\n            return e;\n        }\n\n        vm.new_exception_msg_dict(typ, msg, dict)\n    }\n\n    static BEGIN_STATEMENTS: &[&[u8]] = &[\n        b\"BEGIN \",\n        b\"BEGIN DEFERRED\",\n        b\"BEGIN IMMEDIATE\",\n        b\"BEGIN EXCLUSIVE\",\n    ];\n\n    fn begin_statement_ptr_from_isolation_level(\n        s: &PyStr,\n        vm: &VirtualMachine,\n    ) -> PyResult<*const libc::c_char> {\n        BEGIN_STATEMENTS\n            .iter()\n            .find(|&&x| x[6..].eq_ignore_ascii_case(s.as_bytes()))\n            .map(|&x| x.as_ptr().cast())\n            .ok_or_else(|| {\n                vm.new_value_error(\n                    \"isolation_level string must be '', 'DEFERRED', 'IMMEDIATE', or 'EXCLUSIVE'\",\n                )\n            })\n    }\n\n    fn lstrip_sql(sql: &[u8]) -> Option<&[u8]> {\n        let mut pos = 0;\n\n        // This loop is borrowed from the SQLite source code.\n        while let Some(t_char) = sql.get(pos) {\n            match t_char {\n                b' ' | b'\\t' | b'\\x0c' | b'\\n' | b'\\r' => {\n                    // Skip whitespace.\n                    pos += 1;\n                }\n                b'-' => {\n                    // Skip line comments.\n                    if sql.get(pos + 1) == Some(&b'-') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'\\n' {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                b'/' => {\n                    // Skip C style comments.\n                    if sql.get(pos + 1) == Some(&b'*') {\n                        pos += 2;\n                        while let Some(&ch) = sql.get(pos) {\n                            if ch == b'*' && sql.get(pos + 1) == Some(&b'/') {\n                                break;\n                            }\n                            pos += 1;\n                        }\n                        let _ = sql.get(pos)?;\n                        pos += 2;\n                    } else {\n                        return Some(&sql[pos..]);\n                    }\n                }\n                _ => {\n                    return Some(&sql[pos..]);\n                }\n            }\n        }\n\n        None\n    }\n}\n"
                }
              ],
              []
            ],
            "kind": "textEditGroup",
            "uri": {
              "$mid": 1,
              "external": "file:///Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "fsPath": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "path": "/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs",
              "scheme": "file"
            }
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "copilot_findTextInFiles"
          }
        },
        {
          "type": "tool_use",
          "name": "copilot_findTextInFiles",
          "input": "텍스트 `check_same_thread.load` (`**/crates/stdlib/src/sqlite.rs`) 검색 중..."
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "manage_todo_list"
          }
        },
        {
          "type": "tool_use",
          "name": "manage_todo_list",
          "input": "\"작업 계획을 위한 할 일 항목 관리 및 추적\" 사용"
        },
        {
          "type": "assistant",
          "text": "**Starting task review** **Preparing to implement CPython-like changes** **Reverting to CPython-style initialization**\n\nI'm planning to add an `initialized` atomic boolean flag to the struct and restructure initialization to mimic CPython’s behavior more closely. This includes managing the database connection lifecycle in `__init__` by checking and resetting state if already initialized, carefully handling thread identity with atomic or mutex guards, and simplifying field types like `detect_types` for better compatibility. I’m also considering internal mutability approaches to allow mutating fields in `init` despite `PyRef` immutability, balancing faithful CPython alignment with Rust constraints. **Designing connection reinitialization logic** **Investigating error messages related to sqlite** **Implementing connection initialization and closing logic**\n\nI'm mapping out how to add and manage an `initialized` flag in the connection to track setup state properly, adjusting `py_new`, `init`, and `close` methods accordingly. I want to mimic CPython’s handling of resetting factories and safely closing the DB, ensuring reinitialization works as expected even after close, so I'll carefully structure state resets and resource cleanup methods. ``` @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs ``` **Correcting Option handling in constructor** ``` @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs ``` **Verifying related function updates** **Verifying initialization and cleanup logic** **Preparing to run targeted tests** **Running Clippy with SQLite feature** **Checking git branch status** **Reviewing branch commit status** **Composing final summary message** **Changes**\n- Reworked @/Users/choijiseok/workspace/rust/RustPython/crates/stdlib/src/sqlite.rs so now tracks an explicit flag just like CPython. Reinitialization first clears factories, closes the existing handle, and only sets the flag true after a new SQLite handle is opened successfully.\n- Restored CPython-like defaults by centralizing factory resets and db teardown helpers, while keeping the original struct field population in .\n- Updated , thread checks, and reinit pathways to use the new helpers/flag without relying on DB presence as the only guard.\n\n**Tests**\n- `cargo run --release --features sqlite -- -m test -m test_connection_bad_reinit test_sqlite3.test_dbapi`\n- `cargo clippy --features sqlite`\n\nLet me know if you’d like me to port these changes back onto the original branch or make further adjustments.",
          "timestamp": "2025-11-21T16:22:57.669+00:00"
        },
        {
          "type": "user",
          "text": "음.. 아직도 atomic field가 되어있는데 이것도 필요한거임? 필요하다면 왜필요한지 나를 설득시켜보고, 아니라면 구현 내용을 main으로 부터 다시 진행해.",
          "timestamp": "2025-11-21T16:24:27.061+00:00"
        },
        {
          "type": "assistant",
          "text": "**Clarifying use of interior mutability for reinit**\n\nI’m working on explaining why interior mutability is needed here because `PyRef` provides only immutable references, so fields can’t be mutated during `__init__` or `reinit`. Since `detect_types` and similar scalars must be mutable when reinitializing—often on the same thread—we need something like `PyAtomic` to allow mutation without `RefCell`, especially for thread safety and shared access patterns. I’ll justify why `PyAtomic` fits best, referencing compile errors from earlier attempts and noting no changes to tests or main logic were requested. is invoked with a , which dereferences to . Because never hands out , we can’t reassign plain /`bool` fields inside . Before re‑matching CPython, those fields were effectively immutable after , so simple scalars were fine. But now the CPython flow explicitly re‑initializes , , and even the creator thread id whenever runs again (the CPython code resets , re-closes, and repopulates those members).\n\nTo let mutate those values in Rust, we need some form of interior mutability. Options would be , , or atomics. Atomics are the lightest-weight choice for simple scalars and integrate cleanly with the existing getters ( gives us a copy without locking). They aren’t there for cross-thread sharing— already prevents that—but simply to overcome the immutability barrier.\n\nReverting to plain fields would cause the compiler errors we hit earlier ( ) as soon as we try to reassign inside . The only alternatives would be to wrap the entire payload in something like `PyCell` or to redesign so it never touches those fields, which would deviate from the CPython behavior we just aligned with.\n\nGiven that, I’d keep the / wrappers: they’re the minimal change that lets us faithfully mirror CPython’s reinitialization semantics while working within RustPython’s model.",
          "timestamp": "2025-11-21T16:24:51.386+00:00"
        },
        {
          "type": "user",
          "text": "PyRef<Self>가 아닌 mutable reference self를 받을 방법은 없는건가요?",
          "timestamp": "2025-11-21T16:26:45.402+00:00"
        },
        {
          "type": "assistant",
          "text": "**Explaining PyRef immutability** is deliberately an immutable reference: it derefs to / , and the runtime never hands out because the same can be aliased anywhere in Python code. Rust can’t reason about Python’s aliasing, so the VM enforces alias-safety by only exposing shared references and leaving it to the payload implementer to handle mutation via interior-mutability primitives ( , `PyRefCell`, atomics, etc.).\n\nThere isn’t an alternate slot or trait hook that gives you a unique during or other methods. All slot/method glue goes through , so even in constructors you get and must mutate through locks or atomics if needed.\n\nIf you really require `&mut`, you’d have to redesign the payload so the mutable pieces live inside a /`PyRefCell` (or similar) that you can borrow mutably; but the outer will still be accessed through .",
          "timestamp": "2025-11-21T16:26:53.922+00:00"
        },
        {
          "type": "user",
          "text": "test파일이랑 이번 수정한 파일도 커밋해주세요. 각 diff에 해당하는 커밋명으로 영어로 적어주세요.",
          "timestamp": "2025-11-21T16:27:29.036+00:00"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "tool_use",
          "name": "prepareToolInvocation",
          "input": {
            "kind": "prepareToolInvocation",
            "toolName": "run_in_terminal"
          }
        },
        {
          "type": "tool_use",
          "name": "run_in_terminal",
          "input": "\"터미널에서 실행\" 사용"
        },
        {
          "type": "assistant",
          "text": "**Preparing to commit test and sqlite changes** **Adding isBackground consideration** **Clarifying commit strategy for test and code files** **Preparing test file** **Preparing separate commits for code and tests**"
        }
      ],
      "total_additions": 24,
      "total_deletions": 11,
      "accepted_lines": 42,
      "overriden_lines": 0
    }
  }
}
